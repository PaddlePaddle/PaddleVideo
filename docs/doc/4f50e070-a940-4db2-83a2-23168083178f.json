{
    "summary": "This code defines a 3D ROI extractor class and head, performing feature extraction with optional temporal pooling. The forward method executes feature extraction based on input features, RoIs, and number of RoIs, and returns the final output after applying ROI layer and stacking features along axis 2.",
    "details": [
        {
            "comment": "This code imports necessary libraries and registers a new ROI (Region of Interest) extractor named \"SingleRoIExtractor3D\". This class inherits from nn.Layer and is designed to extract RoI features from a single level feature map with specific options such as roi_layer_type, featmap_stride, output_size, and sampling_ratio.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/single_straight3d.py\":0-27",
            "content": "# copyright (c) 2021 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport paddle\nimport paddle.nn as nn\nimport numpy as np\nfrom ..registry import ROI_EXTRACTORS\nfrom .roi_extractor import RoIAlign\n@ROI_EXTRACTORS.register()\nclass SingleRoIExtractor3D(nn.Layer):\n    \"\"\"Extract RoI features from a single level feature map.  \"\"\"\n    def __init__(self,\n                 roi_layer_type='RoIAlign',\n                 featmap_stride=16,\n                 output_size=16,\n                 sampling_ratio=0,"
        },
        {
            "comment": "This code defines a class for a 3D head that takes input features and regions of interest (ROIs) to extract features using the RoIAlign layer. It also includes an optional temporal pooling operation and an initialization function. The forward method performs feature extraction given the input features, ROIs, and number of ROIs.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/single_straight3d.py\":28-54",
            "content": "                 pool_mode='avg',\n                 aligned=True,\n                 with_temporal_pool=True,\n                 with_global=False):\n        super().__init__()\n        self.roi_layer_type = roi_layer_type\n        assert self.roi_layer_type in ['RoIPool', 'RoIAlign']\n        self.featmap_stride = featmap_stride\n        self.spatial_scale = 1. / self.featmap_stride\n        self.output_size = output_size\n        self.sampling_ratio = sampling_ratio\n        self.pool_mode = pool_mode\n        self.aligned = aligned\n        self.with_temporal_pool = with_temporal_pool\n        self.with_global = with_global\n        self.roi_layer = RoIAlign(resolution=self.output_size,\n                                  spatial_scale=self.spatial_scale,\n                                  sampling_ratio=self.sampling_ratio,\n                                  aligned=self.aligned)\n    def init_weights(self):\n        pass\n    # The shape of feat is N, C, T, H, W\n    def forward(self, feat, rois, rois_num):\n        if len(feat) >= 2:"
        },
        {
            "comment": "This code performs temporal pooling, concatenates slow and fast features, extracts frame-wise features using index selection, squeezes the dimensions to prevent deletion when N=1, applies a ROI layer on each frame, stacks the resulting features along axis 2, and returns the final output.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/single_straight3d.py\":55-78",
            "content": "            assert self.with_temporal_pool\n        if self.with_temporal_pool:\n            xi = 0\n            for x in feat:\n                xi = xi + 1\n                y = paddle.mean(x, 2, keepdim=True)\n            feat = [paddle.mean(x, 2, keepdim=True) for x in feat]\n        feat = paddle.concat(feat, axis=1)  # merge slow and fast\n        roi_feats = []\n        for t in range(feat.shape[2]):\n            if type(t) == paddle.static.Variable:\n                index = paddle.to_tensor(t)\n            else:\n                data_index = np.array([t]).astype('int32')\n                index = paddle.to_tensor(data_index)\n            frame_feat = paddle.index_select(feat, index, axis=2)\n            frame_feat = paddle.squeeze(frame_feat,\n                                        axis=2)  #axis=2,\u907f\u514dN=1\u65f6, \u7b2c\u4e00\u7ef4\u5ea6\u88ab\u5220\u9664.\n            roi_feat = self.roi_layer(frame_feat, rois, rois_num)\n            roi_feats.append(roi_feat)\n        ret = paddle.stack(roi_feats, axis=2)\n        return ret"
        }
    ]
}