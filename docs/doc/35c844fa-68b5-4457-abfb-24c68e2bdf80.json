{
    "summary": "The MultiCropMetric class in PaddleVideo computes top-1/5 accuracy using multi-crop metrics for each video label and logs average values.",
    "details": [
        {
            "comment": "This code snippet defines a class for MultiCropMetric, which is part of the PaddleVideo library. It initializes instances with various parameters such as data_size, batch_size, num_ensemble_views, num_spatial_crops, and num_classes. The log_interval parameter determines how often to update logs during training. This metric appears to be related to slowfast video processing, as specified in the comment.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/multi_crop_metric.py\":0-34",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nimport numpy as np\nimport paddle\nfrom paddle.hapi.model import _all_gather\nfrom paddlevideo.utils import get_logger\nfrom .registry import METRIC\nfrom .base import BaseMetric\nlogger = get_logger(\"paddlevideo\")\n\"\"\" An example for metrics class.\n    MultiCropMetric for slowfast.\n\"\"\"\n@METRIC.register\nclass MultiCropMetric(BaseMetric):\n    def __init__(self,\n                 data_size,\n                 batch_size,\n                 num_ensemble_views,\n                 num_spatial_crops,\n                 num_classes,\n                 log_interval=1):"
        },
        {
            "comment": "This code initializes a multi-crop metric class, which takes data size, batch size, log interval, number of ensemble views, and number of spatial crops as parameters. It calculates the number of videos and clips, creates arrays to store video predictions and labels, and initializes a clip_count dictionary. The update method is used to update metrics during each iteration by gathering data across multiple cards if needed, converting outputs to numpy arrays.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/multi_crop_metric.py\":35-60",
            "content": "        \"\"\"prepare for metrics\n        \"\"\"\n        super().__init__(data_size, batch_size, log_interval)\n        self.num_ensemble_views = num_ensemble_views\n        self.num_spatial_crops = num_spatial_crops\n        self.num_classes = num_classes\n        self.num_clips = self.num_ensemble_views * self.num_spatial_crops\n        num_videos = self.data_size // self.num_clips\n        self.video_preds = np.zeros((num_videos, self.num_classes))\n        self.video_labels = np.zeros((num_videos, 1), dtype=\"int64\")\n        self.clip_count = {}\n    def update(self, batch_id, data, outputs):\n        \"\"\"update metrics during each iter\n        \"\"\"\n        labels = data[2]\n        clip_ids = data[3]\n        # gather mulit card, results of following process in each card is the same.\n        if self.world_size > 1:\n            outputs = _all_gather(outputs, self.world_size)\n            labels = _all_gather(labels.cuda(), self.world_size)\n            clip_ids = _all_gather(clip_ids.cuda(), self.world_size)\n        # to numpy"
        },
        {
            "comment": "The code loops through each prediction and label for video clips in a batch. It checks if the clip index has been encountered before for a particular video ID, and updates the count if it's a new clip or performs ensemble by summing predictions if it's not. If there are labels for a video, it asserts they match and updates the label accordingly. The code also logs processing information at log intervals.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/multi_crop_metric.py\":61-82",
            "content": "        preds = outputs.numpy()\n        labels = labels.numpy().astype(\"int64\")\n        clip_ids = clip_ids.numpy()\n        # preds ensemble\n        for ind in range(preds.shape[0]):\n            vid_id = int(clip_ids[ind]) // self.num_clips\n            ts_idx = int(clip_ids[ind]) % self.num_clips\n            if vid_id not in self.clip_count:\n                self.clip_count[vid_id] = []\n            if ts_idx in self.clip_count[vid_id]:\n                logger.info(\n                    \"[TEST] Passed!! read video {} clip index {} / {} repeatedly.\"\n                    .format(vid_id, ts_idx, clip_ids[ind]))\n            else:\n                self.clip_count[vid_id].append(ts_idx)\n                self.video_preds[vid_id] += preds[ind]  # ensemble method: sum\n                if self.video_labels[vid_id].sum() > 0:\n                    assert self.video_labels[vid_id] == labels[ind]\n                self.video_labels[vid_id] = labels[ind]\n        if batch_id % self.log_interval == 0:\n            logger.info(\"[TEST] Processing batch {}/{} ...\".format("
        },
        {
            "comment": "This code defines a class that accumulates metrics when all iterations are finished. It checks if the number of clips and their counts match, logging an error if not. Then, it converts video predictions and labels to Paddle tensors and calculates top-1 and top-5 accuracy using Paddle's metric library.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/multi_crop_metric.py\":83-103",
            "content": "                batch_id,\n                self.data_size // (self.batch_size * self.world_size)))\n    def accumulate(self):\n        \"\"\"accumulate metrics when finished all iters.\n        \"\"\"\n        # check clip index of each video\n        for key in self.clip_count.keys():\n            if len(self.clip_count[key]) != self.num_clips or sum(\n                    self.clip_count[key]) != self.num_clips * (self.num_clips -\n                                                               1) / 2:\n                logger.info(\n                    \"[TEST] Count Error!! video [{}] clip count [{}] not match number clips {}\"\n                    .format(key, self.clip_count[key], self.num_clips))\n        video_preds = paddle.to_tensor(self.video_preds)\n        video_labels = paddle.to_tensor(self.video_labels)\n        acc_top1 = paddle.metric.accuracy(input=video_preds,\n                                          label=video_labels,\n                                          k=1)\n        acc_top5 = paddle.metric.accuracy(input=video_preds,"
        },
        {
            "comment": "Calculates top-1 and top-5 accuracy using multi-crop metric for each video label, then logs the average accuracy values.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/multi_crop_metric.py\":104-107",
            "content": "                                          label=video_labels,\n                                          k=5)\n        logger.info('[TEST] finished, avg_acc1= {}, avg_acc5= {} '.format(\n            acc_top1.numpy(), acc_top5.numpy()))"
        }
    ]
}