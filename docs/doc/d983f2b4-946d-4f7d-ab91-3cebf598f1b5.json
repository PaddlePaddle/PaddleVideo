{
    "summary": "The \"InferModel\" class is a GPU-optimized inference function for generating action boundaries in videos using propositions and scoring functions. It calculates running averages of predictions, predicts video features, and saves results as proposals in 'results.json'.",
    "details": [
        {
            "comment": "The code defines a class called \"InferModel\" which implements the bmn infer function. It initializes the model with specified configuration and enables GPU usage if available. The class takes in a config file that specifies model, parameters files, GPU memory, device ID, thread count for nms, minimum prediction score threshold, and frame thread count. The code also switches on IR optimizations and enables memory optimization for efficient execution of the model.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/models/bmn_infer.py\":0-38",
            "content": "\"\"\"\nppTSM InferModel\n\"\"\"\nimport sys\nimport numpy as np\nimport json\nimport pickle\nimport time\nsys.path.append('../')\nfrom utils.preprocess import get_images\nfrom utils.config_utils import parse_config\nfrom utils.process_result import process_proposal\nimport reader\nfrom paddle.inference import Config\nfrom paddle.inference import create_predictor\nclass InferModel(object):\n    \"\"\"bmn infer\"\"\"\n    def __init__(self, cfg, name='BMN'):\n        name = name.upper()\n        self.name = name\n        model_file = cfg[name]['model_file']\n        params_file = cfg[name]['params_file']\n        gpu_mem = cfg[name]['gpu_mem']\n        device_id = cfg[name]['device_id']\n        self.nms_thread = cfg[name]['nms_thread']\n        self.min_pred_score = cfg[name]['score_thread']\n        self.min_frame_thread = cfg['COMMON']['fps']\n        # model init\n        config = Config(model_file, params_file)\n        config.enable_use_gpu(gpu_mem, device_id)\n        config.switch_ir_optim(True)  # default true\n        config.enable_memory_optim()\n        # use zero copy"
        },
        {
            "comment": "The code initializes a predictor, sets input and output tensors for inference, and defines an \"infer\" method to perform inference. The \"generate_props\" function takes predictions, start and end timestamps, and generates properties based on the given parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/models/bmn_infer.py\":39-64",
            "content": "        config.switch_use_feed_fetch_ops(False)\n        self.predictor = create_predictor(config)\n        input_names = self.predictor.get_input_names()\n        self.input_tensor = self.predictor.get_input_handle(input_names[0])\n        output_names = self.predictor.get_output_names()\n        self.output1_tensor = self.predictor.get_output_handle(output_names[0])\n        self.output2_tensor = self.predictor.get_output_handle(output_names[1])\n        self.output3_tensor = self.predictor.get_output_handle(output_names[2])\n    def infer(self, input):\n        \"\"\"infer\"\"\"\n        self.input_tensor.copy_from_cpu(input)\n        self.predictor.run()\n        output1 = self.output1_tensor.copy_to_cpu()\n        output2 = self.output2_tensor.copy_to_cpu()\n        output3 = self.output3_tensor.copy_to_cpu()\n        return output1, output2, output3\n    def generate_props(self,\n                       pred_bmn,\n                       pred_start,\n                       pred_end,\n                       max_window=200,\n                       min_window=5):"
        },
        {
            "comment": "This code generates propositions for action boundaries in a video. It iterates through possible window sizes to find valid start and end indices, checks if start and end masks match, then computes the confidence score based on boundary scores and BNM score. The results are stored as a list of [xmin, xmax, confidence] values.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/models/bmn_infer.py\":65-86",
            "content": "        \"\"\"generate_props\"\"\"\n        video_len = min(pred_bmn.shape[-1],\n                        min(pred_start.shape[-1], pred_end.shape[-1]))\n        pred_bmn = pred_bmn[0, :, :] * pred_bmn[1, :, :]\n        start_mask = self.boundary_choose(pred_start)\n        start_mask[0] = 1.\n        end_mask = self.boundary_choose(pred_end)\n        end_mask[-1] = 1.\n        score_results = []\n        for idx in range(min_window, max_window):\n            for jdx in range(video_len):\n                start_index = jdx\n                end_index = start_index + idx\n                if end_index < video_len and start_mask[\n                        start_index] == 1 and end_mask[end_index] == 1:\n                    xmin = start_index\n                    xmax = end_index\n                    xmin_score = pred_start[start_index]\n                    xmax_score = pred_end[end_index]\n                    bmn_score = pred_bmn[idx, jdx]\n                    conf_score = xmin_score * xmax_score * bmn_score\n                    score_results.append([xmin, xmax, conf_score])"
        },
        {
            "comment": "The code defines three functions: \"action_detect.models.bmn_infer.py\" contains the \"score_results\", \"boundary_choose\", and \"predict\" functions. The \"score_results\" function returns a list of scores for each action. The \"boundary_choose\" function determines boundary scores based on peak, front, and back scores. It uses masks to identify relevant positions in the score list. Finally, the \"predict\" function initializes an infer reader, iterates through data, and gathers input data for prediction.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/models/bmn_infer.py\":87-111",
            "content": "        return score_results\n    def boundary_choose(self, score_list):\n        \"\"\"boundary_choose\"\"\"\n        max_score = max(score_list)\n        mask_high = (score_list > max_score * 0.5)\n        score_list = list(score_list)\n        score_middle = np.array([0.0] + score_list + [0.0])\n        score_front = np.array([0.0, 0.0] + score_list)\n        score_back = np.array(score_list + [0.0, 0.0])\n        mask_peak = ((score_middle > score_front) & (score_middle > score_back))\n        mask_peak = mask_peak[1:-1]\n        mask = (mask_high | mask_peak).astype('float32')\n        return mask\n    def predict(self, infer_config, material):\n        \"\"\"predict\"\"\"\n        infer_reader = reader.get_reader(self.name,\n                                         'infer',\n                                         infer_config,\n                                         material=material)\n        feature_list = []\n        for infer_iter, data in enumerate(infer_reader()):\n            inputs = [items[0] for items in data]\n            winds = [items[1] for items in data]"
        },
        {
            "comment": "This code performs a running average of predictions from a series of windows. It calculates the sum of each prediction for each window, divides it by the count of non-zero frames in that window, and stores the results in `sum_pred_bmn`, `sum_pred_sta`, and `sum_pred_end`. Finally, it divides these sums by the corresponding counts to get the final predictions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/models/bmn_infer.py\":112-134",
            "content": "            feat_info = [items[2] for items in data]\n            feature_T = feat_info[0][0]\n            feature_N = feat_info[0][1]\n            inputs = np.array(inputs)\n            pred_bmn, pred_sta, pred_end = self.infer(inputs)\n            if infer_iter == 0:\n                sum_pred_bmn = np.zeros((2, feature_N, feature_T))\n                sum_pred_sta = np.zeros((feature_T, ))\n                sum_pred_end = np.zeros((feature_T, ))\n                sum_pred_cnt = np.zeros((feature_T, ))\n            for idx, sub_wind in enumerate(winds):\n                sum_pred_bmn[:, :, sub_wind[0]:sub_wind[1]] += pred_bmn[idx]\n                sum_pred_sta[sub_wind[0]:sub_wind[1]] += pred_sta[idx]\n                sum_pred_end[sub_wind[0]:sub_wind[1]] += pred_end[idx]\n                sum_pred_cnt[sub_wind[0]:sub_wind[1]] += np.ones(\n                    (sub_wind[1] - sub_wind[0], ))\n        pred_bmn = sum_pred_bmn / sum_pred_cnt\n        pred_sta = sum_pred_sta / sum_pred_cnt\n        pred_end = sum_pred_end / sum_pred_cnt"
        },
        {
            "comment": "The code initializes an instance of the InferModel class from the given configuration file. It then predicts the video features by calling the model's predict method, passing the video features as input and returns the results in the form of proposals. The output is then saved to a JSON file named 'results.json'.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/models/bmn_infer.py\":136-163",
            "content": "        score_result = self.generate_props(pred_bmn, pred_sta, pred_end)\n        results = process_proposal(score_result, self.min_frame_thread,\n                                   self.nms_thread, self.min_pred_score)\n        return results\nif __name__ == \"__main__\":\n    cfg_file = '/home/work/inference/configs/configs.yaml'\n    cfg = parse_config(cfg_file)\n    model = InferModel(cfg)\n    imgs_path = '/home/work/datasets/WorldCup2018/frames/6e577252c4004961ac7caa738a52c238'\n    # feature\n    feature_path = imgs_path.replace(\"frames\", \"features\") + '.pkl'\n    video_features = pickle.load(open(feature_path, 'rb'))\n    t0 = time.time()\n    outputs = model.predict(cfg, video_features)\n    # outputs = model.infer(np.random.rand(32, 8, 3, 224, 224).astype(np.float32))\n    t1 = time.time()\n    results = {'proposal': outputs}\n    with open('results.json', 'w', encoding='utf-8') as f:\n        data = json.dumps(results, indent=4, ensure_ascii=False)\n        f.write(data)\n    print('cost time = {} min'.format((t1 - t0) / 60.0))"
        }
    ]
}