{
    "summary": "This code retrieves images, converts them to JSON format and stores object locations. It also processes videos, creating JSON annotations on frames with functions for video loading/saving, image resizing, mask processing, and PNG saving.",
    "details": [
        {
            "comment": "Code imports necessary libraries and defines two functions. `get_images` retrieves image files from a specified sequence, sorts them, and returns as a numpy array. `json2frame` reads a JSON file and converts its overlays into Image objects in a list format.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/api.py\":0-38",
            "content": "# Author: AP-Kai\n# Datetime: 2022/1/10\n# Copyright belongs to the author.\n# Please indicate the source for reprinting.\nimport json\nimport os\nfrom collections import OrderedDict\nimport cv2\nimport numpy as np\nfrom PIL import Image\nfrom EIVideo.paddlevideo.utils.manet_utils import overlay_davis\nfrom EIVideo import TEMP_JSON_SAVE_PATH, TEMP_JSON_FINAL_PATH\ndef get_images(sequence='bike-packing'):\n    img_path = os.path.join('data', sequence.strip(), 'frame')\n    img_files = os.listdir(img_path)\n    img_files.sort()\n    files = []\n    for img in img_files:\n        img_file = np.array(Image.open(os.path.join(img_path, img)))\n        files.append(img_file)\n    return np.array(files)\ndef json2frame(path):\n    print(\"now turn masks.json to frames\", path)\n    with open(path, 'r', encoding='utf-8') as f:\n        res = f.read()\n        a = json.loads(res)\n        b = a.get('overlays')\n        b_array = np.array(b)\n        frame_list = []\n        for i in range(0, len(b_array)):\n            im = Image.fromarray(np.uint8(b_array[i]))"
        },
        {
            "comment": "The code converts a PNG image to JSON format. It opens the image using PIL, converts it to grayscale, and stores the unique object IDs found in the image. For each object ID, it finds its corresponding locations in the image and adds them as paths to the pframe (an OrderedDict). Finally, it appends the pframes to a list called pframes. The function returns this list of pframes when complete.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/api.py\":39-66",
            "content": "            im = cv2.cvtColor(np.asarray(im), cv2.COLOR_RGB2BGR)\n            im = cv2.cvtColor(im, cv2.COLOR_RGB2BGR)\n            # im = np.array(b_array[i]).astype(\"uint8\")\n            # im = im.transpose((2, 0, 1))\n            # im = cv2.merge(im)\n            frame_list.append(im)\n    return frame_list\ndef png2json(image_path, sliderframenum, save_json_path):\n    image = Image.open(image_path)  # \u7528PIL\u4e2d\u7684Image.open\u6253\u5f00\u56fe\u50cf\n    image = image.convert('P')\n    image_arr = np.array(image)  # \u8f6c\u5316\u6210numpy\u6570\u7ec4\n    image_arr = image_arr.astype(\"float32\")\n    r1 = np.argwhere(image_arr == 1)  # tuple\n    pframes = []\n    # i -> object id\n    for i in range(1, len(np.unique(image_arr))):\n        pframe = OrderedDict()\n        pframe['path'] = []\n        # Find object id in image_arr\n        r1 = np.argwhere(image_arr == i)  # tuple\n        r1 = r1.astype(\"float32\")\n        # Add path to pframe\n        for j in range(0, len(r1)):\n            r1[j][0] = r1[j][0] / 480.0\n            r1[j][1] = r1[j][1] / 910.0\n            # r1[j] = np.around(r1[j], decimals=16)"
        },
        {
            "comment": "This code is related to video processing, specifically for saving and loading videos. It creates a JSON file with scribble annotations on frames. The \"load_video\" function reads the video frames and converts them to RGB format if necessary. It also supports optional minimum side parameter for resizing frames.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/api.py\":67-100",
            "content": "            pframe['path'].append(r1[j].tolist())\n        # Add object id, start_time, stop_time\n        pframe['object_id'] = i\n        pframe['start_time'] = sliderframenum\n        pframe['stop_time'] = sliderframenum\n        # Add pframe to pframes\n        pframes.append(pframe)\n    dic = OrderedDict()\n    dic['scribbles'] = []\n    for i in range(0, int(100)):\n        if i == sliderframenum:\n            # Add value to frame[]\n            dic['scribbles'].append(pframes)\n        else:\n            dic['scribbles'].append([])\n    json_str = json.dumps(dic)\n    with open(save_json_path, 'w') as json_file:\n        json_file.write(json_str)\ndef load_video(video_path, min_side=None):\n    frame_list = []\n    # ToDo To AP-kai: \u662f\u4e0d\u662f\u8f7b\u677e\u5e72\u6389\u4e86m.video_path\uff1f\n    cap = cv2.VideoCapture(video_path)\n    # ToDo To AP-kai: while (cap.isOpened()): -> \u4e0d\u5fc5\u591a\u5199\u4e2a\u62ec\u53f7\u54c8\n    while cap.isOpened():\n        _, frame = cap.read()\n        if frame is None:\n            break\n        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        if min_side:\n            h, w = frame.shape[:2]"
        },
        {
            "comment": "Code chunk resizes images, appends them to a list, stacks the frames into an array and returns both. It also handles loading data from TEMP_JSON_SAVE_PATH and yields scribbles with a boolean flag for the first one. The last function processes masks by overlaying them onto images, saves them as PNGs in the specified save path.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/api.py\":101-129",
            "content": "            new_w = (w * min_side // min(w, h))\n            new_h = (h * min_side // min(w, h))\n            frame = cv2.resize(frame, (new_w, new_h),\n                               interpolation=cv2.INTER_CUBIC)\n            # .transpose([2, 0, 1])\n        frame_list.append(frame)\n    frames = np.stack(frame_list, axis=0)\n    return frames, frame_list\ndef get_scribbles():\n    # os.makedirs(TEMP_JSON_SAVE_PATH, exist_ok=True)\n    with open(TEMP_JSON_SAVE_PATH) as f:\n        print(\"load TEMP_JSON_SAVE_PATH success\")\n        scribbles = json.load(f)\n        first_scribble = True\n        yield scribbles, first_scribble\ndef submit_masks(save_path, masks, images):\n    overlays = []\n    for img_name, (mask, image) in enumerate(zip(masks, images)):\n        overlay = overlay_davis(image, mask)\n        overlays.append(overlay.tolist())\n        overlay = Image.fromarray(overlay)\n        img_name = str(img_name)\n        while len(img_name) < 5:\n            img_name = '0' + img_name\n        overlay.save(os.path.join(save_path, img_name + '.png'))"
        },
        {
            "comment": "This code is saving a dictionary of overlays to a JSON file. It was previously also saving a list of masks, but that functionality has been commented out. The dictionary contains the overlays and the resulting JSON will be written to the specified temporary path.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/api.py\":130-133",
            "content": "    result = {'overlays': overlays}\n    # result = {'masks': masks.tolist()}\n    with open(TEMP_JSON_FINAL_PATH, 'w') as f:\n        json.dump(result, f)"
        }
    ]
}