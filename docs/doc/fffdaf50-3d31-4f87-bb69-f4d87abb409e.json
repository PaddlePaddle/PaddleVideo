{
    "summary": "This code normalizes, scales, and converts images for inference using a ten-crop technique within the PaddleVideo library's implementation of pre-processing operations.",
    "details": [
        {
            "comment": "This code includes necessary headers for OpenCV and Paddle API libraries, defines the Permute class which runs a permutation operation on input images and outputs data in float format.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/preprocess_op.cpp\":0-35",
            "content": "// Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#include \"opencv2/core.hpp\"\n#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include \"paddle_api.h\"\n#include \"paddle_inference_api.h\"\n#include <chrono>\n#include <iomanip>\n#include <iostream>\n#include <ostream>\n#include <vector>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <include/preprocess_op.h>\nnamespace PaddleVideo\n{\n    void Permute::Run(const cv::Mat *im, float *data)"
        },
        {
            "comment": "This code block is for preprocessing images before inference. It extracts each channel from the image and performs normalization on them separately, then scales the values and merges them back into a single image. The normalization is done by subtracting the mean and dividing by the scale factor for each channel. If scaling is required, it also converts the image data type to float. Afterwards, it resizes the image if necessary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/preprocess_op.cpp\":36-65",
            "content": "    {\n        int rh = im->rows;\n        int rw = im->cols;\n        int rc = im->channels();\n        for (int i = 0; i < rc; ++i)\n        {\n            // Extract the i-th channel of im and write it into the array with (data + i * rh * rw) as the starting address\n            cv::extractChannel(*im, cv::Mat(rh, rw, CV_32FC1, data + i * rh * rw), rc - 1 - i);\n        }\n    }\n    void Normalize::Run(cv::Mat *im, const std::vector<float> &mean,\n                        const std::vector<float> &scale, const bool is_scale)\n    {\n        double e = 1.0;\n        if (is_scale)\n        {\n            e /= 255.0;\n        }\n        (*im).convertTo(*im, CV_32FC3, e);\n        std::vector<cv::Mat> bgr_channels(3);\n        cv::split(*im, bgr_channels);\n        for (auto i = 0; i < bgr_channels.size(); i++)\n        {\n            bgr_channels[i].convertTo(bgr_channels[i], CV_32FC1, 1.0 / scale[i], (0.0 - mean[i]) / scale[i]);\n        }\n        cv::merge(bgr_channels, *im);\n    }\n    void Scale::Run(const cv::Mat &img, cv::Mat &resize_img, bool use_tensorrt, const int &short_size)"
        },
        {
            "comment": "This function performs image resizing and cropping operations based on the input image size and target crop size. If the image size is larger than or equal to the target crop size, it resizes the image to fit within the specified bounds and crops the center of the resized image with dimensions equal to the target crop size. If the image size is smaller than the target crop size, it prints an error message stating that the image width and height should be larger than the crop size.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/preprocess_op.cpp\":66-103",
            "content": "    {\n        int h = img.rows;\n        int w = img.cols;\n        if ((w <= h && w == short_size) || (h <= w && h == short_size))\n        {\n            img.copyTo(resize_img);\n        }\n        else\n        {\n            int oh, ow;\n            if (w < h)\n            {\n                ow = short_size;\n                oh = h * ow / w;\n            }\n            else\n            {\n                oh = short_size;\n                ow = w * oh / h;\n            }\n            cv::resize(img, resize_img, cv::Size(ow, oh), 0.0f, 0.0f, cv::INTER_LINEAR);\n        }\n    }\n    void CenterCrop::Run(const cv::Mat &img, cv::Mat &crop_img, bool use_tensorrt, const int &target_size)\n    {\n        int h = img.rows;\n        int w = img.cols;\n        int crop_h = target_size;\n        int crop_w = target_size;\n        if (w < crop_w || h < crop_h)\n        {\n            printf(\"[Error] image width (%d) and height (%d) should be larger than crop size (%d)\",\n                   w, h, target_size);\n        }\n        else\n        {\n            int x1 = (w - crop_w) / 2;"
        },
        {
            "comment": "This code applies a ten-crop technique to input image by extracting 5 pairs of horizontally and vertically cropped images from the original one. These cropped images are stored in a vector for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/preprocess_op.cpp\":104-131",
            "content": "            int y1 = (h - crop_h) / 2;\n            crop_img = img(cv::Rect(x1, y1, crop_w, crop_h));\n        }\n    }\n    void TenCrop::Run(const cv::Mat &img, std::vector<cv::Mat> &crop_imgs, const int &begin_index, bool use_tensorrt, const int &target_size)\n    {\n        int h = img.rows;\n        int w = img.cols;\n        int crop_h = target_size;\n        int crop_w = target_size;\n        int w_step = (w - crop_w) / 4;\n        int h_step = (h - crop_h) / 4;\n        pair<int, int>offsets[5] =\n        {\n            {0,          0},\n            {4 * w_step, 0},\n            {0,          4 * h_step},\n            {4 * w_step, 4 * h_step},\n            {2 * w_step, 2 * h_step}\n        };\n        for (int i = 0; i < 5; ++i)\n        {\n            const int &j = i * 2;\n            const int &x1 = offsets[i].first;\n            const int &y1 = offsets[i].second;\n            crop_imgs[begin_index + j] = img(cv::Rect(x1, y1, crop_w, crop_h)); // cropped\n            cv::flip(img(cv::Rect(x1, y1, crop_w, crop_h)), crop_imgs[begin_index + j + 1], 0); // cropped"
        },
        {
            "comment": "This code is a part of the PaddleVideo library. It appears to be inside a class called PaddleVideo, and it seems that this code block is responsible for implementing some sort of pre-processing operation or function. This operation might involve processing video frames before they are sent through an AI model for inference. The code also includes namespaces, which are used to organize the code into logical groups or modules.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/preprocess_op.cpp\":132-134",
            "content": "        }\n    }\n} // namespace PaddleVideo"
        }
    ]
}