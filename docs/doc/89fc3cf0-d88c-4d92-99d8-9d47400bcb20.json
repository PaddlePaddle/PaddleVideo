{
    "summary": "This function calculates precision and recall metrics from scores, labels, and ground truth instances, raising ValueError for incorrect inputs. It computes average precision using valid precision and recall arrays and calculates CorLoc performance metrics for object detection with given ground truth and detected images per class.",
    "details": [
        {
            "comment": "This code defines a function to compute precision and recall metrics based on input scores, labels, and the number of ground truth instances. It also raises a ValueError if the input is in the incorrect format.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ava_evaluation/metrics.py\":0-29",
            "content": "# copyright (c) 2021 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Functions for computing metrics like precision, recall, CorLoc and etc.\"\"\"\nimport numpy as np\ndef compute_precision_recall(scores, labels, num_gt):\n    \"\"\"Compute precision and recall.\n    Args:\n        scores: A float numpy array representing detection score\n        labels: A boolean numpy array representing true/false positive labels\n        num_gt: Number of ground truth instances\n    Raises:\n        ValueError: if the input is not of the correct format"
        },
        {
            "comment": "This code checks if input 'labels' and 'scores' are valid arrays. It verifies that 'labels' is a one-dimensional boolean numpy array, 'scores' is a one-dimensional numpy array, the number of true positives is less than num_gt (number of ground truth labels), and the lengths of 'scores' and 'labels' are equal. If any conditions are not met, it raises a ValueError with an appropriate error message. If all checks pass and there are no ground truth labels, the function returns None for both precision and recall.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ava_evaluation/metrics.py\":31-57",
            "content": "    Returns:\n        precision: Fraction of positive instances over detected ones. This\n            value is None if no ground truth labels are present.\n        recall: Fraction of detected positive instance over all positive\n            instances. This value is None if no ground truth labels are\n            present.\n    \"\"\"\n    if (not isinstance(labels, np.ndarray) or labels.dtype != np.bool\n            or len(labels.shape) != 1):\n        raise ValueError('labels must be single dimension bool numpy array')\n    if not isinstance(scores, np.ndarray) or len(scores.shape) != 1:\n        raise ValueError('scores must be single dimension numpy array')\n    if num_gt < np.sum(labels):\n        raise ValueError(\n            'Number of true positives must be smaller than num_gt.')\n    if len(scores) != len(labels):\n        raise ValueError('scores and labels must be of the same size.')\n    if num_gt == 0:\n        return None, None\n    sorted_indices = np.argsort(scores)\n    sorted_indices = sorted_indices[::-1]\n    labels = labels.astype(int)"
        },
        {
            "comment": "Computes precision and recall from sorted labels, returns both values.\nDefines a function to compute average precision using precision and recall arrays.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ava_evaluation/metrics.py\":58-87",
            "content": "    true_positive_labels = labels[sorted_indices]\n    false_positive_labels = 1 - true_positive_labels\n    cum_true_positives = np.cumsum(true_positive_labels)\n    cum_false_positives = np.cumsum(false_positive_labels)\n    precision = cum_true_positives.astype(float) / (\n        cum_true_positives + cum_false_positives)\n    recall = cum_true_positives.astype(float) / num_gt\n    return precision, recall\ndef compute_average_precision(precision, recall):\n    \"\"\"Compute Average Precision according to the definition in VOCdevkit.\n    Precision is modified to ensure that it does not decrease as recall\n    decrease.\n    Args:\n        precision: A float [N, 1] numpy array of precisions\n        recall: A float [N, 1] numpy array of recalls\n    Raises:\n        ValueError: if the input is not of the correct format\n    Returns:\n        average_precison: The area under the precision recall curve. NaN if\n            precision and recall are None.\n    \"\"\"\n    if precision is None:\n        if recall is not None:\n            raise ValueError('If precision is None, recall must also be None')"
        },
        {
            "comment": "This function checks the data types and ranges of precision and recall arrays, ensuring they are numpy float arrays within the range [0,1] and have the same size. If all conditions pass, it then concatenates recall and precision arrays with 0 and 1 at the end respectively before preprocessing precision to be a non-decreasing array.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ava_evaluation/metrics.py\":88-110",
            "content": "        return np.NAN\n    if not isinstance(precision, np.ndarray) or not isinstance(\n            recall, np.ndarray):\n        raise ValueError('precision and recall must be numpy array')\n    if precision.dtype != np.float or recall.dtype != np.float:\n        raise ValueError('input must be float numpy array.')\n    if len(precision) != len(recall):\n        raise ValueError('precision and recall must be of the same size.')\n    if not precision.size:\n        return 0.0\n    if np.amin(precision) < 0 or np.amax(precision) > 1:\n        raise ValueError('Precision must be in the range of [0, 1].')\n    if np.amin(recall) < 0 or np.amax(recall) > 1:\n        raise ValueError('recall must be in the range of [0, 1].')\n    if not all(recall[i] <= recall[i + 1] for i in range(len(recall) - 1)):\n        raise ValueError('recall must be a non-decreasing array')\n    recall = np.concatenate([[0], recall, [1]])\n    precision = np.concatenate([[0], precision, [0]])\n    # Preprocess precision to be a non-decreasing array\n    for i in range(len(precision) - 2, -1, -1):"
        },
        {
            "comment": "This code computes the average precision and CorLoc, which is a metric used to evaluate object detection performance. It takes in arrays of ground truth images per class and correctly detected images per class. The average precision function calculates the average precision by comparing recall values, while the compute_cor_loc function calculates the CorLoc score for each class based on these inputs. If there are no ground truth images for a class, it returns NaN.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ava_evaluation/metrics.py\":111-136",
            "content": "        precision[i] = np.maximum(precision[i], precision[i + 1])\n    indices = np.where(recall[1:] != recall[:-1])[0] + 1\n    average_precision = np.sum(\n        (recall[indices] - recall[indices - 1]) * precision[indices])\n    return average_precision\ndef compute_cor_loc(num_gt_imgs_per_class,\n                    num_images_correctly_detected_per_class):\n    \"\"\"Compute CorLoc according to the definition in the following paper.\n    https://www.robots.ox.ac.uk/~vgg/rg/papers/deselaers-eccv10.pdf\n    Returns nans if there are no ground truth images for a class.\n    Args:\n        num_gt_imgs_per_class: 1D array, representing number of images\n            containing at least one object instance of a particular class\n        num_images_correctly_detected_per_class: 1D array, representing number\n            of images that are correctly detected at least one object instance\n            of a particular class\n    Returns:\n        corloc_per_class: A float numpy array represents the corloc score of\n            each class"
        },
        {
            "comment": "Divides the number of images correctly detected by the number of ground truth images per class, ignoring division by zero for classes with no examples.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ava_evaluation/metrics.py\":137-142",
            "content": "    \"\"\"\n    # Divide by zero expected for classes with no gt examples.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        return np.where(\n            num_gt_imgs_per_class == 0, np.nan,\n            num_images_correctly_detected_per_class / num_gt_imgs_per_class)"
        }
    ]
}