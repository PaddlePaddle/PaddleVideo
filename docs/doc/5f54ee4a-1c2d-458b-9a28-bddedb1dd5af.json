{
    "summary": "This code defines a `TSN_ResNet` class for creating Temporal Segment Network ResNet models in PaddlePaddle, using bottleneck_block function and performs adaptive average pooling, reshaping, and activation functions.",
    "details": [
        {
            "comment": "This code defines a class `TSN_ResNet` for creating a Temporal Segment Network ResNet model. It has parameters such as layers, segment number, training flag and extractor flag. The class contains a method `conv_bn_layer()` to create a convolution-batch normalization layer.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn_res_model.py\":0-33",
            "content": "#  Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n#Licensed under the Apache License, Version 2.0 (the \"License\");\n#you may not use this file except in compliance with the License.\n#You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n#Unless required by applicable law or agreed to in writing, software\n#distributed under the License is distributed on an \"AS IS\" BASIS,\n#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#See the License for the specific language governing permissions and\n#limitations under the License.\nimport os\nimport time\nimport sys\nimport paddle\nimport paddle.static as static\nimport math\nclass TSN_ResNet():\n    def __init__(self,\n                 layers=50,\n                 seg_num=7,\n                 is_training=True,\n                 is_extractor=False):\n        self.layers = layers\n        self.seg_num = seg_num\n        self.is_training = is_training\n        self.is_extractor = is_extractor\n    def conv_bn_layer(self,"
        },
        {
            "comment": "This function defines a convolutional layer and returns it after passing through a batch normalization layer. It takes input, number of filters, filter size, stride, groups (number of groups in the layers), activation function if any, and name as arguments. If the name is \"conv1\", the bn_name would be \"bn_conv1\" else, it would be \"bn0\", followed by the original name. The batch normalization layer takes input, activation function if any, whether it's in test mode or not, scale and offset attribute names for parameters, and names for moving mean and variance.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn_res_model.py\":34-62",
            "content": "                      input,\n                      num_filters,\n                      filter_size,\n                      stride=1,\n                      groups=1,\n                      act=None,\n                      name=None):\n        conv = paddle.static.nn.conv2d(\n            input=input,\n            num_filters=num_filters,\n            filter_size=filter_size,\n            stride=stride,\n            padding=(filter_size - 1) // 2,\n            groups=groups,\n            param_attr=paddle.ParamAttr(name=name + \"_weights\"),\n            bias_attr=False)\n        if name == \"conv1\":\n            bn_name = \"bn_\" + name\n        else:\n            bn_name = \"bn\" + name[3:]\n        return paddle.static.nn.batch_norm(\n            input=conv,\n            act=act,\n            is_test=(not self.is_training),\n            param_attr=paddle.ParamAttr(name=bn_name + \"_scale\"),\n            bias_attr=paddle.ParamAttr(bn_name + '_offset'),\n            moving_mean_name=bn_name + \"_mean\",\n            moving_variance_name=bn_name + '_variance')"
        },
        {
            "comment": "This code defines two functions: 'shortcut' and 'bottleneck_block'. The shortcut function determines if input dimensions match the desired output, and returns either a convolution-batch normalization layer or the input itself. The bottleneck_block function applies two consecutive 1x1 and 3x3 convolutions with batch normalization and ReLU activations in between.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn_res_model.py\":64-85",
            "content": "    def shortcut(self, input, ch_out, stride, name):\n        ch_in = input.shape[1]\n        if ch_in != ch_out or stride != 1:\n            return self.conv_bn_layer(input, ch_out, 1, stride, name=name)\n        else:\n            return input\n    def bottleneck_block(self, input, num_filters, stride, name):\n        conv0 = self.conv_bn_layer(input=input,\n                                   num_filters=num_filters,\n                                   filter_size=1,\n                                   act='relu',\n                                   name=name + \"_branch2a\")\n        conv1 = self.conv_bn_layer(input=conv0,\n                                   num_filters=num_filters,\n                                   filter_size=3,\n                                   stride=stride,\n                                   act='relu',\n                                   name=name + \"_branch2b\")\n        conv2 = self.conv_bn_layer(input=conv1,\n                                   num_filters=num_filters * 4,\n                                   filter_size=1,"
        },
        {
            "comment": "The code defines a function `net` that takes an input, performs operations based on the specified number of layers (50, 101 or 152), and reshapes the input. It then applies different configurations of convolutional and batch normalization layers to the input for each specified layer. The final output is the sum of two previous calculations (conv and short).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn_res_model.py\":86-117",
            "content": "                                   act=None,\n                                   name=name + \"_branch2c\")\n        short = self.shortcut(input,\n                              num_filters * 4,\n                              stride,\n                              name=name + \"_branch1\")\n        return paddle.add(x=short, y=conv2)\n    def net(self, input, class_dim=101):\n        layers = self.layers\n        seg_num = self.seg_num\n        supported_layers = [50, 101, 152]\n        assert layers in supported_layers, \\\n            \"supported layers are {} but input layer is {}\".format(supported_layers, layers)\n        # reshape input\n        channels = input.shape[2]\n        short_size = input.shape[3]\n        input = paddle.reshape(\n            x=input, shape=[-1, channels, short_size, short_size])\n        if layers == 50:\n            depth = [3, 4, 6, 3]\n        elif layers == 101:\n            depth = [3, 4, 23, 3]\n        elif layers == 152:\n            depth = [3, 8, 36, 3]\n        num_filters = [64, 128, 256, 512]\n        conv = self.conv_bn_layer(input=input,"
        },
        {
            "comment": "This code defines a ResNet model with multiple convolutional layers and pooling operations. It uses the PaddlePaddle library and includes a bottleneck_block function for the residual blocks. The number of filters, filter size, and stride are defined based on the layer and depth.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn_res_model.py\":118-141",
            "content": "                                  num_filters=64,\n                                  filter_size=7,\n                                  stride=2,\n                                  act='relu',\n                                  name='conv1')\n        conv = paddle.nn.functional.max_pool2d(x=conv,\n                                   kernel_size=3,\n                                   stride=2,\n                                   padding=1)\n        for block in range(len(depth)):\n            for i in range(depth[block]):\n                if layers in [101, 152] and block == 2:\n                    if i == 0:\n                        conv_name = \"res\" + str(block + 2) + \"a\"\n                    else:\n                        conv_name = \"res\" + str(block + 2) + \"b\" + str(i)\n                else:\n                    conv_name = \"res\" + str(block + 2) + chr(97 + i)\n                conv = self.bottleneck_block(\n                    input=conv,\n                    num_filters=num_filters[block],\n                    stride=2 if i == 0 and block != 0 else 1,"
        },
        {
            "comment": "This code performs adaptive average pooling, reshapes the feature map, and if not an extractor, calculates the mean along axis 1. Then, it applies a softmax activation function and returns the output.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn_res_model.py\":142-160",
            "content": "                    name=conv_name)\n        pool = paddle.nn.functional.adaptive_avg_pool2d(x=conv, output_size=1)\n        feature = paddle.reshape(x=pool,\n                                       shape=[-1, seg_num, pool.shape[1]])\n        if self.is_extractor:\n            out = feature\n        else:\n            out = paddle.mean(x=feature, axis=1)\n            stdv = 1.0 / math.sqrt(pool.shape[1] * 1.0)\n            out = static.nn.fc(\n                x=out,\n                size=class_dim,\n                activation='softmax',\n                weight_attr=paddle.ParamAttr(\n                    initializer=paddle.nn.initializer.Uniform(low=-stdv, high=stdv)))\n        return out"
        }
    ]
}