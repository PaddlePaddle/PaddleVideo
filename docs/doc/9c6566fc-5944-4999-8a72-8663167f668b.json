{
    "summary": "TransNetV2 Partitioner in PaddleVideo framework defines a model partitioner, includes forwarding methods for image processing and computing loss metrics. It has three methods: \"loss_metrics\", \"test_step\", and \"infer_step\" for training, testing, and inference phases respectively.",
    "details": [
        {
            "comment": "TransNetV2 Partitioner class for PaddleVideo framework, with forward_net and train_step methods for image processing and model training.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/partitioners/transnetv2_partitioner.py\":0-31",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nfrom ...registry import PARTITIONERS\nfrom .base import BasePartitioner\nimport paddle\n@PARTITIONERS.register()\nclass TransNetV2Partitioner(BasePartitioner):\n    \"\"\"TransNetV2 Partitioner framework\n    \"\"\"\n    def forward_net(self, imgs):\n        one_hot_pred = self.backbone(imgs)\n        return one_hot_pred\n    def train_step(self, data_batch):\n        \"\"\"Define how the model is going to train, from input to output.\n        \"\"\"\n        frame_sequence = data_batch[0]\n        one_hot_gt, many_hot_gt = data_batch[1:]\n        one_hot_pred = self.forward_net(frame_sequence)"
        },
        {
            "comment": "Code defines a model partitioner for TransNetV2. It returns loss metrics from the validation step by forwarding frame sequences through the model, extracting one-hot and many-hot predictions and ground truths, and applying losses based on provided dictionaries.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/partitioners/transnetv2_partitioner.py\":32-53",
            "content": "        dict_ = {}\n        if isinstance(one_hot_pred, tuple):\n            one_hot_pred, dict_ = one_hot_pred\n        many_hot_pred = dict_.get(\"many_hot\", None)\n        comb_reg_loss = dict_.get(\"comb_reg_loss\", None)\n        loss_metrics = self.head.loss(one_hot_pred, one_hot_gt,\n                                    many_hot_pred, many_hot_gt,\n                                    reg_losses={\"comb_reg\": comb_reg_loss})\n        return loss_metrics\n    def val_step(self, data_batch):\n        frame_sequence = data_batch[0]\n        one_hot_gt, many_hot_gt = data_batch[1:]\n        one_hot_pred = self.forward_net(frame_sequence)\n        dict_ = {}\n        if isinstance(one_hot_pred, tuple):\n            one_hot_pred, dict_ = one_hot_pred\n        many_hot_pred = dict_.get(\"many_hot\", None)\n        comb_reg_loss = dict_.get(\"comb_reg_loss\", None)\n        loss_metrics = self.head.loss(one_hot_pred, one_hot_gt,\n                                      many_hot_pred, many_hot_gt,\n                                      reg_losses={\"comb_reg\": comb_reg_loss})"
        },
        {
            "comment": "The code defines three methods: \"loss_metrics\" returns loss and metrics for training, \"test_step\" performs testing by forwarding frames through the net without calculating loss, and \"infer_step\" also performs testing with forwarding frames but without specifying if it's for a test or inference phase.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/partitioners/transnetv2_partitioner.py\":54-67",
            "content": "        return loss_metrics\n    def test_step(self, data_batch):\n        \"\"\"Define how the model is going to test, from input to output.\"\"\"\n        # NOTE: (shipping) when testing, the net won't call head.loss, we deal with the test processing in /paddlevideo/metrics\n        frame_sequence = data_batch[0]\n        one_hot_pred = self.forward_net(frame_sequence)\n        return one_hot_pred\n    def infer_step(self, data_batch):\n        \"\"\"Define how the model is going to test, from input to output.\"\"\"\n        frame_sequence = data_batch[0]\n        one_hot_pred = self.forward_net(frame_sequence)\n        return one_hot_pred"
        }
    ]
}