{
    "summary": "The code introduces a Non-Maximum Suppression function for bounding boxes and defines the AVARoIHead class, an object detection layer performing ROI alignment with bbox loss calculation, image assignment & sampling, and result returning. The simple_test function tests detection without augmentation.",
    "details": [
        {
            "comment": "This code defines the function bbox2result, which takes in bounding box coordinates (bboxes), labels, number of classes (num_classes), image shape (img_shape) and a threshold value (thr). The function returns a list of numpy arrays representing the detection results. If there are no detections (i.e., bboxes is empty), it returns an empty list of zeros for each class.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/roi_head.py\":0-28",
            "content": "# copyright (c) 2021 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport numpy as np\nimport paddle\nimport paddle.nn as nn\nfrom .. import builder\nfrom ..registry import HEADS\ndef bbox2result(bboxes, labels, num_classes, img_shape, thr=0.01):\n    \"\"\"Convert detection results to a list of numpy arrays.  \"\"\"\n    if len(bboxes) == 0:\n        return list(np.zeros((num_classes - 1, 0, 5), dtype=np.float32))\n    else:\n        bboxes = bboxes[0]\n        labels = labels\n        img_shape_np = img_shape"
        },
        {
            "comment": "This code performs Non-Maximum Suppression (NMS) on bounding boxes and scores to filter out overlapping regions. It iterates through each class, selects bounding boxes and their corresponding scores that are above a certain threshold for each class, and appends them to the result list.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/roi_head.py\":29-58",
            "content": "        img_h, img_w = img_shape_np[0][0], img_shape_np[0][1]\n        img_w = paddle.cast(img_w, dtype='int32')\n        img_h = paddle.cast(img_h, dtype='int32')\n        bboxes[:, 0::2] /= img_w\n        bboxes[:, 1::2] /= img_h\n        # We only handle multilabel now\n        assert labels.shape[-1] > 1\n        scores = labels  # rename\n        thr = (thr, ) * num_classes if isinstance(thr, float) else thr\n        assert scores.shape[1] == num_classes\n        assert len(thr) == num_classes\n        result = []\n        for i in range(num_classes - 1):\n            #step1. \u5bf9\u8be5\u7c7b, \u6bcf\u4e2abbox\u7684\u5f97\u5206\u662f\u5426\u5927\u4e8e\u9608\u503c\n            where = scores[:, i + 1] > thr[i + 1]\n            where = paddle.nonzero(where)  # index\n            bboxes_select = paddle.index_select(x=bboxes, index=where)\n            bboxes_select = bboxes_select[:, :4]\n            scores_select = paddle.index_select(x=scores, index=where)\n            scores_select = scores_select[:, i + 1:i + 2]\n            result.append(\n                #\u5bf9\u4e8estep1\u4e2d\u5f97\u5206\u5927\u4e8e\u9608\u503c\u7684bbox(\u53ef\u80fd\u4e3a\u7a7a), \u5c06bbox\u53ca\u5728\u8be5\u7c7b\u7684score\u653e\u5165result\u5217\u8868."
        },
        {
            "comment": "The code defines a class named AVARoIHead, which is a PaddlePaddle layer for object detection. It initializes the assigner and sampler, and optionally initializes the bbox_head (bounding box regression head). The method init_assigner_sampler initializes the bbox_assigner and bbox_sampler from the passed arguments. The method init_bbox_head initializes the bounding box regression head if the bbox_head is provided. This class registers with HEADS, which may be a registry or a list of defined classes.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/roi_head.py\":59-92",
            "content": "                paddle.concat((bboxes_select, scores_select), axis=1).numpy())\n        return result\n@HEADS.register()\nclass AVARoIHead(nn.Layer):\n    def __init__(self,\n                 assigner,\n                 sampler,\n                 pos_weight=1.0,\n                 action_thr=0.0,\n                 bbox_roi_extractor=None,\n                 bbox_head=None,\n                 train_cfg=None,\n                 test_cfg=None):\n        super().__init__()\n        self.assigner = assigner\n        self.sampler = sampler\n        self.pos_weight = pos_weight\n        self.action_thr = action_thr\n        self.init_assigner_sampler()\n        if bbox_head is not None:\n            self.init_bbox_head(bbox_roi_extractor, bbox_head)\n    def init_assigner_sampler(self):\n        \"\"\"Initialize assigner and sampler.\"\"\"\n        self.bbox_assigner = None\n        self.bbox_sampler = None\n        self.bbox_assigner = builder.build_assigner(self.assigner)\n        self.bbox_sampler = builder.build_sampler(self.sampler, context=self)\n    def init_bbox_head(self, bbox_roi_extractor, bbox_head):"
        },
        {
            "comment": "This code initializes the bbox_head and defines the _bbox_forward function for feature extraction and prediction, as well as the _bbox_forward_train function for training purposes. It also handles situations where ROI's width or height equals 0 by correcting the roi_align operation.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/roi_head.py\":93-113",
            "content": "        \"\"\"Initialize ``bbox_head``\"\"\"\n        self.bbox_roi_extractor = builder.build_roi_extractor(\n            bbox_roi_extractor)\n        self.bbox_head = builder.build_head(bbox_head)\n    def _bbox_forward(self, x, rois, rois_num):\n        bbox_feat = self.bbox_roi_extractor(x, rois, rois_num)\n        cls_score, bbox_pred = self.bbox_head(\n            bbox_feat, rois, rois_num\n        )  #deal with: when roi's width or height = 0 , roi_align is wrong\n        bbox_results = dict(cls_score=cls_score,\n                            bbox_pred=bbox_pred,\n                            bbox_feats=bbox_feat)\n        return bbox_results\n    def _bbox_forward_train(self, x, sampling_results, gt_bboxes, gt_labels):\n        \"\"\"Run forward function and calculate loss for box head in training.\"\"\"\n        rois = [res.bboxes for res in sampling_results]\n        rois_num = [res.bboxes.shape[0] for res in sampling_results]\n        bbox_results = self._bbox_forward(x, rois, rois_num)\n        bbox_targets = self.bbox_head.get_targets(sampling_results, gt_bboxes,"
        },
        {
            "comment": "The code defines a ROI head that calculates the bbox loss and performs assignment and sampling for each image in a batch. It takes input images, proposal list, ground truth bounding boxes, and labels as parameters and returns results containing loss_bbox.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/roi_head.py\":114-133",
            "content": "                                                  gt_labels, self.pos_weight)\n        loss_bbox = self.bbox_head.loss(bbox_results['cls_score'], bbox_targets)\n        bbox_results.update(loss_bbox=loss_bbox)\n        return bbox_results\n    def train_step(self, x, img_metas, proposal_list, gt_bboxes, gt_labels):\n        #1. assign gts and sample proposals\n        num_imgs = len(img_metas[0])\n        sampling_results = []\n        for i in range(num_imgs):\n            assign_result = self.bbox_assigner.assign(proposal_list[i],\n                                                      gt_bboxes[i],\n                                                      gt_labels[i])\n            sampling_result = self.bbox_sampler.sample(assign_result,\n                                                       proposal_list[i],\n                                                       gt_bboxes[i],\n                                                       gt_labels[i])\n            sampling_results.append(sampling_result)\n        #2. forward and loss"
        },
        {
            "comment": "The code contains two main functions, \"simple_test\" and \"_bbox_forward_train\". The former is for testing the model in simple test mode by taking input x, proposal list, img_shape, and rescale flag. It calculates det_bboxes and det_labels using the function \"simple_test_bboxes\". Then it uses bbox2result to convert det_bboxes and det_labels into bbox_results. The latter function takes input x, sampling results, gt_bboxes, and gt_labels to calculate bbox results and losses. It updates the losses dictionary with \"loss_bbox\" and returns the losses.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/roi_head.py\":134-157",
            "content": "        bbox_results = self._bbox_forward_train(x, sampling_results, gt_bboxes,\n                                                gt_labels)\n        losses = dict()\n        losses.update(bbox_results['loss_bbox'])\n        return losses\n    def simple_test(self, x, proposal_list, img_shape, rescale=False):\n        x_shape = x[0].shape\n        #assert x_shape[0] == 1, 'only accept 1 sample at test mode'\n        det_bboxes, det_labels = self.simple_test_bboxes(x,\n                                                         img_shape,\n                                                         proposal_list,\n                                                         self.action_thr,\n                                                         rescale=rescale)\n        bbox_results = bbox2result(det_bboxes, det_labels,\n                                   self.bbox_head.num_classes, img_shape,\n                                   self.action_thr)\n        return [bbox_results]\n    def simple_test_bboxes(self,\n                           x,"
        },
        {
            "comment": "This function tests only detection bboxes without augmentation. It takes input x, proposals, action_thr, and rescale as parameters. It creates rois and rois_num from the proposals. It then calls _bbox_forward to get cls_score. It sets crop_quadruple and flip to False. Finally, it calls bbox_head's get_det_bboxes to return det_bboxes and det_labels.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/roi_head.py\":158-176",
            "content": "                           img_shape,\n                           proposals,\n                           action_thr,\n                           rescale=False):\n        \"\"\"Test only det bboxes without augmentation.\"\"\"\n        rois = [proposals]\n        rois_num = [rois[0].shape[0]]\n        bbox_results = self._bbox_forward(x, rois, rois_num)\n        cls_score = bbox_results['cls_score']\n        crop_quadruple = np.array([0, 0, 1, 1])\n        flip = False\n        det_bboxes, det_labels = self.bbox_head.get_det_bboxes(\n            rois,\n            cls_score,\n            img_shape,\n            flip=flip,\n            crop_quadruple=crop_quadruple)\n        return det_bboxes, det_labels"
        }
    ]
}