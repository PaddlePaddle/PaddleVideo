{
    "summary": "The code introduces a \"KineticsReader\" class to efficiently read Kinetics dataset in mp4 and pkl formats, applying data augmentation for image/video classification tasks. It generates images for multi-threaded processing, and selects frames based on parameters for training or testing mode.",
    "details": [
        {
            "comment": "This code is from the PaddleVideo library's VideoTag application, specifically the kinetics_reader.py file. It imports necessary modules, defines a VideoRecord class to describe frames information of videos, and includes license and version details. The code seems to be part of a video processing framework for machine learning tasks, potentially in image or video classification.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":0-40",
            "content": "#  Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n#Licensed under the Apache License, Version 2.0 (the \"License\");\n#you may not use this file except in compliance with the License.\n#You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n#Unless required by applicable law or agreed to in writing, software\n#distributed under the License is distributed on an \"AS IS\" BASIS,\n#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#See the License for the specific language governing permissions and\n#limitations under the License.\nimport os\nimport sys\nimport cv2\nimport math\nimport random\nimport functools\ntry:\n    import cPickle as pickle\n    from cStringIO import StringIO\nexcept ImportError:\n    import pickle\n    from io import BytesIO\nimport numpy as np\nimport paddle\nfrom PIL import Image, ImageEnhance\nimport logging\nfrom .reader_utils import DataReader\nlogger = logging.getLogger(__name__)\npython_ver = sys.version_info\nclass VideoRecord(object):\n    '''\n    define a class method which used to describe the frames information of videos"
        },
        {
            "comment": "This code defines a class \"KineticsReader\" for reading the Kinetics dataset in two formats: mp4 and pkl. It initializes with a row of data containing the frames' path, number of frames, and label. The class has properties for accessing these data elements. The code also specifies dataset configuration options.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":41-78",
            "content": "    1. self._data[0] is the frames' path\n    2. self._data[1] is the number of frames\n    3. self._data[2] is the label of frames\n    '''\n    def __init__(self, row):\n        self._data = row\n    @property\n    def path(self):\n        return self._data[0]\n    @property\n    def num_frames(self):\n        return int(self._data[1])\n    @property\n    def label(self):\n        return int(self._data[2])\nclass KineticsReader(DataReader):\n    \"\"\"\n    Data reader for kinetics dataset of two format mp4 and pkl.\n    1. mp4, the original format of kinetics400\n    2. pkl, the mp4 was decoded previously and stored as pkl\n    In both case, load the data, and then get the frame data in the form of numpy and label as an integer.\n     dataset cfg: format\n                  num_classes\n                  seg_num\n                  short_size\n                  target_size\n                  num_reader_threads\n                  buf_size\n                  image_mean\n                  image_std\n                  batch_size\n                  list\n    \"\"\""
        },
        {
            "comment": "This code initializes an object of the KineticsReader class, which takes in parameters like name, mode, and configuration (cfg). It retrieves various attributes from the configuration, such as number of classes, segmentation information, image sizes, reader threads, buffer size, and random seed. It also sets the mean and standard deviation values for image normalization.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":79-97",
            "content": "    def __init__(self, name, mode, cfg):\n        super(KineticsReader, self).__init__(name, mode, cfg)\n        self.format = cfg.MODEL.format\n        self.num_classes = self.get_config_from_sec('model', 'num_classes')\n        self.seg_num = self.get_config_from_sec('model', 'seg_num')\n        self.seglen = self.get_config_from_sec('model', 'seglen')\n        self.seg_num = self.get_config_from_sec(mode, 'seg_num', self.seg_num)\n        self.short_size = self.get_config_from_sec(mode, 'short_size')\n        self.target_size = self.get_config_from_sec(mode, 'target_size')\n        self.num_reader_threads = self.get_config_from_sec(\n            mode, 'num_reader_threads')\n        self.buf_size = self.get_config_from_sec(mode, 'buf_size')\n        self.fix_random_seed = self.get_config_from_sec(mode, 'fix_random_seed')\n        self.img_mean = np.array(cfg.MODEL.image_mean).reshape(\n            [3, 1, 1]).astype(np.float32)\n        self.img_std = np.array(cfg.MODEL.image_std).reshape([3, 1, 1]).astype(\n            np.float32)"
        },
        {
            "comment": "This code sets the batch size and file list for a video reader. It also ensures random seeds are set, limits the number of reader threads to 1 if fixing random seed, asserts that the filelist exists, creates a video reader object using a provided creator function, and defines a batch_reader generator function to iterate over the reader's output.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":98-120",
            "content": "        # set batch size and file list\n        self.batch_size = cfg[mode.upper()]['batch_size']\n        self.filelist = cfg[mode.upper()]['filelist']\n        if self.fix_random_seed:\n            random.seed(0)\n            np.random.seed(0)\n            self.num_reader_threads = 1\n    def create_reader(self):\n        assert os.path.exists(self.filelist), \\\n                    '{} not exist, please check the data list'.format(self.filelist)\n        _reader = self._reader_creator(self.filelist, self.mode, seg_num=self.seg_num, seglen = self.seglen, \\\n                         short_size = self.short_size, target_size = self.target_size, \\\n                         img_mean = self.img_mean, img_std = self.img_std, \\\n                         shuffle = (self.mode == 'train'), \\\n                         num_threads = self.num_reader_threads, \\\n                         buf_size = self.buf_size, format = self.format)\n        def _batch_reader():\n            batch_out = []\n            for imgs, label in _reader():\n                if imgs is None:"
        },
        {
            "comment": "This code defines a function `_reader_creator` that takes in various parameters and returns another function `decode_mp4`. The returned function reads video frames from MP4 files, extracts labels if necessary, and yields batches of images and labels based on batch size and other specified parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":121-150",
            "content": "                    continue\n                batch_out.append((imgs, label))\n                if len(batch_out) == self.batch_size:\n                    yield batch_out\n                    batch_out = []\n        return _batch_reader\n    def _reader_creator(self,\n                        file_list,\n                        mode,\n                        seg_num,\n                        seglen,\n                        short_size,\n                        target_size,\n                        img_mean,\n                        img_std,\n                        shuffle=False,\n                        num_threads=1,\n                        buf_size=1024,\n                        format='frames'):\n        def decode_mp4(sample, mode, seg_num, seglen, short_size, target_size,\n                       img_mean, img_std):\n            sample = sample[0].split(' ')\n            mp4_path = sample[0]\n            if mode == \"infer\":\n                label = mp4_path.split('/')[-1]\n            else:\n                label = int(sample[1])\n            try:"
        },
        {
            "comment": "This code is defining two functions: `kinetics_reader` and `decode_frames`. The `kinetics_reader` function loads frames from a given MP4 file using `mp4_loader`, applies transformations if necessary, and returns the frames along with their corresponding labels. It also logs an error if the number of frames is less than 1. If an exception occurs during the process, it logs an error message as well. The `decode_frames` function loads frames from a specified directory (specified by the `recode` object) using the `frames_loader` function and returns the frames along with their labels. If the number of frames is less than 1, it logs an error; if an exception occurs, it also logs an error.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":151-175",
            "content": "                imgs = mp4_loader(mp4_path, seg_num, seglen, mode)\n                if len(imgs) < 1:\n                    logger.error('{} frame length {} less than 1.'.format(\n                        mp4_path, len(imgs)))\n                    return None, None\n            except:\n                logger.error('Error when loading {}'.format(mp4_path))\n                return None, None\n            return imgs_transform(imgs, mode, seg_num, seglen, \\\n                         short_size, target_size, img_mean, img_std, name = self.name), label\n        def decode_frames(sample, mode, seg_num, seglen, short_size,\n                          target_size, img_mean, img_std):\n            recode = VideoRecord(sample[0].split(' '))\n            frames_dir_path = recode.path\n            if mode == \"infer\":\n                label = frames_dir_path\n            else:\n                label = recode.label\n            try:\n                imgs = frames_loader(recode, seg_num, seglen, mode)\n                if len(imgs) < 1:\n                    logger.error('{} frame length {} less than 1.'.format("
        },
        {
            "comment": "The code snippet is responsible for loading video frames from a specified directory and handling any errors that may occur during the process. It takes the frames directory path, image format (frames or video), segment number, sequence length, short size, target size, image mean, image standard deviation, and name as input parameters. The code also defines a function reader() to read the file list and shuffle its lines if necessary. Based on the specified format (frames or video), it calls the appropriate decoding function (decode_frames or decode_video).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":176-203",
            "content": "                        frames_dir_path, len(imgs)))\n                    return None, None\n            except:\n                logger.error('Error when loading {}'.format(frames_dir_path))\n                return None, None\n            return imgs_transform(imgs,\n                                  mode,\n                                  seg_num,\n                                  seglen,\n                                  short_size,\n                                  target_size,\n                                  img_mean,\n                                  img_std,\n                                  name=self.name), label\n        def reader_():\n            with open(file_list) as flist:\n                lines = [line.strip() for line in flist]\n                if shuffle:\n                    random.shuffle(lines)\n                for line in lines:\n                    file_path = line.strip()\n                    yield [file_path]\n        if format == 'frames':\n            decode_func = decode_frames\n        elif format == 'video':"
        },
        {
            "comment": "This code selects a specific video format decoder function based on the input format. If the format is not recognized, it raises an error. It then applies transformations to the images using the selected function and returns them with additional functionality for efficient processing with multiple threads.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":204-232",
            "content": "            decode_func = decode_mp4\n        else:\n            raise (\"Not implemented format {}\".format(format))\n        mapper = functools.partial(decode_func,\n                                   mode=mode,\n                                   seg_num=seg_num,\n                                   seglen=seglen,\n                                   short_size=short_size,\n                                   target_size=target_size,\n                                   img_mean=img_mean,\n                                   img_std=img_std)\n        return paddle.reader.decorator.xmap_readers(mapper,\n                                     reader_,\n                                     num_threads,\n                                     buf_size,\n                                     order=True)\ndef imgs_transform(imgs,\n                   mode,\n                   seg_num,\n                   seglen,\n                   short_size,\n                   target_size,\n                   img_mean,\n                   img_std,\n                   name=''):"
        },
        {
            "comment": "This code reads images from a dataset and performs data augmentation by cropping, flipping, and normalization. It also checks if the image dimensions are larger than the target crop size before applying the crop operation. If in 'train' mode, it randomly crops the image. Otherwise, it centers the crop. The resulting images are then normalized by subtracting the mean pixel values and dividing by standard deviation for feature extraction.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":233-265",
            "content": "    imgs = group_scale(imgs, short_size)\n    np_imgs = np.array([np.array(img).astype('float32') for img in imgs])  #dhwc\n    if mode == 'train':\n        np_imgs = group_crop(np_imgs, target_size)\n        np_imgs = group_random_flip(np_imgs)\n    else:\n        np_imgs = group_crop(np_imgs, target_size, is_center=True)\n    np_imgs = np_imgs.transpose(0, 3, 1, 2) / 255  #dchw\n    np_imgs -= img_mean\n    np_imgs /= img_std\n    return np_imgs\ndef group_crop(np_imgs, target_size, is_center=True):\n    d, h, w, c = np_imgs.shape\n    th, tw = target_size, target_size\n    assert (w >= target_size) and (h >= target_size), \\\n          \"image width({}) and height({}) should be larger than crop size\".format(w, h, target_size)\n    if is_center:\n        h_off = int(round((h - th) / 2.))\n        w_off = int(round((w - tw) / 2.))\n    else:\n        w_off = random.randint(0, w - tw)\n        h_off = random.randint(0, h - th)\n    img_crop = np_imgs[:, h_off:h_off + target_size,\n                       w_off:w_off + target_size, :]\n    return img_crop"
        },
        {
            "comment": "The code defines three functions: \"group_random_flip\" flips the image horizontally with 50% probability, \"group_scale\" resizes images to a specified target size while maintaining aspect ratio, and \"mp4_loader\" loads frames from a video file for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":268-304",
            "content": "def group_random_flip(np_imgs):\n    prob = random.random()\n    if prob < 0.5:\n        ret = np_imgs[:, :, ::-1, :]\n        return ret\n    else:\n        return np_imgs\ndef group_scale(imgs, target_size):\n    resized_imgs = []\n    for i in range(len(imgs)):\n        img = imgs[i]\n        w, h = img.size\n        if (w <= h and w == target_size) or (h <= w and h == target_size):\n            resized_imgs.append(img)\n            continue\n        if w < h:\n            ow = target_size\n            oh = int(target_size * 4.0 / 3.0)\n            resized_imgs.append(img.resize((ow, oh), Image.BILINEAR))\n        else:\n            oh = target_size\n            ow = int(target_size * 4.0 / 3.0)\n            resized_imgs.append(img.resize((ow, oh), Image.BILINEAR))\n    return resized_imgs\ndef mp4_loader(filepath, nsample, seglen, mode):\n    cap = cv2.VideoCapture(filepath)\n    videolen = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\n    sampledFrames = []\n    for i in range(videolen):\n        ret, frame = cap.read()\n        # maybe first frame is empty"
        },
        {
            "comment": "This code reads video frames and selects a subset of them based on the provided parameters. It appends each frame in the specified sequence to sampledFrames, calculates average duration, then extracts the required number of frames with a given segment length from the list. The extracted frames are returned at the end.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":305-339",
            "content": "        if ret == False:\n            continue\n        img = frame[:, :, ::-1]\n        sampledFrames.append(img)\n    average_dur = int(len(sampledFrames) / nsample)\n    imgs = []\n    for i in range(nsample):\n        idx = 0\n        if mode == 'train':\n            if average_dur >= seglen:\n                idx = random.randint(0, average_dur - seglen)\n                idx += i * average_dur\n            elif average_dur >= 1:\n                idx += i * average_dur\n            else:\n                idx = i\n        else:\n            if average_dur >= seglen:\n                idx = (average_dur - 1) // 2\n                idx += i * average_dur\n            elif average_dur >= 1:\n                idx += i * average_dur\n            else:\n                idx = i\n        for jj in range(idx, idx + seglen):\n            imgbuf = sampledFrames[int(jj % len(sampledFrames))]\n            img = Image.fromarray(imgbuf, mode='RGB')\n            imgs.append(img)\n    return imgs\ndef frames_loader(recode, nsample, seglen, mode):\n    imgpath, num_frames = recode.path, recode.num_frames"
        },
        {
            "comment": "This code calculates the average duration of video frames and then generates a set of images by randomly selecting start points based on the mode (train or test) and segment length. It opens each image file in RGB format, converts it, and adds it to the list of images returned at the end.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/kinetics_reader.py\":340-366",
            "content": "    average_dur = int(num_frames / nsample)\n    imgs = []\n    for i in range(nsample):\n        idx = 0\n        if mode == 'train':\n            if average_dur >= seglen:\n                idx = random.randint(0, average_dur - seglen)\n                idx += i * average_dur\n            elif average_dur >= 1:\n                idx += i * average_dur\n            else:\n                idx = i\n        else:\n            if average_dur >= seglen:\n                idx = (average_dur - 1) // 2\n                idx += i * average_dur\n            elif average_dur >= 1:\n                idx += i * average_dur\n            else:\n                idx = i\n        for jj in range(idx, idx + seglen):\n            img = Image.open(\n                os.path.join(imgpath,\n                             'img_{:05d}.jpg'.format(jj + 1))).convert('RGB')\n            imgs.append(img)\n    return imgs"
        }
    ]
}