{
    "summary": "This code imports libraries, defines a merging function and uses Paddlevideo classes for evaluation. It calculates Hit@1, measures video-level precision, averages results to assess model performance. The function computes top-k triplet predictions, raises ValueError if k is not a positive integer, and initializes HitOneMetric class for evaluation metrics in Youtube8m's PaddleVideo module.",
    "details": [
        {
            "comment": "The code provides functions for evaluating models. It imports necessary libraries, defines a function to merge multiple lists into one, and includes classes for Average Precision Calculator and Mean Average Precision Calculator from the paddlevideo module.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":0-28",
            "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Provides functions to help with evaluating models.\"\"\"\nimport numpy as np\nimport paddle\nfrom paddlevideo.utils import get_logger\nfrom ..base import BaseMetric\nfrom ..registry import METRIC\nfrom . import average_precision_calculator as ap_calculator\nfrom . import mean_average_precision_calculator as map_calculator\nlogger = get_logger(\"paddlevideo\")\ndef flatten(l):\n    \"\"\" Merges a list of lists into a single list. \"\"\"\n    return [item for sublist in l for item in sublist]"
        },
        {
            "comment": "Calculates Hit@1, the fraction of samples with at least one ground truth label in top predictions.\nMeasures video-level annotation precision when retrieving the same number of entities as ground truth.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":31-59",
            "content": "def calculate_hit_at_one(predictions, actuals):\n    \"\"\"\n    Hit@k: indicates the fraction of test samples that contain at least\n    one of the ground truth labels in the top k predictions,\n    i.e topk.\n    Args:\n        predictions: Matrix containing the outputs of the model.\n        Dimensions are 'batch' x 'num_classes'.\n        actuals: Matrix containing the ground truth labels.\n        Dimensions are 'batch' x 'num_classes'.\n    Returns:\n        float: The average hit at one across the entire batch.\n    \"\"\"\n    top_prediction = np.argmax(predictions, 1)\n    hits = actuals[np.arange(actuals.shape[0]), top_prediction]\n    return np.mean(hits)\ndef calculate_precision_at_equal_recall_rate(predictions, actuals):\n    \"\"\"\n    PERR: measures the video-level annotation precision when we retrieve the same number\n     of entities per video as there are in the ground-truth.\n    More details please refer to:  https://arxiv.org/abs/1609.08675\n    Args:\n        predictions: Matrix containing the outputs of the model.\n        Dimensions are 'batch' x 'num_classes'."
        },
        {
            "comment": "The code calculates the average precision at equal recall rate and global average precision for a batch of videos. It iterates over each video, determines the number of labels, finds the top indices based on predictions, calculates item-wise precision, aggregates these precisions for all videos, and returns the averaged precision as well as the gap score.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":60-89",
            "content": "        actuals: Matrix containing the ground truth labels.\n        Dimensions are 'batch' x 'num_classes'.\n    Returns:\n        float: The average precision at equal recall rate across the entire batch.\n    \"\"\"\n    aggregated_precision = 0.0\n    num_videos = actuals.shape[0]\n    for row in np.arange(num_videos):\n        num_labels = int(np.sum(actuals[row]))\n        top_indices = np.argpartition(predictions[row],\n                                      -num_labels)[-num_labels:]\n        item_precision = 0.0\n        for label_index in top_indices:\n            if predictions[row][label_index] > 0:\n                item_precision += actuals[row][label_index]\n        item_precision /= top_indices.size\n        aggregated_precision += item_precision\n    aggregated_precision /= num_videos\n    return aggregated_precision\ndef calculate_gap(predictions, actuals, top_k=20):\n    \"\"\"\n    GAP: the global average precision.\n    Only the top_k predictions are taken for each of the videos.\n    Args:\n        predictions: Matrix containing the outputs of the model."
        },
        {
            "comment": "This code calculates the global average precision by first extracting the top k predictions for each video, sorted by class. It then accumulates these results using an AveragePrecisionCalculator and returns the global average precision.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":90-115",
            "content": "        Dimensions are 'batch' x 'num_classes'.\n        actuals: Matrix containing the ground truth labels.\n        Dimensions are 'batch' x 'num_classes'.\n        top_k: How many predictions to use per video.\n    Returns:\n        float: The global average precision.\n    \"\"\"\n    gap_calculator = ap_calculator.AveragePrecisionCalculator()\n    sparse_predictions, sparse_labels, num_positives = top_k_by_class(\n        predictions, actuals, top_k)\n    gap_calculator.accumulate(flatten(sparse_predictions),\n                              flatten(sparse_labels), sum(num_positives))\n    return gap_calculator.peek_ap_at_n()\ndef top_k_by_class(predictions, labels, k=20):\n    \"\"\"Extracts the top k predictions for each video, sorted by class.\n    Args:\n        predictions: A numpy matrix containing the outputs of the model.\n        Dimensions are 'batch' x 'num_classes'.\n        k: the top k non-zero entries to preserve in each prediction.\n    Returns:\n        A tuple (predictions,labels, true_positives). 'predictions' and 'labels'"
        },
        {
            "comment": "This function takes in a list of lists containing probability predictions and ground truth labels for multiple classes, and calculates top-k triplet predictions based on the given k value. It raises a ValueError if k is not a positive integer. The function then creates empty lists to store output predictions and labels for each class.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":116-136",
            "content": "        are lists of lists of floats. 'true_positives' is a list of scalars. The\n        length of the lists are equal to the number of classes. The entries in the\n        predictions variable are probability predictions, and\n        the corresponding entries in the labels variable are the ground truth for\n        those predictions. The entries in 'true_positives' are the number of true\n        positives for each class in the ground truth.\n    Raises:\n        ValueError: An error occurred when the k is not a positive integer.\n    \"\"\"\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer.\")\n    k = min(k, predictions.shape[1])\n    num_classes = predictions.shape[1]\n    prediction_triplets = []\n    for video_index in range(predictions.shape[0]):\n        prediction_triplets.extend(\n            top_k_triplets(predictions[video_index], labels[video_index], k))\n    out_predictions = [[] for v in range(num_classes)]\n    out_labels = [[] for v in range(num_classes)]\n    for triplet in prediction_triplets:"
        },
        {
            "comment": "This code calculates top-k predictions and labels from given predictions and labels arrays, and then initializes HitOneMetric class to store the evaluation metrics.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":137-166",
            "content": "        out_predictions[triplet[0]].append(triplet[1])\n        out_labels[triplet[0]].append(triplet[2])\n    out_true_positives = [np.sum(labels[:, i]) for i in range(num_classes)]\n    return out_predictions, out_labels, out_true_positives\ndef top_k_triplets(predictions, labels, k=20):\n    \"\"\"Get the top_k for a 1-d numpy array. Returns a sparse list of tuples in\n    (prediction, class) format\"\"\"\n    m = len(predictions)\n    k = min(k, m)\n    indices = np.argpartition(predictions, -k)[-k:]\n    return [(index, predictions[index], labels[index]) for index in indices]\n@METRIC.register\nclass HitOneMetric(BaseMetric):\n    \"\"\"A class to store the evaluation metrics.\"\"\"\n    def __init__(self,\n                 num_class,\n                 top_k,\n                 data_size,\n                 batch_size,\n                 log_interval=20):\n        \"\"\"Construct an HitOneMetric object to store the evaluation metrics.\"\"\"\n        self.hit_at_one = []\n        self.perr = []\n        self.gap = []\n        super().__init__(data_size, batch_size, log_interval)"
        },
        {
            "comment": "The code defines a HitOneMetric class for evaluating metrics in a video prediction task. The accumulate method calculates mean values of hit_at_one, perr, and gap, and logs the results as information. The clear method resets all metrics to an empty list. The update method updates the metric with each iteration, taking into account multi-card validation using PaddlePaddle's distributed functions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":168-192",
            "content": "    def accumulate(self):\n        logger.info(\n            '[TEST] finished, hit_at_one = {:.5f}, perr = {:.5f}, gap = {:.5f}'.\n            format(np.mean(np.array(self.hit_at_one)),\n                   np.mean(np.array(self.perr)), np.mean(np.array(self.gap))))\n    def clear(self):\n        \"\"\"Clear the evaluation metrics and reset the HitOneMetric object.\"\"\"\n        self.hit_at_one = []\n        self.perr = []\n        self.gap = []\n    def update(self, batch_id, data, outputs):\n        \"\"\"update metrics during each iter\n        \"\"\"\n        hit_at_one = paddle.to_tensor(outputs['hit_at_one'])\n        perr = paddle.to_tensor(outputs['perr'])\n        gap = paddle.to_tensor(outputs['gap'])\n        # NOTE(shipping): deal with multi cards validate\n        if self.world_size > 1:\n            hit_at_one = paddle.distributed.all_reduce(\n                hit_at_one,\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size\n            perr = paddle.distributed.all_reduce(\n                perr, op=paddle.distributed.ReduceOp.SUM) / self.world_size"
        },
        {
            "comment": "This code snippet is a part of the Youtube8m evaluation module in PaddleVideo. It calculates the gap between ground truth and prediction for each batch, performs all-reduce on the gap, appends it to the corresponding list. Also, logs information about processing batches during testing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/youtube8m/eval_util.py\":193-204",
            "content": "            gap = paddle.distributed.all_reduce(\n                gap, op=paddle.distributed.ReduceOp.SUM) / self.world_size\n        self.hit_at_one.append(hit_at_one.numpy())\n        self.perr.append(perr.numpy())\n        self.gap.append(gap.numpy())\n        # preds ensemble\n        if batch_id % self.log_interval == 0:\n            logger.info(\"[TEST] Processing batch {}/{}...\".format(\n                batch_id,\n                self.data_size // (self.batch_size * self.world_size),\n            ))"
        }
    ]
}