{
    "summary": "The code introduces a RecognizerDistillation class for recognizer distillation in PaddleVideo's framework, and includes model selection, modes like training and validation, loss functions, accuracy functions, and forward pass capabilities.",
    "details": [
        {
            "comment": "This code defines a RecognizerDistillation class that inherits from nn.Layer in PaddleVideo's framework. It implements recognizer distillation, which is a machine learning framework for object recognition tasks. The class takes optional arguments such as freeze_params_list (a list to set models trainable/not), models, and loss. It is registered under RECOGNIZERS and uses logger from paddlevideo's utils.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":0-33",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nfrom abc import abstractmethod\nimport paddle\nimport paddle.nn as nn\nfrom ...registry import RECOGNIZERS\nfrom ... import builder\nfrom paddlevideo.utils import get_logger, get_dist_info\nlogger = get_logger(\"paddlevideo\")\n@RECOGNIZERS.register()\nclass RecognizerDistillation(nn.Layer):\n    \"\"\"recognizer Distillation framework.\"\"\"\n    def __init__(self,\n                 freeze_params_list=None,\n                 models=None,\n                 loss=None,\n                 **kargs):\n        \"\"\"\n        Args:\n            freeze_params_list: list, set each model is trainable or not"
        },
        {
            "comment": "This code initializes an instance of a distillation model. It takes in a list of models and loss configurations, as well as a freeze_params_list (optional). It checks the lengths of the input lists, builds teacher and student models, and initializes backbone and head if they exist in the configurations.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":34-59",
            "content": "            models: config of distillaciton model.\n            loss: config of loss list\n        \"\"\"\n        super().__init__()\n        self.model_list = []\n        self.model_name_list = []\n        self.loss_cfgs = loss\n        if freeze_params_list is None:\n            freeze_params_list = [False] * len(models)\n        assert len(freeze_params_list) == len(models)\n        # build Teacher and Student model\n        for idx, model_config in enumerate(models):\n            assert len(model_config) == 1\n            key = list(model_config.keys())[0]  #Teacher or Student\n            model_config = model_config[key]\n            model_name = model_config['backbone']['name']\n            backbone, head = None, None\n            if model_config.get('backbone'):\n                backbone = builder.build_backbone(model_config['backbone'])\n                if hasattr(backbone, 'init_weights'):\n                    backbone.init_weights()\n            if model_config.get('head'):\n                head = builder.build_head(model_config['head'])"
        },
        {
            "comment": "Builds a distillation model by appending a head to the backbone, initializes weights for the head if possible, and sets trainable parameters based on freeze_params_list. Constructs loss functions using builder.build_loss().",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":60-84",
            "content": "                if hasattr(head, 'init_weights'):\n                    head.init_weights()\n            model = nn.Sequential(backbone, head)\n            logger.info('build distillation {} model done'.format(key))\n            # for add all parameters in nn.Layer class\n            self.model_list.append(self.add_sublayer(key, model))\n            self.model_name_list.append({model_name: key})\n            # set model trainable or not\n            if freeze_params_list[idx]:\n                for param in model.parameters():\n                    param.trainable = False\n        # build loss: support for loss list\n        self.loss_func_list = []\n        mode_keys = list(loss.keys())\n        for mode in mode_keys:\n            loss_cfgs = loss[mode]\n            for loss_cfg in loss_cfgs:\n                loss_func_dict = {}\n                model_name_pairs = loss_cfg.pop('model_name_pairs')\n                loss_func = builder.build_loss(loss_cfg)\n                loss_func_dict['mode'] = mode\n                loss_func_dict['loss_func'] = loss_func"
        },
        {
            "comment": "This code defines a class for handling different modes of operation (train, valid, test, infer) and includes methods to handle each mode. It also contains a method to calculate the loss based on output and labels in 'Train' or 'Val' mode. The code is likely used in a model framework and the class might be used to control the flow and operations of the model depending on the mode it runs in.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":85-113",
            "content": "                loss_func_dict['model_name_pairs'] = model_name_pairs\n                self.loss_func_list.append(loss_func_dict)\n    def forward(self, data_batch, mode='infer'):\n        \"\"\"\n        1. Define how the model is going to run, from input to output.\n        2. Console of train, valid, test or infer step\n        3. Set mode='infer' is used for saving inference model, refer to tools/export_model.py\n        \"\"\"\n        if mode == 'train':\n            return self.train_step(data_batch)\n        elif mode == 'valid':\n            return self.val_step(data_batch)\n        elif mode == 'test':\n            return self.test_step(data_batch)\n        elif mode == 'infer':\n            return self.infer_step(data_batch)\n        else:\n            raise NotImplementedError\n    def get_loss(self, output, labels, mode):\n        \"\"\"\n        Args:\n            output: dict, output name and its value\n            labels: label of data\n            mode: str, 'Train' or 'Val'\n        \"\"\"\n        output['GroundTruth'] = labels\n        loss_list = []"
        },
        {
            "comment": "This code is iterating over a list of loss function dictionaries to find the appropriate loss function based on the input mode. It then calculates the loss value and appends it to a list. Finally, it adds up all the loss values to get the total loss. In the `get_acc` method, it defines an inner function that calculates top-1 and top-5 accuracy scores using PaddlePaddle's `metric.accuracy` function. It also handles multi-card validation by reducing the sum of top-1 and top-5 accuracy scores across multiple cards.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":115-135",
            "content": "        for loss_func_dict in self.loss_func_list:\n            if mode == loss_func_dict['mode']:\n                model_name_pairs = loss_func_dict['model_name_pairs']\n                loss_func = loss_func_dict['loss_func']\n                loss_val = loss_func(output[model_name_pairs[0]],\n                                     output[model_name_pairs[1]])\n                loss_list.append(loss_val)\n        total_loss = paddle.add_n(loss_list)\n        return total_loss\n    def get_acc(self, scores, labels, mode='Train'):\n        def _get_acc(score, label, mode='Train'):\n            top1 = paddle.metric.accuracy(input=score, label=label, k=1)\n            top5 = paddle.metric.accuracy(input=score, label=label, k=5)\n            _, world_size = get_dist_info()\n            # Deal with multi cards validate\n            if world_size > 1 and mode == 'Val':  #reduce sum when valid\n                top1 = paddle.distributed.all_reduce(\n                    top1, op=paddle.distributed.ReduceOp.SUM) / world_size\n                top5 = paddle.distributed.all_reduce("
        },
        {
            "comment": "The code snippet contains a recognizerDistillation function, which calculates accuracy based on given scores and labels. It also includes a forward_model function for reshaping images and applying model operations. The train_step function defines the training process from input to output, including loss metrics calculation.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":136-164",
            "content": "                    top5, op=paddle.distributed.ReduceOp.SUM) / world_size\n            return top1, top5\n        if len(labels) == 1:\n            label = labels[0]\n            return _get_acc(scores, label)\n        # Deal with VideoMix\n        elif len(labels) == 3:\n            label_a, label_b, lam = labels\n            top1a, top5a = _get_acc(scores, label_a, mode)\n            top1b, top5b = _get_acc(scores, label_b, mode)\n            top1 = lam * top1a + (1 - lam) * top1b\n            top5 = lam * top5a + (1 - lam) * top5b\n            return top1, top5\n    def forward_model(self, imgs, model_name, model):\n        if model_name in ['PPTSM_v2', 'ResNetTweaksTSM']:\n            # [N,T,C,H,W] -> [N*T,C,H,W]\n            imgs = paddle.reshape(imgs, [-1] + list(imgs.shape[2:]))\n        return model(imgs)\n    def train_step(self, data_batch):\n        \"\"\"Define how the model is going to train, from input to output.\n        \"\"\"\n        out = {}\n        loss_metrics = {}\n        imgs = data_batch[0]\n        labels = data_batch[1:]"
        },
        {
            "comment": "This code defines a class that implements a recognizer for distillation. The model takes in an image and a model name, and returns the output from both the student and teacher models. It calculates loss using the student and teacher outputs, as well as top-1 and top-5 accuracy metrics from the student's output only. This is used for both training (train_step) and validation (val_step). The class utilizes a list of model names and corresponding models for both types, student and teacher, and iterates over them to apply the forward pass and calculate loss and metrics.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":166-192",
            "content": "        for idx, item in enumerate(self.model_name_list):\n            model = self.model_list[idx]\n            model_name = list(item.keys())[0]\n            model_type = item[model_name]  # Teacher or Student\n            out[model_type] = self.forward_model(imgs, model_name, model)\n        # out_student, out_teacher\n        loss = self.get_loss(out, labels, 'Train')\n        loss_metrics['loss'] = loss\n        # calculate acc with student output\n        top1, top5 = self.get_acc(out['Student'], labels)\n        loss_metrics['top1'] = top1\n        loss_metrics['top5'] = top5\n        return loss_metrics\n    def val_step(self, data_batch):\n        out = {}\n        loss_metrics = {}\n        imgs = data_batch[0]\n        labels = data_batch[1:]\n        for idx, item in enumerate(self.model_name_list):\n            model = self.model_list[idx]\n            model_name = list(item.keys())[0]\n            model_type = item[model_name]  # Teacher or Student\n            out[model_type] = self.forward_model(imgs, model_name, model)"
        },
        {
            "comment": "In this code snippet, the get_loss and get_acc functions are used to calculate loss and accuracy metrics for a \"Student\" model. The test_step function tests the Student model using forward_model function, and the infer_step function is not implemented here. This code seems related to evaluating the performance of a student model in image recognition tasks.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":194-223",
            "content": "        # Loss of student with gt:  out_student, label\n        loss = self.get_loss(out, labels, 'Val')\n        loss_metrics['loss'] = loss\n        top1, top5 = self.get_acc(out['Student'], labels, 'Val')\n        loss_metrics['top1'] = top1\n        loss_metrics['top5'] = top5\n        return loss_metrics\n    def test_step(self, data_batch):\n        \"\"\"Define how the model is going to test, from input to output.\"\"\"\n        imgs = data_batch[0]\n        # Use Student to test\n        for idx, item in enumerate(self.model_name_list):\n            model = self.model_list[idx]\n            model_name = list(item.keys())[0]\n            model_type = item[model_name]  # Teacher or Student\n            if model_type == \"Student\":\n                out = self.forward_model(imgs, model_name, model)\n        return out\n    def infer_step(self, data_batch):\n        \"\"\"Define how the model is going to test, from input to output.\"\"\"\n        imgs = data_batch[0]\n        # Use Student to infer\n        for idx, item in enumerate(self.model_name_list):"
        },
        {
            "comment": "The code selects a model from the model_list based on the idx, and assigns its name to model_name. If the model type is \"Student\", it calls forward_model function passing imgs, model_name, and model as parameters, and returns the output.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/recognizers/recognizerDistillation.py\":224-230",
            "content": "            model = self.model_list[idx]\n            model_name = list(item.keys())[0]\n            model_type = item[model_name]  # Teacher or Student\n            if model_type == \"Student\":\n                out = self.forward_model(imgs, model_name, model)\n        return out"
        }
    ]
}