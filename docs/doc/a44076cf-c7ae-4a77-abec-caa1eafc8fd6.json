{
    "summary": "This function calculates video results by implementing one-dimensional non-maximal suppression, removes overlapping detections, and processes video properties. It takes in various parameters such as label map file, fps, score threshold, iou threshold, and frame offset.",
    "details": [
        {
            "comment": "This function takes in label_map, data, and topk as input arguments. It calculates the video result based on the given parameters and returns it. The video result is a list of lists where each sub-list contains the feature start ID, feature end ID, label ID, label name, score, and label IOU for each action detected in the video.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/utils/process_result.py\":0-38",
            "content": "\"\"\"\n# @File  : process_result.py\n# @Author: macaihong\n# @Date  : 2019/12/15\n# @Desc  :\n\"\"\"\nimport sys\nimport os\nimport re\nimport numpy as np\nimport pickle\nimport json\nimport logger\nlogger = logger.Logger()\ndef get_data_res(label_map, data, topk):\n    \"\"\"get_data_res\"\"\"\n    sum_vid = len(data)\n    video_result = []\n    for i in range(sum_vid):\n        vid_name = data[i][0][0]\n        # true_label predict_start predict_end predict_score predict_len gt_iou gt_start gt_ioa\n        feature_start_id = float(data[i][0][1]['start'])\n        feature_end_id = float(data[i][0][1]['end'])\n        feature_stage1_score = data[i][0][1]['score']\n        predict_res = []\n        for k in range(topk):\n            score_top = data[i][1][k]\n            labelid_top = data[i][2][k]\n            label_iou = data[i][3]\n            labelname_top = label_map[str(labelid_top)]\n            video_result.append([\n                feature_start_id, feature_end_id, labelid_top, labelname_top,\n                score_top, label_iou\n            ])\n    return video_result"
        },
        {
            "comment": "This code implements one-dimensional non-maximal suppression, which performs non-overlapping detection on bounding boxes. The function takes in a list of bounding boxes and removes any overlapping detections with an Intersection over Union (IoU) threshold greater than the given threshold. The resulting list contains only the non-overlapping detections.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/utils/process_result.py\":41-77",
            "content": "def base_nms(bboxes, thresh, delta=0, nms_id=2):\n    \"\"\"\n    One-dimensional non-maximal suppression\n    :param bboxes: [[vid, label, st, ed, score, ...], ...]\n    :param thresh:\n    :return:\n    \"\"\"\n    \"\"\"\n    t1 = bboxes[:, 0]\n    t2 = bboxes[:, 1]\n    scores = bboxes[:, nms_id]\n    \"\"\"\n    t1 = np.array([max(0, x[0] - delta) for x in bboxes])\n    t2 = np.array([x[1] + delta for x in bboxes])\n    scores = np.array([x[nms_id] for x in bboxes])\n    durations = t2 - t1\n    order = scores.argsort()[::-1]\n    keep = []\n    while order.size > 0:\n        i = order[0]\n        keep.append(i)\n        tt1 = np.maximum(t1[i], t1[order[1:]])\n        tt2 = np.minimum(t2[i], t2[order[1:]])\n        intersection = tt2 - tt1\n        IoU = intersection / (durations[i] + durations[order[1:]] -\n                              intersection).astype(float)\n        inds = np.where(IoU <= thresh)[0]\n        order = order[inds + 1]\n    return [bboxes[i] for i in keep]\ndef process_proposal(source_prop_box,\n                     min_frame_thread=5,"
        },
        {
            "comment": "The code contains two functions: `process_video_prop` and `process_video_classify`. The first function processes video properties based on start frame, end frame, and score thresholds. It applies non-maximum suppression (NMS) to remove redundant or weak detections. The second function filters video properties based on background id and performs NMS for specific parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/utils/process_result.py\":78-109",
            "content": "                     nms_thresh=0.7,\n                     score_thresh=0.01):\n    \"\"\"process_video_prop\"\"\"\n    prop_box = []\n    for items in source_prop_box:\n        start_frame = float(items[0])\n        end_frame = float(items[1])\n        score = float(items[2])\n        if end_frame - start_frame < min_frame_thread or score < score_thresh:\n            continue\n        prop_box.append([start_frame, end_frame, score])\n    prop_box_keep = base_nms(prop_box, nms_thresh)\n    prop_res = []\n    for res in prop_box_keep:\n        prop_res.append({'start': res[0], 'end': res[1], 'score': res[2]})\n    return prop_res\ndef process_video_classify(video_prop, fps, score_thread, iou_thread, \\\n                           nms_id=5, nms_thread=0.01, nms_delta=10, backgroundid=0):\n    \"\"\"process_video_classify\"\"\"\n    prop_filter = []\n    for item in video_prop:\n        if item[2] == backgroundid:\n            continue\n        prop_filter.append(item)\n    # prop_filter = sorted(prop_filter, key=lambda x: x[nms_id], reverse=True)\n    prop_filter = base_nms(prop_filter, nms_thread, nms_delta, nms_id)"
        },
        {
            "comment": "This code sorts prop_filter based on timestamps, then iterates over the sorted list to extract start and end times, label IDs, and scores. It appends these details to video_results if the classify score is greater than a threshold and IOU score is also above the threshold.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/utils/process_result.py\":110-135",
            "content": "    prop_filter = sorted(prop_filter, key=lambda x: x[0])\n    video_results = []\n    for item in prop_filter:\n        start_sec = item[0] / fps\n        end_sec = item[1] / fps\n        start_id_frame = item[0]\n        end_id_frame = item[1]\n        # start_time = \"%02d:%02d:%02d\" % ((start_id_frame / fps) / 3600, \\\n        #     ((start_id_frame / fps) % 3600) / 60, (start_id_frame / fps) % 60)\n        # end_time = \"%02d:%02d:%02d\" % ((end_id_frame / fps) / 3600, \\\n        #     ((end_id_frame / fps) % 3600) / 60, (end_id_frame / fps) % 60)\n        start_time = int(start_id_frame / fps)\n        end_time = int(end_id_frame / fps)\n        label_id = item[2]\n        label_name = item[3]\n        label_classify_score = item[4]\n        label_iou_score = item[5]\n        if label_classify_score > score_thread and label_iou_score > iou_thread:\n            video_results.append({\n                \"start_time\": start_time,\n                \"end_time\": end_time,\n                \"label_id\": label_id,\n                \"label_name\": label_name,"
        },
        {
            "comment": "This function, `get_action_result`, takes in `result_info`, `label_map_file`, `fps`, `score_thread`, `iou_thread`, `nms_id`, `nms_thread`, and `frame_offset` as parameters. It uses the `json.load()` method to load a label map from the file specified by `label_map_file`. The function then calls `get_data_res` with the loaded label map, `result_info`, and `topk` to obtain original results (`org_result`). Finally, it processes these original results using `process_video_classify()`, passing in additional parameters such as `fps`, `score_thread`, `iou_thread`, `nms_id`, `nms_thread`, and `frame_offset`. The function returns the non-maximum suppression (`nms`) result.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/action_detect/utils/process_result.py\":136-154",
            "content": "                \"classify_score\": label_classify_score,\n                \"iou_score\": label_iou_score\n            })\n    return video_results\ndef get_action_result(result_info, label_map_file, fps, score_thread=0, \\\n                      iou_thread=0, nms_id=5, nms_thread=0.01, frame_offset=10, topk=1):\n    \"\"\"get_action_result\"\"\"\n    label_map = json.load(open(label_map_file, 'r', encoding='utf-8'))\n    org_result = get_data_res(label_map, result_info, topk)\n    nms_result = process_video_classify(org_result, fps, score_thread,\n                                        iou_thread, nms_id, nms_thread,\n                                        frame_offset)\n    return nms_result"
        }
    ]
}