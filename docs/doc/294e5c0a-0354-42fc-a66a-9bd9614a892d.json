{
    "summary": "This code initializes a DAVIS 2017 dataset class for loading and preprocessing, creates a custom dataloader, prepares input for Ma-Net model, and outputs JSON files with sequence data.",
    "details": [
        {
            "comment": "This code snippet defines a DAVIS2017_Test_Manager class for loading and managing test data from the DAVIS 2017 dataset. It accepts parameters such as split, root directory, transformations to apply, and sequence name. The get_image() method retrieves an image from the specified directory based on the index, reads it into a numpy array, and converts it into float32 data type. This class can be used for loading test images in the DAVIS 2017 dataset for further processing or analysis.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":0-39",
            "content": "from __future__ import division\nimport json\nimport os\nimport shutil\nimport numpy as np\nimport paddle, cv2\nfrom random import choice\nfrom paddle.io import Dataset\nimport json\nfrom PIL import Image\nfrom davisinteractive.utils.scribbles import scribbles2mask, annotated_frames\nimport sys\nsys.path.append(\"..\")\nfrom config import cfg\nimport time\nclass DAVIS2017_Test_Manager():\n    def __init__(self,\n                 split='val',\n                 root=cfg.DATA_ROOT,\n                 transform=None,\n                 rgb=False,\n                 seq_name=None):\n        self.split = split\n        self.db_root_dir = root\n        self.rgb = rgb\n        self.transform = transform\n        self.seq_name = seq_name\n    def get_image(self, idx):\n        frame_name = str(idx)\n        while len(frame_name) != 5:\n            frame_name = '0' + frame_name\n        imgpath = os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                               str(self.seq_name), frame_name + '.jpg')\n        img = cv2.imread(imgpath)\n        img = np.array(img, dtype=np.float32)"
        },
        {
            "comment": "This code is initializing a dataset for DAVIS2017, which contains images and their features. It loads the image list from a specified directory, and applies optional transformations to the samples before returning them. The dataset supports different splits (e.g., training or validation) and allows for specifying an optional sequence name.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":40-72",
            "content": "        sample = {'img': img}\n        if self.transform is not None:\n            sample = self.transform(sample)\n        return sample\nclass DAVIS2017_Feature_Extract(Dataset):\n    def __init__(self,\n                 split='val',\n                 root=cfg.DATA_ROOT,\n                 transform=None,\n                 rgb=False,\n                 seq_name=None):\n        self.split = split\n        self.db_root_dir = root\n        self.rgb = rgb\n        self.transform = transform\n        self.seq_name = seq_name\n        self.img_list = np.sort(\n            os.listdir(\n                os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                             str(seq_name))))\n    def __len__(self):\n        return len(self.img_list)\n    def __getitem__(self, idx):\n        img = self.img_list[idx]\n        imgpath = os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                               str(self.seq_name), img)\n        current_img = cv2.imread(imgpath)\n        current_img = np.array(current_img, dtype=np.float32)"
        },
        {
            "comment": "The code defines a DAVIS2017_VOS_Test dataset class which loads data from the DAVIS 2017 dataset for semantic segmentation tasks. It takes various parameters such as split, root directory, transformation function, if RGB images are required, result root directory, and sequence name. It reads a list of sequences from a file and returns an image sample along with its metadata (sequence name, height, width, and image path).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":73-108",
            "content": "        h, w, _ = current_img.shape\n        sample = {'img1': current_img}\n        sample['meta'] = {\n            'seq_name': self.seq_name,\n            'h_w': (h, w),\n            'img_path': imgpath\n        }\n        if self.transform is not None:\n            sample = self.transform(sample)\n        return sample\nclass DAVIS2017_VOS_Test(Dataset):\n    \"\"\"\n    \"\"\"\n    def __init__(self,\n                 split='val',\n                 root=cfg.DATA_ROOT,\n                 transform=None,\n                 rgb=False,\n                 result_root=None,\n                 seq_name=None):\n        self.split = split\n        self.db_root_dir = root\n        self.result_root = result_root\n        self.rgb = rgb\n        self.transform = transform\n        self.seq_name = seq_name\n        self.seq_list_file = os.path.join(\n            self.db_root_dir, 'ImageSets', '2017',\n            '_'.join(self.split) + '_instances.txt')\n        self.seqs = []\n        for splt in self.split:\n            with open(\n                    os.path.join(self.db_root_dir, 'ImageSets', '2017',"
        },
        {
            "comment": "The code reads sequences from a file and extends the existing sequence list. It then checks if preprocessing is required and performs it if necessary. The code asserts that the sequence name exists in the dictionary of sequences. Next, it retrieves image names and label names, creating lists of image paths and label paths respectively. Finally, it ensures that a specific file exists.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":109-134",
            "content": "                                 self.split + '.txt')) as f:\n                seqs_tmp = f.readlines()\n            seqs_tmp = list(map(lambda elem: elem.strip(), seqs_tmp))\n            self.seqs.extend(seqs_tmp)\n        if not self._check_preprocess():\n            self._preprocess()\n        assert self.seq_name in self.seq_dict.keys(\n        ), '{} not in {} set.'.format(self.seq_name, '_'.join(self.split))\n        names_img = np.sort(\n            os.listdir(\n                os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                             str(seq_name))))\n        img_list = list(\n            map(lambda x: os.path.join('JPEGImages/480p/', str(seq_name), x),\n                names_img))\n        name_label = np.sort(\n            os.listdir(\n                os.path.join(self.db_root_dir, 'Annotations/480p/',\n                             str(seq_name))))\n        labels = list(\n            map(lambda x: os.path.join('Annotations/480p/', str(seq_name), x),\n                name_label))\n        if not os.path.isfile("
        },
        {
            "comment": "This code creates a data loader for the DAVIS 2017 dataset. It checks if the result directory exists, and if not, it creates it and copies the label file to the new directory. If the directory already exists, it simply copies the label file. The function then sets the first image and its label, as well as the remaining images in the list. Lastly, it defines the length of the dataset and a method for getting items from the dataset at specific indices.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":135-160",
            "content": "                os.path.join(self.result_root, seq_name, name_label[0])):\n            if not os.path.exists(os.path.join(self.result_root, seq_name)):\n                os.makedirs(os.path.join(self.result_root, seq_name))\n                shutil.copy(\n                    os.path.join(self.db_root_dir, labels[0]),\n                    os.path.join(self.result_root, seq_name, name_label[0]))\n            else:\n                shutil.copy(\n                    os.path.join(self.db_root_dir, labels[0]),\n                    os.path.join(self.result_root, seq_name, name_label[0]))\n        self.first_img = names_img[0]\n        self.first_label = name_label[0]\n        self.img_list = names_img[1:]\n    def __len__(self):\n        return len(self.img_list)\n    def __getitem__(self, idx):\n        img = self.img_list[idx]\n        imgpath = os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                               str(self.seq_name), img)\n        num_frame = int(img.split('.')[0])\n        ref_img = os.path.join(self.db_root_dir, 'JPEGImages/480p/',"
        },
        {
            "comment": "The code snippet is responsible for loading images and labels from a specific path. It handles image path formatting, ensures all frames have 5 digits, reads images using cv2, converts them to numpy arrays with float32 dtype, and retrieves reference labels by opening and converting the label file to uint8 dtype.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":161-185",
            "content": "                               str(self.seq_name), self.first_img)\n        prev_frame = num_frame - 1\n        prev_frame = str(prev_frame)\n        while len(prev_frame) != 5:\n            prev_frame = '0' + prev_frame\n        prev_img = os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                                str(self.seq_name),\n                                prev_frame + '.' + img.split('.')[-1])\n        current_img = cv2.imread(imgpath)\n        current_img = np.array(current_img, dtype=np.float32)\n        ref_img = cv2.imread(ref_img)\n        ref_img = np.array(ref_img, dtype=np.float32)\n        prev_img = cv2.imread(prev_img)\n        prev_img = np.array(prev_img, dtype=np.float32)\n        ref_label = os.path.join(self.db_root_dir, 'Annotations/480p/',\n                                 str(self.seq_name), self.first_label)\n        ref_label = Image.open(ref_label)\n        ref_label = np.array(ref_label, dtype=np.uint8)\n        prev_label = os.path.join(\n            self.result_root, str(self.seq_name),"
        },
        {
            "comment": "This code appears to be part of a data loader for a video object detection task. It loads frames and labels from a specific dataset (DAVIS 2017) and creates samples for each frame. The _check_preprocess function checks if the sequence list file exists, and if so, it loads the dictionary of sequences. The _preprocess function initializes an empty dictionary for the sequence dictionary and iterates over the specified sequences to process them.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":186-218",
            "content": "            prev_frame + '.' + self.first_label.split('.')[-1])\n        prev_label = Image.open(prev_label)\n        prev_label = np.array(prev_label, dtype=np.uint8)\n        obj_num = self.seq_dict[self.seq_name][-1]\n        sample = {\n            'ref_img': ref_img,\n            'prev_img': prev_img,\n            'current_img': current_img,\n            'ref_label': ref_label,\n            'prev_label': prev_label\n        }\n        sample['meta'] = {\n            'seq_name': self.seq_name,\n            'frame_num': num_frame,\n            'obj_num': obj_num,\n            'current_name': img\n        }\n        if self.transform is not None:\n            sample = self.transform(sample)\n        return sample\n    def _check_preprocess(self):\n        _seq_list_file = self.seq_list_file\n        if not os.path.isfile(_seq_list_file):\n            return False\n        else:\n            self.seq_dict = json.load(open(self.seq_list_file, 'r'))\n            return True\n    def _preprocess(self):\n        self.seq_dict = {}\n        for seq in self.seqs:"
        },
        {
            "comment": "This code reads object masks from DAVIS 2017 dataset, obtains the number of objects, and creates a dictionary containing sequence names as keys and their corresponding unique object IDs as values. The dictionary is then saved to a file in JSON format for further use in the DAVIS2017_VOS_Train class, which serves as the training dataset for the DAVIS 2017 dataset.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":219-243",
            "content": "            # Read object masks and get number of objects\n            name_label = np.sort(\n                os.listdir(\n                    os.path.join(self.db_root_dir, 'Annotations/480p/', seq)))\n            label_path = os.path.join(self.db_root_dir, 'Annotations/480p/',\n                                      seq, name_label[0])\n            _mask = np.array(Image.open(label_path))\n            _mask_ids = np.unique(_mask)\n            n_obj = _mask_ids[-1]\n            self.seq_dict[seq] = list(range(1, n_obj + 1))\n        with open(self.seq_list_file, 'w') as outfile:\n            outfile.write('{{\\n\\t\"{:s}\": {:s}'.format(\n                self.seqs[0], json.dumps(self.seq_dict[self.seqs[0]])))\n            for ii in range(1, len(self.seqs)):\n                outfile.write(',\\n\\t\"{:s}\": {:s}'.format(\n                    self.seqs[ii], json.dumps(self.seq_dict[self.seqs[ii]])))\n            outfile.write('\\n}\\n')\n        print('Preprocessing finished')\nclass DAVIS2017_VOS_Train(Dataset):\n    \"\"\"DAVIS2017 dataset for training"
        },
        {
            "comment": "This code initializes a class for loading and preprocessing data from the DAVIS 2017 dataset. It takes parameters such as split, root directory, transformation functions, and RGB mode. The code reads sequence lists and checks if pre-processing is necessary before creating a list of samples to be loaded.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":245-272",
            "content": "    Return: imgs: N*2*3*H*W,label: N*2*1*H*W, seq-name: N, frame_num:N\n    \"\"\"\n    def __init__(self,\n                 split='train',\n                 root=cfg.DATA_ROOT,\n                 transform=None,\n                 rgb=False):\n        self.split = split\n        self.db_root_dir = root\n        self.rgb = rgb\n        self.transform = transform\n        self.seq_list_file = os.path.join(\n            self.db_root_dir, 'ImageSets', '2017',\n            '_'.join(self.split) + '_instances.txt')\n        self.seqs = []\n        for splt in self.split:\n            with open(\n                    os.path.join(self.db_root_dir, 'ImageSets', '2017',\n                                 self.split + '.txt')) as f:\n                seqs_tmp = f.readlines()\n            seqs_tmp = list(map(lambda elem: elem.strip(), seqs_tmp))\n            self.seqs.extend(seqs_tmp)\n        self.imglistdic = {}\n        if not self._check_preprocess():\n            self._preprocess()\n        self.sample_list = []\n        for seq_name in self.seqs:\n            images = np.sort("
        },
        {
            "comment": "The code defines a class for loading data from the DAVIS 2017 dataset, extracting image and annotation files based on the given sequence name. It also provides methods to get the length of the dataset and retrieve specific items by index. The dataset is organized into 'JPEGImages/480p' and 'Annotations/480p' directories with corresponding sequence names. It selects a random previous image from the list, increments its frame number by 1 to get the next image, and returns both the image and annotation files.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":273-298",
            "content": "                os.listdir(\n                    os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                                 seq_name.strip())))\n            images_path = list(\n                map(\n                    lambda x: os.path.join('JPEGImages/480p/', seq_name.strip(),\n                                           x), images))\n            lab = np.sort(\n                os.listdir(\n                    os.path.join(self.db_root_dir, 'Annotations/480p/',\n                                 seq_name.strip())))\n            lab_path = list(\n                map(\n                    lambda x: os.path.join('Annotations/480p/', seq_name.strip(\n                    ), x), lab))\n            self.imglistdic[seq_name] = (images, lab)\n    def __len__(self):\n        return len(self.seqs)\n    def __getitem__(self, idx):\n        seqname = self.seqs[idx]\n        imagelist, lablist = self.imglistdic[seqname]\n        prev_img = np.random.choice(imagelist[:-1], 1)\n        prev_img = prev_img[0]\n        frame_num = int(prev_img.split('.')[0]) + 1"
        },
        {
            "comment": "Processing two adjacent frames and labels: Reads next image, prepares previous image and their corresponding labels from file paths.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":299-319",
            "content": "        next_frame = str(frame_num)\n        while len(next_frame) != 5:\n            next_frame = '0' + next_frame\n        ###############################Processing two adjacent frames and labels\n        img2path = os.path.join('JPEGImages/480p/', seqname,\n                                next_frame + '.' + prev_img.split('.')[-1])\n        img2 = cv2.imread(os.path.join(self.db_root_dir, img2path))\n        img2 = np.array(img2, dtype=np.float32)\n        imgpath = os.path.join('JPEGImages/480p/', seqname, prev_img)\n        img1 = cv2.imread(os.path.join(self.db_root_dir, imgpath))\n        img1 = np.array(img1, dtype=np.float32)\n        ###############\n        labelpath = os.path.join(\n            'Annotations/480p/', seqname,\n            prev_img.split('.')[0] + '.' + lablist[0].split('.')[-1])\n        label1 = Image.open(os.path.join(self.db_root_dir, labelpath))\n        label2path = os.path.join('Annotations/480p/', seqname,\n                                  next_frame + '.' + lablist[0].split('.')[-1])\n        label2 = Image.open(os.path.join(self.db_root_dir, label2path))"
        },
        {
            "comment": "This code randomly selects a reference image and associated scribble label for each video frame, ensuring the labels are unique and not from the same or consecutive frames. It also ensures that the selected images have corresponding annotations in the 480p folder.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":321-343",
            "content": "        label1 = np.array(label1, dtype=np.uint8)\n        label2 = np.array(label2, dtype=np.uint8)\n        ###################\n        ref_img = np.random.choice(imagelist, 1)\n        ref_img = ref_img[0]\n        ref_img_name = ref_img\n        ref_scribble_label = Image.open(\n            os.path.join(\n                self.db_root_dir, 'Annotations/480p/', seqname,\n                ref_img_name.split('.')[0] + '.' + lablist[0].split('.')[-1]))\n        ref_scribble_label = np.array(ref_scribble_label, dtype=np.uint8)\n        while len(np.unique(ref_scribble_label)) < self.seq_dict[seqname][\n                -1] + 1 or ref_img == prev_img or ref_img == (\n                    next_frame + '.' + prev_img.split('.')[-1]):\n            ref_img = np.random.choice(imagelist, 1)\n            ref_img = ref_img[0]\n            ref_img_name = ref_img\n            ref_scribble_label = Image.open(\n                os.path.join(\n                    self.db_root_dir, 'Annotations/480p/', seqname,\n                    ref_img_name.split('.')[0] + '.' +"
        },
        {
            "comment": "This code reads an image, splits it into RGB channels if required, and stores it in a dictionary along with other images and labels. It also assigns metadata to the sample. The transform is applied if not None.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":344-373",
            "content": "                    lablist[0].split('.')[-1]))\n            ref_scribble_label = np.array(ref_scribble_label, dtype=np.int64)\n        ref_img = os.path.join('JPEGImages/480p/', seqname, ref_img)\n        ref_img = cv2.imread(os.path.join(self.db_root_dir, ref_img))\n        ref_img = np.array(ref_img, dtype=np.float32)\n        ####\n        ###################\n        if self.rgb:\n            img1 = img1[:, :, [2, 1, 0]]\n            img2 = img2[:, :, [2, 1, 0]]\n            ref_img = ref_img[:, :, [2, 1, 0]]\n        obj_num = self.seq_dict[seqname][-1]\n        sample = {\n            'ref_img': ref_img,\n            'img1': img1,\n            'img2': img2,\n            'ref_scribble_label': ref_scribble_label,\n            'label1': label1,\n            'label2': label2\n        }\n        sample['meta'] = {\n            'seq_name': seqname,\n            'frame_num': frame_num,\n            'obj_num': obj_num\n        }\n        if self.transform is not None:\n            sample = self.transform(sample)\n        sample['ref_scribble_label'] = paddle.to_tensor("
        },
        {
            "comment": "The code defines a function that loads and preprocesses data from a specific source. It checks if the sequence list file exists and then proceeds to read object masks, getting the number of objects in each sequence.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":374-399",
            "content": "            sample['ref_scribble_label'], dtype='int64')\n        sample['label1'] = paddle.to_tensor(sample['label1'], dtype='int64')\n        sample['label2'] = paddle.to_tensor(sample['label2'], dtype='int64')\n        return sample\n    ########################\n    def _check_preprocess(self):\n        _seq_list_file = self.seq_list_file\n        if not os.path.isfile(_seq_list_file):\n            return False\n        else:\n            self.seq_dict = json.load(open(self.seq_list_file, 'r'))\n            return True\n    def _preprocess(self):\n        self.seq_dict = {}\n        for seq in self.seqs:\n            # Read object masks and get number of objects\n            name_label = np.sort(\n                os.listdir(\n                    os.path.join(self.db_root_dir, 'Annotations/480p/', seq)))\n            label_path = os.path.join(self.db_root_dir, 'Annotations/480p/',\n                                      seq, name_label[0])\n            _mask = np.array(Image.open(label_path))\n            _mask_ids = np.unique(_mask)"
        },
        {
            "comment": "This code defines a class for the DAVIS2017 dataset used in training. It initializes the dataset object based on specified parameters, writes a sequence list file containing frame numbers for each sequence, and provides the functionality to load images, masks, and other data required for training.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":400-430",
            "content": "            n_obj = _mask_ids[-1]\n            self.seq_dict[seq] = list(range(1, n_obj + 1))\n        with open(self.seq_list_file, 'w') as outfile:\n            outfile.write('{{\\n\\t\"{:s}\": {:s}'.format(\n                self.seqs[0], json.dumps(self.seq_dict[self.seqs[0]])))\n            for ii in range(1, len(self.seqs)):\n                outfile.write(',\\n\\t\"{:s}\": {:s}'.format(\n                    self.seqs[ii], json.dumps(self.seq_dict[self.seqs[ii]])))\n            outfile.write('\\n}\\n')\n        print('Preprocessing finished')\nclass DAVIS2017_Train(Dataset):\n    \"\"\"DAVIS2017 dataset for training\n    Return: imgs: N*2*3*H*W,label: N*2*1*H*W, seq-name: N, frame_num:N\n    \"\"\"\n    def __init__(self,\n                 split='train',\n                 root=cfg.DATA_ROOT,\n                 transform=None,\n                 rgb=False):\n        self.split = split\n        self.db_root_dir = root\n        self.rgb = rgb\n        self.transform = transform\n        self.seq_list_file = os.path.join(\n            self.db_root_dir, 'ImageSets', '2017',"
        },
        {
            "comment": "This code is creating a custom dataloader for the DAVIS dataset. It loads the image and annotation files, sorts them by name, checks if preprocessing needs to be done, and then forms a sample list containing the image paths and labels. The result will be used for training or testing purposes in the Ma-Net application.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":431-455",
            "content": "            '_'.join(self.split) + '_instances.txt')\n        self.seqs = []\n        for splt in self.split:\n            with open(\n                    os.path.join(self.db_root_dir, 'ImageSets', '2017',\n                                 self.split + '.txt')) as f:\n                seqs_tmp = f.readlines()\n            seqs_tmp = list(map(lambda elem: elem.strip(), seqs_tmp))\n            self.seqs.extend(seqs_tmp)\n        if not self._check_preprocess():\n            self._preprocess()\n        self.sample_list = []\n        for seq_name in self.seqs:\n            images = np.sort(\n                os.listdir(\n                    os.path.join(self.db_root_dir, 'JPEGImages/480p/',\n                                 seq_name.strip())))\n            images_path = list(\n                map(\n                    lambda x: os.path.join('JPEGImages/480p/', seq_name.strip(),\n                                           x), images))\n            lab = np.sort(\n                os.listdir(\n                    os.path.join(self.db_root_dir, 'Annotations/480p/',"
        },
        {
            "comment": "The code creates a custom dataloader for a dataset with two adjacent frames and their corresponding labels. It takes the images and label paths, appends them to a list of dictionaries, and handles any necessary padding to ensure frame numbers have 5 digits. The length of the dataloader is determined by the number of samples in the sample_list, and the __getitem__ method retrieves specific samples based on their index.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":456-484",
            "content": "                                 seq_name.strip())))\n            lab_path = list(\n                map(\n                    lambda x: os.path.join('Annotations/480p/', seq_name.strip(\n                    ), x), lab))\n            for img_path, label_path in zip(images_path[:-1], lab_path[:-1]):\n                tmp_dic = {\n                    'img': img_path,\n                    'label': label_path,\n                    'seq_name': seq_name,\n                    'frame_num': img_path.split('/')[-1].split('.')[0]\n                }\n                self.sample_list.append(tmp_dic)\n    def __len__(self):\n        return len(self.sample_list)\n    def __getitem__(self, idx):\n        tmp_sample = self.sample_list[idx]\n        imgpath = tmp_sample['img']\n        labelpath = tmp_sample['label']\n        seqname = tmp_sample['seq_name']\n        frame_num = int(tmp_sample['frame_num']) + 1\n        next_frame = str(frame_num)\n        while len(next_frame) != 5:\n            next_frame = '0' + next_frame\n        ###############################Processing two adjacent frames and labels"
        },
        {
            "comment": "The code reads image and label files for a video sequence from their respective directories, converts them to numpy arrays of dtype float32 and int32 respectively for compatibility with the model's stack function. It also retrieves reference frame information from ref_frame_dic for the given sequence.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":485-505",
            "content": "        img2path = os.path.join('JPEGImages/480p/', seqname,\n                                next_frame + '.' + imgpath.split('.')[-1])\n        img2 = cv2.imread(os.path.join(self.db_root_dir, img2path))\n        img2 = np.array(img2, dtype=np.float32)\n        img1 = cv2.imread(os.path.join(self.db_root_dir, imgpath))\n        img1 = np.array(img1, dtype=np.float32)\n        ###############\n        label1 = Image.open(os.path.join(self.db_root_dir, labelpath))\n        label2path = os.path.join('Annotations/480p/', seqname,\n                                  next_frame + '.' + labelpath.split('.')[-1])\n        label2 = Image.open(os.path.join(self.db_root_dir, label2path))\n        label1 = np.array(\n            label1, dtype=np.int32\n        )  # fixed, uint8->int32, because layers.stack does not support uint8\n        label2 = np.array(\n            label2, dtype=np.int32\n        )  # fixed, uint8->int32, because layers.stack does not support uint8\n        ###################\n        ref_tmp_dic = self.ref_frame_dic[seqname]"
        },
        {
            "comment": "This code reads the reference image, scribble label, and ground truth frame from a dictionary. It then converts them to appropriate data types for processing. If rgb=True, it changes the color order. It also gets the total number of objects in the sequence. Finally, it creates a sample dictionary with all these elements.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":506-530",
            "content": "        ref_img = ref_tmp_dic['ref_frame']\n        ref_scribble_label = ref_tmp_dic['scribble_label']\n        ref_img = cv2.imread(os.path.join(self.db_root_dir, ref_img))\n        ref_img = np.array(ref_img, dtype=np.float32)\n        ref_frame_gt = ref_tmp_dic['ref_frame_gt']\n        ref_frame_gt = Image.open(os.path.join(self.db_root_dir, ref_frame_gt))\n        ref_frame_gt = np.array(\n            ref_frame_gt, dtype=np.int32\n        )  # fixed, uint8->int32, because layers.stack does not support uint8\n        ref_frame_num = ref_tmp_dic['ref_frame_num']\n        ###################\n        if self.rgb:\n            img1 = img1[:, :, [2, 1, 0]]\n            img2 = img2[:, :, [2, 1, 0]]\n            ref_img = ref_img[:, :, [2, 1, 0]]\n        obj_num = self.seq_dict[seqname][-1]\n        sample = {\n            'ref_img': ref_img,\n            'img1': img1,\n            'img2': img2,\n            'ref_scribble_label': ref_scribble_label,\n            'label1': label1,\n            'label2': label2,\n            'ref_frame_gt': ref_frame_gt"
        },
        {
            "comment": "This code defines a function that creates a sample containing images, labels, and metadata for the Ma-Net model. It also includes a separate function to update the reference frame and label based on user input. The sample is then transformed using a specified transform if one is provided.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":531-561",
            "content": "        }\n        if 'prev_round_label' in ref_tmp_dic:\n            prev_round_label = ref_tmp_dic['prev_round_label']\n            prev_round_label = prev_round_label.squeeze()\n            prev_round_label = prev_round_label.numpy()\n            sample = {\n                'ref_img': ref_img,\n                'img1': img1,\n                'img2': img2,\n                'ref_scribble_label': ref_scribble_label,\n                'label1': label1,\n                'label2': label2,\n                'ref_frame_gt': ref_frame_gt,\n                'prev_round_label': prev_round_label\n            }\n        sample['meta'] = {\n            'seq_name': seqname,\n            'frame_num': frame_num,\n            'obj_num': obj_num,\n            'ref_frame_num': ref_frame_num\n        }\n        if self.transform is not None:\n            sample = self.transform(sample)\n        return sample\n    def update_ref_frame_and_label(self,\n                                   round_scribble=None,\n                                   frame_num=None,\n                                   prev_round_label_dic=None):"
        },
        {
            "comment": "Updating the reference frame and scribbles for each sequence in the dataset. If no frame number is given, uses the first frame from annotated_frames list. Ensures frame number is 5 digits long. Retrieves the corresponding reference image path and ground truth mask path. Reads the reference image. Resizes the image based on its height and width. Generates scribble masks for each frame using the provided scribble. If no frame number given, selects the first frame's scribble mask.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":562-584",
            "content": "        ##########Update reference frame and scribbles\n        for seq in self.seqs:\n            scribble = round_scribble[seq]\n            if frame_num is None:\n                scr_frame = annotated_frames(scribble)[0]\n            else:\n                scr_frame = frame_num[seq]\n                scr_frame = int(scr_frame)\n            scr_f = str(scr_frame)\n            while len(scr_f) != 5:\n                scr_f = '0' + scr_f\n            ref_frame_path = os.path.join('JPEGImages/480p', seq,\n                                          scr_f + '.jpg')\n            #######################\n            ref_frame_gt = os.path.join('Annotations/480p/', seq,\n                                        scr_f + '.png')\n            #########################\n            ref_tmp = cv2.imread(os.path.join(self.db_root_dir, ref_frame_path))\n            h_, w_ = ref_tmp.shape[:2]\n            scribble_masks = scribbles2mask(scribble, (h_, w_))\n            if frame_num is None:\n                scribble_label = scribble_masks[scr_frame]"
        },
        {
            "comment": "The code initializes a dictionary for reference frames, storing information such as reference frame path, scribble label, and ground truth data. If there is a previous round's label dictionary, it also includes the previous round's label in the current dictionary entry. It uses the database root directory to find the Scribbles folder and selects a random JSON file for each sequence.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":585-609",
            "content": "            else:\n                scribble_label = scribble_masks[0]\n            self.ref_frame_dic[seq] = {\n                'ref_frame': ref_frame_path,\n                'scribble_label': scribble_label,\n                'ref_frame_gt': ref_frame_gt,\n                'ref_frame_num': scr_frame\n            }\n            if prev_round_label_dic is not None:\n                self.ref_frame_dic[seq] = {\n                    'ref_frame': ref_frame_path,\n                    'scribble_label': scribble_label,\n                    'ref_frame_gt': ref_frame_gt,\n                    'ref_frame_num': scr_frame,\n                    'prev_round_label': prev_round_label_dic[seq]\n                }\n    def init_ref_frame_dic(self):\n        self.ref_frame_dic = {}\n        scribbles_path = os.path.join(self.db_root_dir, 'Scribbles')\n        for seq in self.seqs:\n            selected_json = np.random.choice(\n                ['001.json', '002.json', '003.json'], 1)\n            selected_json = selected_json[0]\n            scribble = os.path.join(self.db_root_dir, 'Scribbles', seq,"
        },
        {
            "comment": "Reading JSON file for annotated frame, extracting frame path and loading reference image using OpenCV, determining the shape of the reference image, extracting the mask from the scribble, storing reference frame path in ref_frame_dic.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":610-632",
            "content": "                                    selected_json)\n            with open(scribble) as f:\n                scribble = json.load(f)\n                #    print(scribble)\n                scr_frame = annotated_frames(scribble)[0]\n                scr_f = str(scr_frame)\n                while len(scr_f) != 5:\n                    scr_f = '0' + scr_f\n                ref_frame_path = os.path.join('JPEGImages/480p', seq,\n                                              scr_f + '.jpg')\n                ref_tmp = cv2.imread(\n                    os.path.join(self.db_root_dir, ref_frame_path))\n                h_, w_ = ref_tmp.shape[:2]\n                scribble_masks = scribbles2mask(scribble, (h_, w_))\n                ########################\n                ref_frame_gt = os.path.join('Annotations/480p/', seq,\n                                            scr_f + '.png')\n                ########################\n                scribble_label = scribble_masks[scr_frame]\n                self.ref_frame_dic[seq] = {\n                    'ref_frame': ref_frame_path,"
        },
        {
            "comment": "The code reads a list of sequences from the sequence_list file and checks if it exists. If the file does not exist, it returns False; otherwise, it loads the sequence dictionary using json.load() and then proceeds to preprocess each sequence by reading object masks and finding the number of objects in the masks. The code stores this information in a dictionary format for later use.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":633-661",
            "content": "                    'scribble_label': scribble_label,\n                    'ref_frame_gt': ref_frame_gt,\n                    'ref_frame_num': scr_frame\n                }\n    ########################\n    def _check_preprocess(self):\n        _seq_list_file = self.seq_list_file\n        if not os.path.isfile(_seq_list_file):\n            return False\n        else:\n            self.seq_dict = json.load(open(self.seq_list_file, 'r'))\n            return True\n    def _preprocess(self):\n        self.seq_dict = {}\n        for seq in self.seqs:\n            # Read object masks and get number of objects\n            name_label = np.sort(\n                os.listdir(\n                    os.path.join(self.db_root_dir, 'Annotations/480p/', seq)))\n            label_path = os.path.join(self.db_root_dir, 'Annotations/480p/',\n                                      seq, name_label[0])\n            _mask = np.array(Image.open(label_path))\n            _mask_ids = np.unique(_mask)\n            n_obj = _mask_ids[-1]\n            self.seq_dict[seq] = list(range(1, n_obj + 1))"
        },
        {
            "comment": "The code writes a JSON file containing video sequences and their corresponding dictionaries, which will be used for the dataset. It iterates over each sequence, formats the output as JSON strings in the file, and finishes by printing \"Preprocessing finished\".",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/dataloaders/davis_2017_f.py\":663-671",
            "content": "        with open(self.seq_list_file, 'w') as outfile:\n            outfile.write('{{\\n\\t\"{:s}\": {:s}'.format(\n                self.seqs[0], json.dumps(self.seq_dict[self.seqs[0]])))\n            for ii in range(1, len(self.seqs)):\n                outfile.write(',\\n\\t\"{:s}\": {:s}'.format(\n                    self.seqs[ii], json.dumps(self.seq_dict[self.seqs[ii]])))\n            outfile.write('\\n}\\n')\n        print('Preprocessing finished')"
        }
    ]
}