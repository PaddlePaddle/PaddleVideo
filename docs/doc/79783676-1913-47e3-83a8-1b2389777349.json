{
    "summary": "The BBoxHeadAVA class generates classification targets, handles dropout, constructs labels, calculates recall/precision, computes losses, and uses a bbox_head for object detection. The code defines \"get_det_bboxes\" and \"multilabel_accuracy\" functions for detecting boxes and computing recall/precision, respectively. Loss is computed using binary cross-entropy with sigmoid activation.",
    "details": [
        {
            "comment": "This code defines a BBoxHeadAVA class, which is the simplest RoI (region of interest) head with two fully connected layers for classification and regression. The temporal_pool_type and spatial_pool_type parameters allow users to choose different pooling methods, while in_channels specifies the number of input channels for the network.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":0-31",
            "content": "# copyright (c) 2021 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport paddle \nimport paddle.nn as nn\nimport paddle.nn.functional as F\nimport numpy as np\nfrom .. import builder\nfrom ..registry import HEADS\n@HEADS.register()\nclass BBoxHeadAVA(nn.Layer):\n    \"\"\"Simplest RoI head, with only two fc layers for classification and\n    regression respectively.  \"\"\"\n    def __init__(\n            self,\n            temporal_pool_type='avg',\n            spatial_pool_type='max',\n            in_channels=2048,"
        },
        {
            "comment": "Class BBoxHeadAVA is being initialized with specified parameters including in_channels, num_classes, dropout_ratio, temporal and spatial pool types, topk values for pooling results, and multilabel flag. The code performs checks on the provided parameters to ensure their validity before assigning them to instance variables.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":32-60",
            "content": "            num_classes=81,# The first class is reserved, to classify bbox as pos / neg\n            dropout_ratio=0,\n            dropout_before_pool=True,\n            topk=(3, 5),\n            multilabel=True):\n        super(BBoxHeadAVA, self).__init__()\n        assert temporal_pool_type in ['max', 'avg']\n        assert spatial_pool_type in ['max', 'avg']\n        self.temporal_pool_type = temporal_pool_type\n        self.spatial_pool_type = spatial_pool_type\n        self.in_channels = in_channels\n        self.num_classes = num_classes\n        self.dropout_ratio = dropout_ratio\n        self.dropout_before_pool = dropout_before_pool\n        self.multilabel = multilabel\n        if topk is None:\n            self.topk = ()\n        elif isinstance(topk, int):\n            self.topk = (topk, )\n        elif isinstance(topk, tuple):\n            assert all([isinstance(k, int) for k in topk])\n            self.topk = topk\n        else:\n            raise TypeError('topk should be int or tuple[int], '\n                            f'but get {type(topk)}')"
        },
        {
            "comment": "This code initializes the BBoxHead model, which is a part of PaddleVideo. It sets up different layers such as temporal and spatial pooling layers, and dropout layer if needed. The code also specifies the parameters for weights and biases in these layers.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":61-82",
            "content": "        # Class 0 is ignored when calculaing multilabel accuracy,\n        # so topk cannot be equal to num_classes\n        assert all([k < num_classes for k in self.topk])\n        assert self.multilabel\n        in_channels = self.in_channels\n        if self.temporal_pool_type == 'avg':\n            self.temporal_pool = nn.AdaptiveAvgPool3D((1, None, None))\n        else:\n            self.temporal_pool = nn.AdaptiveMaxPool3D((1, None, None))\n        if self.spatial_pool_type == 'avg':\n            self.spatial_pool = nn.AdaptiveAvgPool3D((None, 1, 1))\n        else:\n            self.spatial_pool = nn.AdaptiveMaxPool3D((None, 1, 1))\n        if dropout_ratio > 0:\n            self.dropout = nn.Dropout(dropout_ratio)\n        weight_attr = paddle.framework.ParamAttr(name=\"weight\",\n                                                 initializer=paddle.nn.initializer.Normal(mean=0.0, std=0.01))\n        bias_attr = paddle.ParamAttr(name=\"bias\",\n                                     initializer=paddle.nn.initializer.Constant(value=0.0))"
        },
        {
            "comment": "This code defines a bbox_head with a linear layer (fc_cls) for classification and initializes debug images. It also performs forward pass by computing ROI features, applying dropout if enabled, and pooling the features.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":84-105",
            "content": "        self.fc_cls = nn.Linear(in_channels, num_classes, weight_attr=weight_attr, bias_attr=bias_attr)\n        self.debug_imgs = None\n    def forward(self, x,rois, rois_num):\n        roi = paddle.concat(rois)\n        roi_x1 = paddle.index_select(roi, index=paddle.to_tensor(0), axis=1)\n        roi_x2 = paddle.index_select(roi, index=paddle.to_tensor(2), axis=1)\n        roi_w = roi_x2 - roi_x1\n        roi_y1 = paddle.index_select(roi, index=paddle.to_tensor(1), axis=1)\n        roi_y2 = paddle.index_select(roi, index=paddle.to_tensor(3), axis=1)\n        roi_h = roi_y2 - roi_y1\n        roi_area = paddle.multiply(roi_w, roi_h)\n        A = roi_area\n        A1 = paddle.full(A.shape, 1, dtype='int32')\n        A2 = paddle.where(A == 0, paddle.zeros_like(A1), A1)\n        AE = paddle.expand(A2, [A.shape[0], x.shape[1]])\n        rois_num = paddle.to_tensor(rois_num, dtype='int32')\n        if self.dropout_before_pool and self.dropout_ratio > 0 :\n            x = self.dropout(x)\n        x = self.temporal_pool(x)\n        x = self.spatial_pool(x)"
        },
        {
            "comment": "Code snippet is part of a Bounding Box (BBox) head in PaddleVideo, responsible for generating classification targets and handling dropout before pooling. The code also includes functions to generate bbox targets based on positive and negative proposals, ground truth labels, and a positional weight.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":106-125",
            "content": "        if not self.dropout_before_pool and self.dropout_ratio > 0 :\n            x = self.dropout(x)\n        x = paddle.reshape(x, [x.shape[0], -1])\n        x = paddle.multiply(x, paddle.cast(AE,\"float32\"))\n        cls_score = self.fc_cls(x)\n        # We do not predict bbox, so return None\n        return cls_score, None\n    def get_targets(self, sampling_results, gt_bboxes, gt_labels, pos_weight):\n        pos_proposals = [res.pos_bboxes for res in sampling_results]\n        neg_proposals = [res.neg_bboxes for res in sampling_results]\n        pos_gt_labels = [res.pos_gt_labels for res in sampling_results]\n        cls_reg_targets = self.bbox_target(pos_proposals, neg_proposals,\n                                      pos_gt_labels, pos_weight)\n        return cls_reg_targets\n    def bbox_target(self, pos_bboxes_list, neg_bboxes_list, gt_labels, pos_weight):\n        \"\"\"Generate classification targets for bboxes.  \"\"\"\n        labels, label_weights = [], []\n        pos_weight = 1.0 if pos_weight <= 0 else pos_weight"
        },
        {
            "comment": "This code snippet is part of the PaddleVideo library's bbox_head module. It asserts that three lists have equal lengths and then iterates over each list, counting positive (pos) and negative (neg) bounding boxes. It constructs a label by concatenating ground truth labels with zero-filled negatives. The function returns the generated labels for training. The recall_prec function compares prediction vectors to target vectors, creating a correct vector before filling it with 1s or 0s based on their logical AND operation.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":127-151",
            "content": "        assert len(pos_bboxes_list) == len(neg_bboxes_list) == len(gt_labels)\n        length = len(pos_bboxes_list)\n        for i in range(length):\n            pos_bboxes = pos_bboxes_list[i]\n            neg_bboxes = neg_bboxes_list[i]\n            gt_label = gt_labels[i]\n            num_pos = pos_bboxes.shape[0]\n            if neg_bboxes is not None:\n                num_neg = neg_bboxes.shape[0]\n            else:\n                num_neg = 0\n            num_samples = num_pos + num_neg\n            neg_label = paddle.zeros([num_neg, gt_label.shape[1]])\n            label = paddle.concat([gt_label,neg_label])\n            labels.append(label)\n        labels = paddle.concat(labels, 0)\n        return labels\n    def recall_prec(self, pred_vec, target_vec):\n        correct = paddle.to_tensor(np.logical_and(pred_vec.numpy(), target_vec.numpy()))\n        correct = paddle.where(correct, \n                                    paddle.full(correct.shape,1,dtype='int32'),\n                                    paddle.full(correct.shape,0,dtype='int32'))"
        },
        {
            "comment": "This code calculates recall and precision for multi-label classification tasks. It first computes recall and precision for each sample, then calculates the mean recall and precision across all samples. The function uses threshold values of 0.5 and 1e-6 for target and prediction vectors to ensure numerical stability.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":152-170",
            "content": "        recall_correct = paddle.cast(paddle.sum(correct, axis=1), 'float32')\n        target_vec = paddle.where(target_vec, \n                                    paddle.full(target_vec.shape,1,dtype='int32'),\n                                    paddle.full(target_vec.shape,0,dtype='int32'))\n        recall_target = paddle.cast(paddle.sum(target_vec, axis=1),'float32')\n        recall = recall_correct / recall_target\n        pred_vec = paddle.where(pred_vec, \n                                    paddle.full(pred_vec.shape,1,dtype='int32'),\n                                    paddle.full(pred_vec.shape,0,dtype='int32'))\n        prec_target = paddle.cast(paddle.sum(pred_vec, axis=1) + 1e-6, 'float32')\n        prec = recall_correct / prec_target\n        recall_mean = paddle.mean(recall)\n        prec_mean = paddle.mean(prec)\n        return recall_mean, prec_mean\n    def multilabel_accuracy(self, pred, target, thr=0.5):\n        pred = paddle.nn.functional.sigmoid(pred)\n        pred_vec = pred > thr\n        target_vec = target > 0.5"
        },
        {
            "comment": "Code creates a bbox_head for object detection. It computes recall and precision given predicted and target vectors, and returns the results. In loss function, it only considers cls_score if available and computes losses based on pos_inds (positive indices) and labels.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":171-194",
            "content": "        recall_thr, prec_thr = self.recall_prec(pred_vec, target_vec)\n        recalls, precs = [], []\n        for k in self.topk:\n            _, pred_label = paddle.topk(pred, k, 1, True, True)\n            pred_vec = paddle.full(pred.shape,0,dtype='bool')\n            num_sample = pred.shape[0]\n            for i in range(num_sample):\n                pred_vec[i, pred_label[i].numpy()] = 1  \n            recall_k, prec_k = self.recall_prec(pred_vec, target_vec)\n            recalls.append(recall_k)\n            precs.append(prec_k)\n        return recall_thr, prec_thr, recalls, precs\n    def loss(self,\n             cls_score,\n             labels):\n        losses = dict()\n        if cls_score is not None:\n            # Only use the cls_score\n            labels = labels[:, 1:]\n            pos_inds_bool = paddle.sum(labels, axis=-1) > 0\n            pos_inds = paddle.where(paddle.sum(labels, axis=-1) > 0,\n                                    paddle.full([labels.shape[0]],1,dtype='int32'),\n                                    paddle.full([labels.shape[0]],0,dtype='int32'))"
        },
        {
            "comment": "This code defines two functions: \"get_det_bboxes\" and \"multilabel_accuracy\". The \"get_det_bboxes\" function takes ROIs, cls_score, img_shape, flip, and crop_quadruple as inputs to calculate detection boxes for each bounding box. The \"multilabel_accuracy\" function calculates recall and precision for different thresholds and top-k values from the given cls_score and labels arrays. The code also computes loss using binary cross-entropy with logits and adds it to the losses dictionary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":195-217",
            "content": "            pos_inds = paddle.nonzero(pos_inds, as_tuple=False)\n            cls_score = paddle.index_select(cls_score, pos_inds, axis=0)\n            cls_score = cls_score[:, 1:] \n            labels = paddle.index_select(labels, pos_inds, axis=0)\n            bce_loss = F.binary_cross_entropy_with_logits\n            loss = bce_loss(cls_score, labels, reduction='none')\n            losses['loss'] = paddle.mean(loss)\n            recall_thr, prec_thr, recall_k, prec_k = self.multilabel_accuracy(\n                cls_score, labels, thr=0.5)\n            losses['recall@thr=0.5'] = recall_thr\n            losses['prec@thr=0.5'] = prec_thr\n            for i, k in enumerate(self.topk):\n                losses[f'recall@top{k}'] = recall_k[i]\n                losses[f'prec@top{k}'] = prec_k[i]\n        return losses\n    def get_det_bboxes(self,\n                       rois,\n                       cls_score,\n                       img_shape,\n                       flip=False,\n                       crop_quadruple=None,\n                       cfg=None):"
        },
        {
            "comment": "The code checks if cls_score is a list, calculates the mean of its elements if it's a list, asserts that self.multilabel is True, applies sigmoid activation to cls_score, and assigns resulting scores to variable 'scores'. It also assigns rois to bboxes and returns both bboxes and scores.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/bbox_head.py\":218-224",
            "content": "        if isinstance(cls_score, list):\n            cls_score = sum(cls_score) / float(len(cls_score))\n        assert self.multilabel\n        m = paddle.nn.Sigmoid()\n        scores = m(cls_score)\n        bboxes = rois\n        return bboxes, scores"
        }
    ]
}