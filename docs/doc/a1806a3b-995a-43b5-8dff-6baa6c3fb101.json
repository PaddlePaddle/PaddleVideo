{
    "summary": "This code calculates delta between bounding boxes, adjusts using weighted averages, provides functions for filtering, computing overlaps, generating anchor points, decoding YOLO boxes, and calculating IoU. It transforms coordinates, computes deltas, stacks results, calculates dimensions and center of rotated boxes, converts rectangles to polygons, and finds the best begin point for a coordinate.",
    "details": [
        {
            "comment": "This code calculates the delta between source and target bounding boxes. It first computes the width and height of both source and target boxes, then their center coordinates. The variables are initialized and calculated for further usage in other functions related to bounding box transformation.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":0-29",
            "content": "#   Copyright (c) 2021 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport math\nimport paddle\nimport paddle.nn.functional as F\nimport math\nimport numpy as np\ndef bbox2delta(src_boxes, tgt_boxes, weights):\n    src_w = src_boxes[:, 2] - src_boxes[:, 0]\n    src_h = src_boxes[:, 3] - src_boxes[:, 1]\n    src_ctr_x = src_boxes[:, 0] + 0.5 * src_w\n    src_ctr_y = src_boxes[:, 1] + 0.5 * src_h\n    tgt_w = tgt_boxes[:, 2] - tgt_boxes[:, 0]\n    tgt_h = tgt_boxes[:, 3] - tgt_boxes[:, 1]\n    tgt_ctr_x = tgt_boxes[:, 0] + 0.5 * tgt_w"
        },
        {
            "comment": "This code calculates the differentials (deltas) between target and source bounding boxes, then converts those deltas back into new bounding box coordinates. The conversion is done with weighted averages for x, y, width, and height adjustments, ensuring values are clipped to avoid large inputs for paddle.exp().",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":30-62",
            "content": "    tgt_ctr_y = tgt_boxes[:, 1] + 0.5 * tgt_h\n    wx, wy, ww, wh = weights\n    dx = wx * (tgt_ctr_x - src_ctr_x) / src_w\n    dy = wy * (tgt_ctr_y - src_ctr_y) / src_h\n    dw = ww * paddle.log(tgt_w / src_w)\n    dh = wh * paddle.log(tgt_h / src_h)\n    deltas = paddle.stack((dx, dy, dw, dh), axis=1)\n    return deltas\ndef delta2bbox(deltas, boxes, weights):\n    clip_scale = math.log(1000.0 / 16)\n    widths = boxes[:, 2] - boxes[:, 0]\n    heights = boxes[:, 3] - boxes[:, 1]\n    ctr_x = boxes[:, 0] + 0.5 * widths\n    ctr_y = boxes[:, 1] + 0.5 * heights\n    wx, wy, ww, wh = weights\n    dx = deltas[:, 0::4] / wx\n    dy = deltas[:, 1::4] / wy\n    dw = deltas[:, 2::4] / ww\n    dh = deltas[:, 3::4] / wh\n    # Prevent sending too large values into paddle.exp()\n    dw = paddle.clip(dw, max=clip_scale)\n    dh = paddle.clip(dh, max=clip_scale)\n    pred_ctr_x = dx * widths.unsqueeze(1) + ctr_x.unsqueeze(1)\n    pred_ctr_y = dy * heights.unsqueeze(1) + ctr_y.unsqueeze(1)\n    pred_w = paddle.exp(dw) * widths.unsqueeze(1)\n    pred_h = paddle.exp(dh) * heights.unsqueeze(1)"
        },
        {
            "comment": "The code contains three functions: `expand_bbox`, `clip_bbox`, and `nonempty_bbox`. `expand_bbox` takes bbox coordinates, scales them by a factor, and returns the expanded bboxes. `clip_bbox` clips the bbox coordinates to the image shape boundaries. `nonempty_bbox` filters out empty bounding boxes based on a minimum size threshold or returns a mask if return_mask is True.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":64-101",
            "content": "    pred_boxes = []\n    pred_boxes.append(pred_ctr_x - 0.5 * pred_w)\n    pred_boxes.append(pred_ctr_y - 0.5 * pred_h)\n    pred_boxes.append(pred_ctr_x + 0.5 * pred_w)\n    pred_boxes.append(pred_ctr_y + 0.5 * pred_h)\n    pred_boxes = paddle.stack(pred_boxes, axis=-1)\n    return pred_boxes\ndef expand_bbox(bboxes, scale):\n    w_half = (bboxes[:, 2] - bboxes[:, 0]) * .5\n    h_half = (bboxes[:, 3] - bboxes[:, 1]) * .5\n    x_c = (bboxes[:, 2] + bboxes[:, 0]) * .5\n    y_c = (bboxes[:, 3] + bboxes[:, 1]) * .5\n    w_half *= scale\n    h_half *= scale\n    bboxes_exp = np.zeros(bboxes.shape, dtype=np.float32)\n    bboxes_exp[:, 0] = x_c - w_half\n    bboxes_exp[:, 2] = x_c + w_half\n    bboxes_exp[:, 1] = y_c - h_half\n    bboxes_exp[:, 3] = y_c + h_half\n    return bboxes_exp\ndef clip_bbox(boxes, im_shape):\n    h, w = im_shape[0], im_shape[1]\n    x1 = boxes[:, 0].clip(0, w)\n    y1 = boxes[:, 1].clip(0, h)\n    x2 = boxes[:, 2].clip(0, w)\n    y2 = boxes[:, 3].clip(0, h)\n    return paddle.stack([x1, y1, x2, y2], axis=1)\ndef nonempty_bbox(boxes, min_size=0, return_mask=False):"
        },
        {
            "comment": "The function `bbox_utils.py` at line 102-138 contains two functions: 'filter_boxes_by_size' and 'bbox_overlaps'.\n'filter_boxes_by_size' filters the bounding boxes by size, only keeping those whose width or height exceeds a specified minimum size. If a mask is also desired, it returns one of true values for the selected bounding boxes.\n'bbox_overlaps' calculates overlaps between two sets of bounding boxes and returns them as a tensor with shape [M, N]. This function uses the areas of the bounding boxes to compute the intersections and unions, applying clipping for valid computations and handling non-intersecting boxes.\n\nExplanation: The code contains functions that filter bounding boxes by size and calculate overlaps between them. The 'filter_boxes_by_size' function filters bounding boxes based on their width or height, while the 'bbox_overlaps' function calculates overlap between two sets of bounding boxes and returns a tensor with shape [M, N].",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":102-138",
            "content": "    w = boxes[:, 2] - boxes[:, 0]\n    h = boxes[:, 3] - boxes[:, 1]\n    mask = paddle.logical_and(w > min_size, w > min_size)\n    if return_mask:\n        return mask\n    keep = paddle.nonzero(mask).flatten()\n    return keep\ndef bbox_area(boxes):\n    return (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])\ndef bbox_overlaps(boxes1, boxes2):\n    \"\"\"\n    Calculate overlaps between boxes1 and boxes2\n    Args:\n        boxes1 (Tensor): boxes with shape [M, 4]\n        boxes2 (Tensor): boxes with shape [N, 4]\n    Return:\n        overlaps (Tensor): overlaps between boxes1 and boxes2 with shape [M, N]\n    \"\"\"\n    area1 = bbox_area(boxes1)\n    area2 = bbox_area(boxes2)\n    xy_max = paddle.minimum(\n        paddle.unsqueeze(boxes1, 1)[:, :, 2:], boxes2[:, 2:])\n    xy_min = paddle.maximum(\n        paddle.unsqueeze(boxes1, 1)[:, :, :2], boxes2[:, :2])\n    width_height = xy_max - xy_min\n    width_height = width_height.clip(min=0)\n    inter = width_height.prod(axis=2)\n    overlaps = paddle.where(inter > 0, inter /\n                            (paddle.unsqueeze(area1, 1) + area2 - inter),"
        },
        {
            "comment": "The code defines functions for converting box coordinates, generating a grid of anchor points, and decoding YOLO bounding boxes. The \"xywh2xyxy\" function transforms (x, y, w, h) to (x1, y1, x2, y2). The \"make_grid\" function generates a grid of coordinates for downsampled images. The \"decode_yolo\" function decodes YOLO bounding boxes using anchor points and downsample ratios.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":139-175",
            "content": "                            paddle.zeros_like(inter))\n    return overlaps\ndef xywh2xyxy(box):\n    x, y, w, h = box\n    x1 = x - w * 0.5\n    y1 = y - h * 0.5\n    x2 = x + w * 0.5\n    y2 = y + h * 0.5\n    return [x1, y1, x2, y2]\ndef make_grid(h, w, dtype):\n    yv, xv = paddle.meshgrid([paddle.arange(h), paddle.arange(w)])\n    return paddle.stack((xv, yv), 2).cast(dtype=dtype)\ndef decode_yolo(box, anchor, downsample_ratio):\n    \"\"\"decode yolo box\n    Args:\n        box (list): [x, y, w, h], all have the shape [b, na, h, w, 1]\n        anchor (list): anchor with the shape [na, 2]\n        downsample_ratio (int): downsample ratio, default 32\n        scale (float): scale, default 1.\n    Return:\n        box (list): decoded box, [x, y, w, h], all have the shape [b, na, h, w, 1]\n    \"\"\"\n    x, y, w, h = box\n    na, grid_h, grid_w = x.shape[1:4]\n    grid = make_grid(grid_h, grid_w, x.dtype).reshape((1, 1, grid_h, grid_w, 2))\n    x1 = (x + grid[:, :, :, :, 0:1]) / grid_w\n    y1 = (y + grid[:, :, :, :, 1:2]) / grid_h\n    anchor = paddle.to_tensor(anchor)"
        },
        {
            "comment": "Code defines anchor and calculates width (w1) and height (h1) for bounding boxes based on exponential values of w and h, downsample ratio, and grid dimensions. It also includes a function iou_similarity that calculates the intersection over union (IoU) between two sets of bounding boxes.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":176-203",
            "content": "    anchor = paddle.cast(anchor, x.dtype)\n    anchor = anchor.reshape((1, na, 1, 1, 2))\n    w1 = paddle.exp(w) * anchor[:, :, :, :, 0:1] / (downsample_ratio * grid_w)\n    h1 = paddle.exp(h) * anchor[:, :, :, :, 1:2] / (downsample_ratio * grid_h)\n    return [x1, y1, w1, h1]\ndef iou_similarity(box1, box2, eps=1e-9):\n    \"\"\"Calculate iou of box1 and box2\n    Args:\n        box1 (Tensor): box with the shape [N, M1, 4]\n        box2 (Tensor): box with the shape [N, M2, 4]\n    Return:\n        iou (Tensor): iou between box1 and box2 with the shape [N, M1, M2]\n    \"\"\"\n    box1 = box1.unsqueeze(2)  # [N, M1, 4] -> [N, M1, 1, 4]\n    box2 = box2.unsqueeze(1)  # [N, M2, 4] -> [N, 1, M2, 4]\n    px1y1, px2y2 = box1[:, :, :, 0:2], box1[:, :, :, 2:4]\n    gx1y1, gx2y2 = box2[:, :, :, 0:2], box2[:, :, :, 2:4]\n    x1y1 = paddle.maximum(px1y1, gx1y1)\n    x2y2 = paddle.minimum(px2y2, gx2y2)\n    overlap = (x2y2 - x1y1).clip(0).prod(-1)\n    area1 = (px2y2 - px1y1).clip(0).prod(-1)\n    area2 = (gx2y2 - gx1y1).clip(0).prod(-1)\n    union = area1 + area2 - overlap + eps"
        },
        {
            "comment": "This function calculates the intersection over union (IoU) between two bounding boxes, box1 and box2. It supports various IoU metrics such as Giou, Diou, or Ciou. The calculated IoU is returned as a tensor with the same shape as box1 and box2. This function is used in object detection tasks to measure the overlap between predicted and ground truth bounding boxes.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":204-236",
            "content": "    return overlap / union\ndef bbox_iou(box1, box2, giou=False, diou=False, ciou=False, eps=1e-9):\n    \"\"\"calculate the iou of box1 and box2\n    Args:\n        box1 (list): [x, y, w, h], all have the shape [b, na, h, w, 1]\n        box2 (list): [x, y, w, h], all have the shape [b, na, h, w, 1]\n        giou (bool): whether use giou or not, default False\n        diou (bool): whether use diou or not, default False\n        ciou (bool): whether use ciou or not, default False\n        eps (float): epsilon to avoid divide by zero\n    Return:\n        iou (Tensor): iou of box1 and box1, with the shape [b, na, h, w, 1]\n    \"\"\"\n    px1, py1, px2, py2 = box1\n    gx1, gy1, gx2, gy2 = box2\n    x1 = paddle.maximum(px1, gx1)\n    y1 = paddle.maximum(py1, gy1)\n    x2 = paddle.minimum(px2, gx2)\n    y2 = paddle.minimum(py2, gy2)\n    overlap = ((x2 - x1).clip(0)) * ((y2 - y1).clip(0))\n    area1 = (px2 - px1) * (py2 - py1)\n    area1 = area1.clip(0)\n    area2 = (gx2 - gx1) * (gy2 - gy1)\n    area2 = area2.clip(0)\n    union = area1 + area2 - overlap + eps"
        },
        {
            "comment": "This code calculates the Intersection over Union (IoU) between two bounding boxes and applies various forms of IoU calculations depending on the input parameters. It first checks if giou, ciou, or diou is True and then proceeds with the corresponding calculation based on the convex area, diagonal distance, or aspect ratio difference between the bounding boxes. The rect2rbox function transforms a set of bounding boxes from (xmin, ymin, xmax, ymax) format to (cx, cy, w, h) format where cx and cy are center coordinates and w and h are width and height respectively.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":237-267",
            "content": "    iou = overlap / union\n    if giou or ciou or diou:\n        # convex w, h\n        cw = paddle.maximum(px2, gx2) - paddle.minimum(px1, gx1)\n        ch = paddle.maximum(py2, gy2) - paddle.minimum(py1, gy1)\n        if giou:\n            c_area = cw * ch + eps\n            return iou - (c_area - union) / c_area\n        else:\n            # convex diagonal squared\n            c2 = cw**2 + ch**2 + eps\n            # center distance\n            rho2 = ((px1 + px2 - gx1 - gx2)**2 + (py1 + py2 - gy1 - gy2)**2) / 4\n            if diou:\n                return iou - rho2 / c2\n            else:\n                w1, h1 = px2 - px1, py2 - py1 + eps\n                w2, h2 = gx2 - gx1, gy2 - gy1 + eps\n                delta = paddle.atan(w1 / h1) - paddle.atan(w2 / h2)\n                v = (4 / math.pi**2) * paddle.pow(delta, 2)\n                alpha = v / (1 + eps - iou + v)\n                alpha.stop_gradient = True\n                return iou - (rho2 / c2 + v * alpha)\n    else:\n        return iou\ndef rect2rbox(bboxes):\n    \"\"\"\n    :param bboxes: shape (n, 4) (xmin, ymin, xmax, ymax)"
        },
        {
            "comment": "This function converts bounding box coordinates and dimensions to rotation-aligned bounding boxes by calculating the center, edge lengths, and angle. It returns a new tensor with reshaped and rotated bounding boxes.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":268-303",
            "content": "    :return: dbboxes: shape (n, 5) (x_ctr, y_ctr, w, h, angle)\n    \"\"\"\n    bboxes = bboxes.reshape(-1, 4)\n    num_boxes = bboxes.shape[0]\n    x_ctr = (bboxes[:, 2] + bboxes[:, 0]) / 2.0\n    y_ctr = (bboxes[:, 3] + bboxes[:, 1]) / 2.0\n    edges1 = np.abs(bboxes[:, 2] - bboxes[:, 0])\n    edges2 = np.abs(bboxes[:, 3] - bboxes[:, 1])\n    angles = np.zeros([num_boxes], dtype=bboxes.dtype)\n    inds = edges1 < edges2\n    rboxes = np.stack((x_ctr, y_ctr, edges1, edges2, angles), axis=1)\n    rboxes[inds, 2] = edges2[inds]\n    rboxes[inds, 3] = edges1[inds]\n    rboxes[inds, 4] = np.pi / 2.0\n    return rboxes\ndef delta2rbox(Rrois,\n               deltas,\n               means=[0, 0, 0, 0, 0],\n               stds=[1, 1, 1, 1, 1],\n               wh_ratio_clip=1e-6):\n    \"\"\"\n    :param Rrois: (cx, cy, w, h, theta)\n    :param deltas: (dx, dy, dw, dh, dtheta)\n    :param means:\n    :param stds:\n    :param wh_ratio_clip:\n    :return:\n    \"\"\"\n    means = paddle.to_tensor(means)\n    stds = paddle.to_tensor(stds)\n    deltas = paddle.reshape(deltas, [-1, deltas.shape[-1]])"
        },
        {
            "comment": "This code computes the bounding box regression results for each proposed bounding box. It calculates the deltas and applies clipping to ensure they stay within reasonable bounds, then transforms these deltas into actual bounding box coordinates. The resulting bounding boxes are stacked in a tensor and returned as output.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":304-338",
            "content": "    denorm_deltas = deltas * stds + means\n    dx = denorm_deltas[:, 0]\n    dy = denorm_deltas[:, 1]\n    dw = denorm_deltas[:, 2]\n    dh = denorm_deltas[:, 3]\n    dangle = denorm_deltas[:, 4]\n    max_ratio = np.abs(np.log(wh_ratio_clip))\n    dw = paddle.clip(dw, min=-max_ratio, max=max_ratio)\n    dh = paddle.clip(dh, min=-max_ratio, max=max_ratio)\n    Rroi_x = Rrois[:, 0]\n    Rroi_y = Rrois[:, 1]\n    Rroi_w = Rrois[:, 2]\n    Rroi_h = Rrois[:, 3]\n    Rroi_angle = Rrois[:, 4]\n    gx = dx * Rroi_w * paddle.cos(Rroi_angle) - dy * Rroi_h * paddle.sin(\n        Rroi_angle) + Rroi_x\n    gy = dx * Rroi_w * paddle.sin(Rroi_angle) + dy * Rroi_h * paddle.cos(\n        Rroi_angle) + Rroi_y\n    gw = Rroi_w * dw.exp()\n    gh = Rroi_h * dh.exp()\n    ga = np.pi * dangle + Rroi_angle\n    ga = (ga + np.pi / 4) % np.pi - np.pi / 4\n    ga = paddle.to_tensor(ga)\n    gw = paddle.to_tensor(gw, dtype='float32')\n    gh = paddle.to_tensor(gh, dtype='float32')\n    bboxes = paddle.stack([gx, gy, gw, gh, ga], axis=-1)\n    return bboxes\ndef rbox2delta(proposals, gt, means=[0, 0, 0, 0, 0], stds=[1, 1, 1, 1, 1]):"
        },
        {
            "comment": "This code calculates the delta values between ground truth and proposals for bounding boxes, taking into account their widths, heights, angles, and applying normalization based on means and stds. It also ensures that angle differences are within 0 to 2\u03c0 range before scaling by the inverse of PI.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":339-377",
            "content": "    \"\"\"\n    Args:\n        proposals:\n        gt:\n        means: 1x5\n        stds: 1x5\n    Returns:\n    \"\"\"\n    proposals = proposals.astype(np.float64)\n    PI = np.pi\n    gt_widths = gt[..., 2]\n    gt_heights = gt[..., 3]\n    gt_angle = gt[..., 4]\n    proposals_widths = proposals[..., 2]\n    proposals_heights = proposals[..., 3]\n    proposals_angle = proposals[..., 4]\n    coord = gt[..., 0:2] - proposals[..., 0:2]\n    dx = (np.cos(proposals[..., 4]) * coord[..., 0] + np.sin(proposals[..., 4])\n          * coord[..., 1]) / proposals_widths\n    dy = (-np.sin(proposals[..., 4]) * coord[..., 0] + np.cos(proposals[..., 4])\n          * coord[..., 1]) / proposals_heights\n    dw = np.log(gt_widths / proposals_widths)\n    dh = np.log(gt_heights / proposals_heights)\n    da = (gt_angle - proposals_angle)\n    da = (da + PI / 4) % PI - PI / 4\n    da /= PI\n    deltas = np.stack([dx, dy, dw, dh, da], axis=-1)\n    means = np.array(means, dtype=deltas.dtype)\n    stds = np.array(stds, dtype=deltas.dtype)\n    deltas = (deltas - means) / stds"
        },
        {
            "comment": "Function `bbox_decode` takes bbox predictions, anchors and means/stds as inputs. It returns decoded bounding boxes. It first converts the means and stds to tensors. Then for each image, it computes the bbox delta from the bbox predictions. It then transforms these deltas to actual bounding box coordinates using `delta2rbox` function. Finally, it reshapes the obtained bounding boxes and stores them in a list. The function returns a stack of all the bounding boxes for each image.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":378-416",
            "content": "    deltas = deltas.astype(np.float32)\n    return deltas\ndef bbox_decode(bbox_preds,\n                anchors,\n                means=[0, 0, 0, 0, 0],\n                stds=[1, 1, 1, 1, 1]):\n    \"\"\"decode bbox from deltas\n    Args:\n        bbox_preds: [N,H,W,5]\n        anchors: [H*W,5]\n    return:\n        bboxes: [N,H,W,5]\n    \"\"\"\n    means = paddle.to_tensor(means)\n    stds = paddle.to_tensor(stds)\n    num_imgs, H, W, _ = bbox_preds.shape\n    bboxes_list = []\n    for img_id in range(num_imgs):\n        bbox_pred = bbox_preds[img_id]\n        # bbox_pred.shape=[5,H,W]\n        bbox_delta = bbox_pred\n        anchors = paddle.to_tensor(anchors)\n        bboxes = delta2rbox(\n            anchors, bbox_delta, means, stds, wh_ratio_clip=1e-6)\n        bboxes = paddle.reshape(bboxes, [H, W, 5])\n        bboxes_list.append(bboxes)\n    return paddle.stack(bboxes_list, axis=0)\ndef poly_to_rbox(polys):\n    \"\"\"\n    poly:[x0,y0,x1,y1,x2,y2,x3,y3]\n    to\n    rotated_boxes:[x_ctr,y_ctr,w,h,angle]\n    \"\"\"\n    rotated_boxes = []\n    for poly in polys:"
        },
        {
            "comment": "This code calculates the width, height, and angle of a rotated bounding box based on its eight points. It first converts the polyline to a numpy array, then calculates the lengths of two edges. The function then determines the maximum edge length as the width and the minimum edge length as the height. Based on these values, it computes the rotation angle using arctan2. Finally, it normalizes the rotation angle within a specified range using the norm_angle function. It also calculates the x and y coordinates of the box's center.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":417-446",
            "content": "        poly = np.array(poly[:8], dtype=np.float32)\n        pt1 = (poly[0], poly[1])\n        pt2 = (poly[2], poly[3])\n        pt3 = (poly[4], poly[5])\n        pt4 = (poly[6], poly[7])\n        edge1 = np.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[\n            1]) * (pt1[1] - pt2[1]))\n        edge2 = np.sqrt((pt2[0] - pt3[0]) * (pt2[0] - pt3[0]) + (pt2[1] - pt3[\n            1]) * (pt2[1] - pt3[1]))\n        width = max(edge1, edge2)\n        height = min(edge1, edge2)\n        rbox_angle = 0\n        if edge1 > edge2:\n            rbox_angle = np.arctan2(\n                np.float(pt2[1] - pt1[1]), np.float(pt2[0] - pt1[0]))\n        elif edge2 >= edge1:\n            rbox_angle = np.arctan2(\n                np.float(pt4[1] - pt1[1]), np.float(pt4[0] - pt1[0]))\n        def norm_angle(angle, range=[-np.pi / 4, np.pi]):\n            return (angle - range[0]) % range[1] + range[0]\n        rbox_angle = norm_angle(rbox_angle)\n        x_ctr = np.float(pt1[0] + pt3[0]) / 2\n        y_ctr = np.float(pt1[1] + pt3[1]) / 2"
        },
        {
            "comment": "This function `get_best_begin_point_single` takes a coordinate as input and calculates the minimum x and y coordinates (xmin, ymin) and maximum x and y coordinates (xmax, ymax). It then defines four different combinations of the four points in the coordinate and compares these combinations to the destination coordinate (dst_coordinate) by calculating the distance using `cal_line_length` function. The combination with the smallest distance is returned as the best begin point. The code also includes a force variable to handle potential edge cases where no valid begin point can be found.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":447-474",
            "content": "        rotated_box = np.array([x_ctr, y_ctr, width, height, rbox_angle])\n        rotated_boxes.append(rotated_box)\n    ret_rotated_boxes = np.array(rotated_boxes)\n    assert ret_rotated_boxes.shape[1] == 5\n    return ret_rotated_boxes\ndef cal_line_length(point1, point2):\n    import math\n    return math.sqrt(\n        math.pow(point1[0] - point2[0], 2) + math.pow(point1[1] - point2[1], 2))\ndef get_best_begin_point_single(coordinate):\n    x1, y1, x2, y2, x3, y3, x4, y4 = coordinate\n    xmin = min(x1, x2, x3, x4)\n    ymin = min(y1, y2, y3, y4)\n    xmax = max(x1, x2, x3, x4)\n    ymax = max(y1, y2, y3, y4)\n    combinate = [[[x1, y1], [x2, y2], [x3, y3], [x4, y4]],\n                 [[x4, y4], [x1, y1], [x2, y2], [x3, y3]],\n                 [[x3, y3], [x4, y4], [x1, y1], [x2, y2]],\n                 [[x2, y2], [x3, y3], [x4, y4], [x1, y1]]]\n    dst_coordinate = [[xmin, ymin], [xmax, ymin], [xmax, ymax], [xmin, ymax]]\n    force = 100000000.0\n    force_flag = 0\n    for i in range(4):\n        temp_force = cal_line_length(combinate[i][0], dst_coordinate[0]) \\"
        },
        {
            "comment": "This function `rbox2poly_single` takes a rectangle represented by its center coordinates, width, height, and angle, and converts it to a polygon representation. It first calculates the top-left and bottom-right coordinates of the rectangle. Then, it creates a 2x4 matrix representing the four corners of the rectangle. The function applies a rotation matrix to transform the rectangle into a rotated coordinate system. Finally, it shifts the transformed coordinates by the center coordinates and returns the polygon representation as an array.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":475-502",
            "content": "                     + cal_line_length(combinate[i][1], dst_coordinate[1]) \\\n                     + cal_line_length(combinate[i][2], dst_coordinate[2]) \\\n                     + cal_line_length(combinate[i][3], dst_coordinate[3])\n        if temp_force < force:\n            force = temp_force\n            force_flag = i\n    if force_flag != 0:\n        pass\n    return np.array(combinate[force_flag]).reshape(8)\ndef rbox2poly_single(rrect):\n    \"\"\"\n    rrect:[x_ctr,y_ctr,w,h,angle]\n    to\n    poly:[x0,y0,x1,y1,x2,y2,x3,y3]\n    \"\"\"\n    x_ctr, y_ctr, width, height, angle = rrect[:5]\n    tl_x, tl_y, br_x, br_y = -width / 2, -height / 2, width / 2, height / 2\n    # rect 2x4\n    rect = np.array([[tl_x, br_x, br_x, tl_x], [tl_y, tl_y, br_y, br_y]])\n    R = np.array([[np.cos(angle), -np.sin(angle)],\n                  [np.sin(angle), np.cos(angle)]])\n    # poly\n    poly = R.dot(rect)\n    x0, x1, x2, x3 = poly[0, :4] + x_ctr\n    y0, y1, y2, y3 = poly[1, :4] + y_ctr\n    poly = np.array([x0, y0, x1, y1, x2, y2, x3, y3], dtype=np.float32)"
        },
        {
            "comment": "This function `rbox2poly` converts a list of rotation rectangles (rrects) into polygons (polys). It first calculates the top-left and bottom-right coordinates of each rrect. Then, it rotates the rectangle using the given angle. The function adjusts the poly points by adding the x_ctr and y_ctr values to obtain the final poly. It applies a single best begin point adjustment (`get_best_begin_point_single`) and adds the poly to the list of polys. Finally, it returns the array of polygons.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/bbox_utils.py\":503-527",
            "content": "    poly = get_best_begin_point_single(poly)\n    return poly\ndef rbox2poly(rrects):\n    \"\"\"\n    rrect:[x_ctr,y_ctr,w,h,angle]\n    to\n    poly:[x0,y0,x1,y1,x2,y2,x3,y3]\n    \"\"\"\n    polys = []\n    for rrect in rrects:\n        x_ctr, y_ctr, width, height, angle = rrect[:5]\n        tl_x, tl_y, br_x, br_y = -width / 2, -height / 2, width / 2, height / 2\n        rect = np.array([[tl_x, br_x, br_x, tl_x], [tl_y, tl_y, br_y, br_y]])\n        R = np.array([[np.cos(angle), -np.sin(angle)],\n                      [np.sin(angle), np.cos(angle)]])\n        poly = R.dot(rect)\n        x0, x1, x2, x3 = poly[0, :4] + x_ctr\n        y0, y1, y2, y3 = poly[1, :4] + y_ctr\n        poly = np.array([x0, y0, x1, y1, x2, y2, x3, y3], dtype=np.float32)\n        poly = get_best_begin_point_single(poly)\n        polys.append(poly)\n    polys = np.array(polys)\n    return polys"
        }
    ]
}