{
    "summary": "The `DepthMetric` class inherits from `BaseMetric`, processes batches, accumulates metrics and performs distributed all-reduce operations before averaging metric values.",
    "details": [
        {
            "comment": "This code defines a class `DepthMetric` that inherits from `BaseMetric`. It initializes lists for various metric values and then updates these metrics during each iteration. The code also includes logic to handle distributed computing, using all-reduce operation to average the results across different processes in the same training job.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/depth_metric.py\":0-33",
            "content": "import numpy as np\nimport paddle\nfrom paddlevideo.utils import get_logger\nfrom .base import BaseMetric\nfrom .registry import METRIC\nlogger = get_logger(\"paddlevideo\")\n@METRIC.register\nclass DepthMetric(BaseMetric):\n    def __init__(self, data_size, batch_size, log_interval=1):\n        \"\"\"prepare for metrics\n        \"\"\"\n        super().__init__(data_size, batch_size, log_interval)\n        self.abs_rel = []\n        self.sq_rel = []\n        self.rmse = []\n        self.rmse_log = []\n        self.a1 = []\n        self.a2 = []\n        self.a3 = []\n    def update(self, batch_id, data, outputs):\n        \"\"\"update metrics during each iter\n        \"\"\"\n        abs_rel, sq_rel, rmse, rmse_log, a1, a2, a3 = outputs['abs_rel'], outputs['sq_rel'], outputs['rmse'], \\\n                                                      outputs['rmse_log'], outputs['a1'], outputs['a2'],outputs['a3']\n        # preds ensemble\n        if self.world_size > 1:\n            abs_rel = paddle.distributed.all_reduce(\n                outputs['abs_rel'],\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size"
        },
        {
            "comment": "This code performs distributed all-reduce operations on several metrics (sq_rel, rmse, rmse\\_log, a1, a2, a3) and calculates their average values by dividing by the world size. These averaged metric values are then appended to corresponding lists (abs_rel, sq_rel, rmse, rmse_log).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/depth_metric.py\":34-56",
            "content": "            sq_rel = paddle.distributed.all_reduce(\n                outputs['sq_rel'],\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size\n            rmse = paddle.distributed.all_reduce(\n                outputs['rmse'],\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size\n            rmse_log = paddle.distributed.all_reduce(\n                outputs['rmse_log'],\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size\n            a1 = paddle.distributed.all_reduce(\n                outputs['a1'],\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size\n            a2 = paddle.distributed.all_reduce(\n                outputs['a2'],\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size\n            a3 = paddle.distributed.all_reduce(\n                outputs['a3'],\n                op=paddle.distributed.ReduceOp.SUM) / self.world_size\n        self.abs_rel.append(abs_rel)\n        self.sq_rel.append(sq_rel)\n        self.rmse.append(rmse)\n        self.rmse_log.append(rmse_log)"
        },
        {
            "comment": "This code defines a class with methods for processing batches and accumulating metrics. The `process_batch` method appends data to lists, logs progress if the batch ID is divisible by log_interval, and handles the next batch. The `accumulate` method calculates mean values for each metric list and logs them using a logger with the corresponding metric values.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/depth_metric.py\":57-76",
            "content": "        self.a1.append(a1)\n        self.a2.append(a2)\n        self.a3.append(a3)\n        if batch_id % self.log_interval == 0:\n            logger.info(\"[TEST] Processing batch {}/{} ...\".format(\n                batch_id,\n                self.data_size // (self.batch_size * self.world_size)))\n    def accumulate(self):\n        \"\"\"accumulate metrics when finished all iters.\n        \"\"\"\n        logger.info(\n            '[TEST] finished, abs_rel= {}, sq_rel= {} , rmse= {}, rmse_log= {},'\n            'a1= {}, a2= {}, a3= {}'.format(np.mean(np.array(self.abs_rel)),\n                                            np.mean(np.array(self.sq_rel)),\n                                            np.mean(np.array(self.rmse)),\n                                            np.mean(np.array(self.rmse_log)),\n                                            np.mean(np.array(self.a1)),\n                                            np.mean(np.array(self.a2)),\n                                            np.mean(np.array(self.a3))))"
        }
    ]
}