{
    "summary": "The SFMRI_DecodeSampler class is a tool that decodes and samples MRI frames, creating segments based on sampling indices and handling video length constraints. It calculates offsets for 's' and 'f' frame types, determines average durations per segment, and returns an object containing the frame indices.",
    "details": [
        {
            "comment": "This code snippet is a Python class for the SFMRI_DecodeSampler pipeline, which decodes and samples MRI frames. It uses PIL and SimpleITK packages to read images and relies on OpenCV for image processing. The class is registered in the PIPELINES module.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":0-35",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport os\nimport random\nimport numpy as np\nfrom PIL import Image\ntry:\n    import SimpleITK as sitk\nexcept ImportError as e:\n    print(\n        f\"Warning! {e}, [SimpleITK] package and it's dependencies is required for PP-Care.\"\n    )\nimport cv2\nfrom ..registry import PIPELINES\n@PIPELINES.register()\nclass SFMRI_DecodeSampler(object):\n    \"\"\"\n    Sample frames id.\n    NOTE: Use PIL to read image here, has diff with CV2\n    Args:"
        },
        {
            "comment": "This code defines a class with methods for creating segments of frames from an MRI image. The constructor takes arguments for the number of segments, length of each segment, and optional parameters for sampling mode. It returns the indexes of sampled frames in each segment. The class also includes a method for getting images from the MRI and storing them.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":36-63",
            "content": "        num_seg(int): number of segments.\n        seg_len(int): number of sampled frames in each segment.\n        valid_mode(bool): True or False.\n        select_left: Whether to select the frame to the left in the middle when the sampling interval is even in the test mode.\n    Returns:\n        frames_idx: the index of sampled #frames.\n    \"\"\"\n    def __init__(self,\n                 num_seg,\n                 seg_len,\n                 valid_mode=False,\n                 select_left=False,\n                 dense_sample=False,\n                 linspace_sample=False):\n        self.num_seg = num_seg\n        self.seg_len = seg_len\n        self.valid_mode = valid_mode\n        self.select_left = select_left\n        self.dense_sample = dense_sample\n        self.linspace_sample = linspace_sample\n    def _get(self, frames_idx_s, frames_idx_f, results):\n        frame_dir = results['frame_dir']\n        imgs_s = []\n        imgs_f = []\n        MRI = sitk.GetArrayFromImage(sitk.ReadImage(frame_dir))\n        for idx in frames_idx_s:"
        },
        {
            "comment": "This code defines a class that takes in MRI data and returns resized images for sampling. It creates two lists, imgs_s and imgs_f, which contain the resized MRI frames. The results dictionary contains these lists under the 'imgs' key. The __call__ method calculates the average duration of each segment based on frames_len, and generates frame indices for each segment using linspace_sample. It does not return any value in this context.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":64-93",
            "content": "            item = MRI[idx]\n            item = cv2.resize(item, (224, 224))\n            imgs_s.append(item)\n        for idx in frames_idx_f:\n            item = MRI[idx]\n            item = cv2.resize(item, (224, 224))\n            imgs_f.append(item)\n        results['imgs'] = [imgs_s, imgs_f]\n        return results\n    def __call__(self, results):\n        \"\"\"\n        Args:\n            frames_len: length of frames.\n        return:\n            sampling id.\n        \"\"\"\n        frames_len = int(results['frames_len'])\n        average_dur1 = int(frames_len / self.num_seg[0])\n        average_dur2 = int(frames_len / self.num_seg[1])\n        frames_idx_s = []\n        frames_idx_f = []\n        if self.linspace_sample:\n            if 'start_idx' in results and 'end_idx' in results:\n                offsets_s = np.linspace(results['start_idx'],\n                                        results['end_idx'], self.num_seg[0])\n                offsets_f = np.linspace(results['start_idx'],\n                                        results['end_idx'], self.num_seg[1])"
        },
        {
            "comment": "This code segment handles sampling of frames for video decoding. It sets the offsets for sample positions based on the number of segments specified and ensures they are within the valid frame range. If `select_left` is not set, it further checks if `dense_sample` is enabled in dense sampling mode. For ppTSM, it selects a sample position and calculates the corresponding offsets for each segment using the given formulas.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":94-114",
            "content": "            else:\n                offsets_s = np.linspace(0, frames_len - 1, self.num_seg[0])\n                offsets_f = np.linspace(0, frames_len - 1, self.num_seg[1])\n            offsets_s = np.clip(offsets_s, 0, frames_len - 1).astype(np.int64)\n            offsets_f = np.clip(offsets_f, 0, frames_len - 1).astype(np.int64)\n            frames_idx_s = list(offsets_s)\n            frames_idx_f = list(offsets_f)\n            return self._get(frames_idx_s, frames_idx_f, results)\n        if not self.select_left:\n            if self.dense_sample:  # For ppTSM\n                if not self.valid_mode:  # train\n                    sample_pos = max(1, 1 + frames_len - 64)\n                    t_stride1 = 64 // self.num_seg[0]\n                    t_stride2 = 64 // self.num_seg[1]\n                    start_idx = 0 if sample_pos == 1 else np.random.randint(\n                        0, sample_pos - 1)\n                    offsets_s = [(idx * t_stride1 + start_idx) % frames_len + 1\n                                 for idx in range(self.num_seg[0])]"
        },
        {
            "comment": "This code calculates the sampling indices for both spatial and frequency domains. It creates two lists, frames_idx_s and frames_idx_f, based on the number of segments in each dimension (self.num_seg[0] and self.num_seg[1]). If the video length is less than 64 frames, it sets a smaller sampling range for both domains. The code also includes a backup strategy that uses a list of starting points for sampling if the video length is longer but still shorter than 64 frames.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":115-134",
            "content": "                    offsets_f = [(idx * t_stride2 + start_idx) % frames_len + 1\n                                 for idx in range(self.num_seg[1])]\n                    frames_idx_s = offsets_s\n                    frames_idx_f = offsets_f\n                else:\n                    sample_pos = max(1, 1 + frames_len - 64)\n                    t_stride1 = 64 // self.num_seg[0]\n                    t_stride2 = 64 // self.num_seg[1]\n                    start_list = np.linspace(0,\n                                             sample_pos - 1,\n                                             num=10,\n                                             dtype=int)\n                    offsets_s = []\n                    offsets_f = []\n                    for start_idx in start_list.tolist():\n                        offsets_s += [\n                            (idx * t_stride1 + start_idx) % frames_len + 1\n                            for idx in range(self.num_seg[0])\n                        ]\n                    for start_idx in start_list.tolist():"
        },
        {
            "comment": "This code calculates the offsets for segmenting frames and storing them in two lists, `frames_idx_s` and `frames_idx_f`. If `valid_mode` is set, it randomly selects the indices within the constraints of `average_dur1`, otherwise it uses sequential indexing. It also handles cases where `average_dur1` is less than 1 by setting the index to i.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":135-156",
            "content": "                        offsets_f += [\n                            (idx * t_stride2 + start_idx) % frames_len + 1\n                            for idx in range(self.num_seg[1])\n                        ]\n                    frames_idx_s = offsets_s\n                    frames_idx_f = offsets_f\n            else:\n                for i in range(self.num_seg[0]):\n                    idx = 0\n                    if not self.valid_mode:\n                        if average_dur1 >= self.seg_len:\n                            idx = random.randint(0, average_dur1 - self.seg_len)\n                            idx += i * average_dur1\n                        elif average_dur1 >= 1:\n                            idx += i * average_dur1\n                        else:\n                            idx = i\n                    else:\n                        if average_dur1 >= self.seg_len:\n                            idx = (average_dur1 - 1) // 2\n                            idx += i * average_dur1\n                        elif average_dur1 >= 1:"
        },
        {
            "comment": "Code iterates over frames and segments, assigning frame indices based on valid mode and average durations. If valid mode is off, it determines the idx based on average duration 1 and 2, or if in valid mode, it sets the idx to half the remaining average duration 2 minus 1. Finally, it appends frame indices to frames_idx_s list for each segment length.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":157-179",
            "content": "                            idx += i * average_dur1\n                        else:\n                            idx = i\n                    for jj in range(idx, idx + self.seg_len):\n                        frames_idx_s.append(jj)\n                for i in range(self.num_seg[1]):\n                    idx = 0\n                    if not self.valid_mode:\n                        if average_dur2 >= self.seg_len:\n                            idx = random.randint(0, average_dur2 - self.seg_len)\n                            idx += i * average_dur2\n                        elif average_dur2 >= 1:\n                            idx += i * average_dur2\n                        else:\n                            idx = i\n                    else:\n                        if average_dur2 >= self.seg_len:\n                            idx = (average_dur2 - 1) // 2\n                            idx += i * average_dur2\n                        elif average_dur2 >= 1:\n                            idx += i * average_dur2\n                        else:"
        },
        {
            "comment": "If not in valid mode, if average duration 2 > 0, generate offsets_s and offsets_f for TSM. If frames_len is greater than num_seg[1], randomly select offsets_s and offsets_f. Otherwise, set offsets_s to zeros.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":180-202",
            "content": "                            idx = i\n                    for jj in range(idx, idx + self.seg_len):\n                        frames_idx_f.append(jj)\n            return self._get(frames_idx_s, frames_idx_f, results)\n        else:  # for TSM\n            if not self.valid_mode:\n                if average_dur2 > 0:\n                    offsets_s = np.multiply(list(range(\n                        self.num_seg[0])), average_dur1) + np.random.randint(\n                            average_dur1, size=self.num_seg[0])\n                    offsets_f = np.multiply(list(range(\n                        self.num_seg[1])), average_dur2) + np.random.randint(\n                            average_dur2, size=self.num_seg[1])\n                elif frames_len > self.num_seg[1]:\n                    offsets_s = np.sort(\n                        np.random.randint(frames_len, size=self.num_seg[0]))\n                    offsets_f = np.sort(\n                        np.random.randint(frames_len, size=self.num_seg[1]))\n                else:\n                    offsets_s = np.zeros(shape=(self.num_seg[0], ))"
        },
        {
            "comment": "This code calculates the offsets for segmenting frames into 's' and 'f' types based on the number of segments specified. If the total number of frames is greater than the specified number of segments, it calculates the average duration per segment for both types ('s' and 'f'). It then creates arrays of frame indices for 's' and 'f' frames using these calculated offsets. Finally, it returns an object by calling a method '_get'.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler_MRI.py\":203-223",
            "content": "                    offsets_f = np.zeros(shape=(self.num_seg[1], ))\n            else:\n                if frames_len > self.num_seg[1]:\n                    average_dur_float_s = frames_len / self.num_seg[0]\n                    offsets_s = np.array([\n                        int(average_dur_float_s / 2.0 + average_dur_float_s * x)\n                        for x in range(self.num_seg[0])\n                    ])\n                    average_dur_float_f = frames_len / self.num_seg[1]\n                    offsets_f = np.array([\n                        int(average_dur_float_f / 2.0 + average_dur_float_f * x)\n                        for x in range(self.num_seg[1])\n                    ])\n                else:\n                    offsets_s = np.zeros(shape=(self.num_seg[0], ))\n                    offsets_f = np.zeros(shape=(self.num_seg[1], ))\n            frames_idx_s = list(offsets_s)\n            frames_idx_f = list(offsets_f)\n            return self._get(frames_idx_s, frames_idx_f, results)"
        }
    ]
}