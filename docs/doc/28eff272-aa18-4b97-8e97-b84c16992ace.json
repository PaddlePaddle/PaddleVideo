{
    "summary": "The code defines a Compose class for image processing steps and functions to preprocess video frames, returning input/output variables. The get_preprocess_func function selects the correct preprocessing function based on the model name. Invalid names raise ValueError.",
    "details": [
        {
            "comment": "This code imports necessary libraries and defines the VALID_MODELS variable. It then creates a Compose class that takes in a list of transforms, allowing for composition of multiple image processing steps to be applied sequentially.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_serving/preprocess_ops.py\":0-33",
            "content": "import os\nimport sys\n__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(os.path.abspath(os.path.join(__dir__, \"../../\")))\nfrom paddlevideo.loader.pipelines import (CenterCrop, Image2Array,\n                                          Normalization, Sampler, Scale,\n                                          VideoDecoder, TenCrop)\nimport numpy as np\nfrom typing import Dict, Tuple, List, Callable\nVALID_MODELS = [\"PPTSM\", \"PPTSN\"]\nimport os\nimport sys\n__dir__ = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(os.path.abspath(os.path.join(__dir__, \"../../\")))\nfrom paddlevideo.loader.pipelines import (CenterCrop, Image2Array,\n                                          Normalization, Sampler, Scale,\n                                          VideoDecoder, TenCrop)\nimport numpy as np\nfrom typing import Dict, Tuple, List, Callable\nVALID_MODELS = [\"PPTSM\", \"PPTSN\"]\nclass Compose:\n    def __init__(self, transforms):\n        self.transforms = transforms\n    def __call__(self, img):\n        for t in self.transforms:"
        },
        {
            "comment": "The code is defining a function `preprocess_PPTSM` that takes a video path as input, and applies several image preprocessing steps before returning the feed and fetch data. These steps include decoding the video frames, sampling, scaling, cropping, converting to array format, and normalization using specific mean and standard deviation values. The resulting processed data is stored in the `results` dictionary, which contains the images and metadata.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_serving/preprocess_ops.py\":34-75",
            "content": "            img = t(img)\n        return img\ndef np_softmax(x: np.ndarray, axis: int = 0) -> np.ndarray:\n    \"\"\"softmax function\n    Args:\n        x (np.ndarray): logits\n        axis (int): axis\n    Returns:\n        np.ndarray: probs\n    \"\"\"\n    x -= np.max(x, axis=axis, keepdims=True)\n    x = np.exp(x) / np.sum(np.exp(x), axis=axis, keepdims=True)\n    return x\ndef preprocess_PPTSM(video_path: str) -> Tuple[Dict[str, np.ndarray], List]:\n    \"\"\"preprocess\n    Args:\n        video_path (str): input video path\n    Returns:\n        Tuple[Dict[str, np.ndarray], List]: feed and fetch\n    \"\"\"\n    img_mean = [0.485, 0.456, 0.406]\n    img_std = [0.229, 0.224, 0.225]\n    seq = Compose([\n        VideoDecoder(),\n        Sampler(8, 1, valid_mode=True),\n        Scale(256),\n        CenterCrop(224),\n        Image2Array(),\n        Normalization(img_mean, img_std)\n    ])\n    results = {\"filename\": video_path}\n    results = seq(results)\n    tmp_inp = np.expand_dims(results[\"imgs\"], axis=0)  # [b,t,c,h,w]\n    tmp_inp = np.expand_dims(tmp_inp, axis=0)  # [1,b,t,c,h,w]"
        },
        {
            "comment": "The function preprocess_PPTSN takes in a video path, applies a series of image processing steps to the video frames, and returns feed and fetch variables for input and output respectively. The get_preprocess_func function returns a preprocessing function based on the given model name.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_serving/preprocess_ops.py\":76-110",
            "content": "    feed = {\"data_batch_0\": tmp_inp}\n    fetch = [\"outputs\"]\n    return feed, fetch\ndef preprocess_PPTSN(video_path: str) -> Tuple[Dict[str, np.ndarray], List]:\n    \"\"\"preprocess\n    Args:\n        video_path (str): input video path\n    Returns:\n        Tuple[Dict[str, np.ndarray], List]: feed and fetch\n    \"\"\"\n    img_mean = [0.485, 0.456, 0.406]\n    img_std = [0.229, 0.224, 0.225]\n    seq = Compose([\n        VideoDecoder(),\n        Sampler(25, 1, valid_mode=True, select_left=True),\n        Scale(256, fixed_ratio=True, do_round=True, backend='cv2'),\n        TenCrop(224),\n        Image2Array(),\n        Normalization(img_mean, img_std)\n    ])\n    results = {\"filename\": video_path}\n    results = seq(results)\n    tmp_inp = np.expand_dims(results[\"imgs\"], axis=0)  # [b,t,c,h,w]\n    tmp_inp = np.expand_dims(tmp_inp, axis=0)  # [1,b,t,c,h,w]\n    feed = {\"data_batch_0\": tmp_inp}\n    fetch = [\"outputs\"]\n    return feed, fetch\ndef get_preprocess_func(model_name: str) -> Callable:\n    \"\"\"get preprocess function by model_name"
        },
        {
            "comment": "This function takes a model name as input and returns the corresponding preprocess function based on the conditionals provided. If the model name is \"PPTSM\", it will return the preprocess_PPTSM function, if the model name is \"PPTSN\" it will return preprocess_PPTSN, otherwise it raises a ValueError with an error message stating that the model name must be in VALID_MODELS.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_serving/preprocess_ops.py\":112-125",
            "content": "    Args:\n        model_name (str): model's name, must in `VALID_MODELS`\n    Returns:\n        Callable: preprocess function corresponding to model name\n    \"\"\"\n    if model_name == \"PPTSM\":\n        return preprocess_PPTSM\n    elif model_name == \"PPTSN\":\n        return preprocess_PPTSN\n    else:\n        raise ValueError(\n            f\"model_name must in {VALID_MODELS}, but got model_name\")"
        }
    ]
}