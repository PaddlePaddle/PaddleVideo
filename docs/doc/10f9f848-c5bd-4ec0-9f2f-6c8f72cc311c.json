{
    "summary": "The code incorporates image processing and Graph class, supports layouts like 'stgcn' and 'coco_keypoint'. It defines a STGCN model for spatio-temporal data processing using ConvTemporalGraphical layer. The code creates a STGCN class for skeleton-based action recognition with edge importance, applies networks, pools results, and averages before returning output.",
    "details": [
        {
            "comment": "This code snippet imports necessary libraries, defines several functions (zero, iden, einsum), and registers the BACKBONES. The purpose of this module seems to be defining backbone architectures or functions used in image processing tasks. However, more context is needed to understand the specific functionality of these functions or their use within the BACKBONES registry.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":0-36",
            "content": "# Copyright (c) 2021  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport paddle\nimport paddle.nn as nn\nimport paddle.nn.functional as F\nimport numpy as np\nfrom ..registry import BACKBONES\nfrom ..weight_init import weight_init_\ndef zero(x):\n    return 0\ndef iden(x):\n    return x\ndef einsum(x, A):\n    \"\"\"paddle.einsum will be implemented in release/2.2.\n    \"\"\"\n    x = x.transpose((0, 2, 3, 1, 4))\n    n, c, t, k, v = x.shape\n    k2, v2, w = A.shape\n    assert (k == k2 and v == v2), \"Args of einsum not match!\""
        },
        {
            "comment": "This code defines a Graph class and three functions: get_hop_distance, normalize_digraph, and a constructor for the Graph class. The Graph class initializes with layout, strategy, max_hop, and dilation parameters. The get_hop_distance function computes hop distances between nodes in a graph up to max_hop level. The normalize_digraph function calculates and applies row-wise node degrees to normalize the adjacency matrix. The constructor initializes an instance of the Graph class with given parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":37-79",
            "content": "    x = x.reshape((n, c, t, k * v))\n    A = A.reshape((k * v, w))\n    y = paddle.matmul(x, A)\n    return y\ndef get_hop_distance(num_node, edge, max_hop=1):\n    A = np.zeros((num_node, num_node))\n    for i, j in edge:\n        A[j, i] = 1\n        A[i, j] = 1\n    # compute hop steps\n    hop_dis = np.zeros((num_node, num_node)) + np.inf\n    transfer_mat = [np.linalg.matrix_power(A, d) for d in range(max_hop + 1)]\n    arrive_mat = (np.stack(transfer_mat) > 0)\n    for d in range(max_hop, -1, -1):\n        hop_dis[arrive_mat[d]] = d\n    return hop_dis\ndef normalize_digraph(A):\n    Dl = np.sum(A, 0)\n    num_node = A.shape[0]\n    Dn = np.zeros((num_node, num_node))\n    for i in range(num_node):\n        if Dl[i] > 0:\n            Dn[i, i] = Dl[i]**(-1)\n    AD = np.dot(A, Dn)\n    return AD\nclass Graph():\n    def __init__(self,\n                 layout='openpose',\n                 strategy='uniform',\n                 max_hop=1,\n                 dilation=1):\n        self.max_hop = max_hop\n        self.dilation = dilation\n        self.get_edge(layout)"
        },
        {
            "comment": "The code initializes the hop distance and edge based on the number of nodes, maximum hops, and layout type. It defines self_link as intra-node connections and neighbor_link as inter-node connections. The center node is determined based on the layout.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":80-103",
            "content": "        self.hop_dis = get_hop_distance(self.num_node,\n                                        self.edge,\n                                        max_hop=max_hop)\n        self.get_adjacency(strategy)\n    def __str__(self):\n        return self.A\n    def get_edge(self, layout):\n        # edge is a list of [child, parent] paris\n        if layout == 'fsd10':\n            self.num_node = 25\n            self_link = [(i, i) for i in range(self.num_node)]\n            neighbor_link = [(1, 8), (0, 1), (15, 0), (17, 15), (16, 0),\n                             (18, 16), (5, 1), (6, 5), (7, 6), (2, 1), (3, 2),\n                             (4, 3), (9, 8), (10, 9), (11, 10), (24, 11),\n                             (22, 11), (23, 22), (12, 8), (13, 12), (14, 13),\n                             (21, 14), (19, 14), (20, 19)]\n            self.edge = self_link + neighbor_link\n            self.center = 8\n        elif layout == 'ntu-rgb+d':\n            self.num_node = 25\n            self_link = [(i, i) for i in range(self.num_node)]"
        },
        {
            "comment": "The code initializes 'self.edge' and 'self.center', defining nodes, self-links, and neighboring node links based on the specified layout ('stgcn' or 'coco_keypoint'). For 'stgcn', there are 25 nodes with various connections, while for 'coco_keypoint', there are 17 nodes with specific connections.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":104-119",
            "content": "            neighbor_1base = [(1, 2), (2, 21), (3, 21), (4, 3), (5, 21), (6, 5),\n                              (7, 6), (8, 7), (9, 21), (10, 9), (11, 10),\n                              (12, 11), (13, 1), (14, 13), (15, 14), (16, 15),\n                              (17, 1), (18, 17), (19, 18), (20, 19), (22, 23),\n                              (23, 8), (24, 25), (25, 12)]\n            neighbor_link = [(i - 1, j - 1) for (i, j) in neighbor_1base]\n            self.edge = self_link + neighbor_link\n            self.center = 21 - 1\n        elif layout == 'coco_keypoint':\n            self.num_node = 17\n            self_link = [(i, i) for i in range(self.num_node)]\n            neighbor_1base = [(0, 1), (0, 2), (1, 3), (2, 4), (3, 5), (4, 6),\n                              (5, 7), (6, 8), (7, 9), (8, 10), (5, 11), (6, 12),\n                              (11, 13), (12, 14), (13, 15), (14, 16), (11, 12)]\n            neighbor_link = [(i, j) for (i, j) in neighbor_1base]\n            self.edge = self_link + neighbor_link"
        },
        {
            "comment": "This function sets the adjacency matrix for STGCN based on the strategy. It initializes the adjacency matrix as a zero matrix, then fills it with 1s for valid hops. The adjacency matrix is normalized using `normalize_digraph`. If the strategy is 'spatial', it iterates over each pair of nodes and populates the adjacency matrix accordingly based on their hop distance from the center node and their hop distance to each other.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":120-142",
            "content": "            self.center = 11\n        else:\n            raise ValueError(\"Do Not Exist This Layout.\")\n    def get_adjacency(self, strategy):\n        valid_hop = range(0, self.max_hop + 1, self.dilation)\n        adjacency = np.zeros((self.num_node, self.num_node))\n        for hop in valid_hop:\n            adjacency[self.hop_dis == hop] = 1\n        normalize_adjacency = normalize_digraph(adjacency)\n        if strategy == 'spatial':\n            A = []\n            for hop in valid_hop:\n                a_root = np.zeros((self.num_node, self.num_node))\n                a_close = np.zeros((self.num_node, self.num_node))\n                a_further = np.zeros((self.num_node, self.num_node))\n                for i in range(self.num_node):\n                    for j in range(self.num_node):\n                        if self.hop_dis[j, i] == hop:\n                            if self.hop_dis[j, self.center] == self.hop_dis[\n                                    i, self.center]:\n                                a_root[j, i] = normalize_adjacency[j, i]"
        },
        {
            "comment": "This code implements a ConvTemporalGraphical layer, which is a backbone architecture for STGCN. It initializes the ConvTemporalGraphical layer with input and output channels, kernel size, and temporal parameters. The code handles different strategies to build the adjacency matrix (A) for the graph convolution by considering close and further nodes based on hop distance from the central node. If hop == 0, it appends A to a list, otherwise appends both close and further A matrices. Finally, it stacks the A matrices into a numpy array and assigns it to self.A.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":143-173",
            "content": "                            elif self.hop_dis[j, self.center] > self.hop_dis[\n                                    i, self.center]:\n                                a_close[j, i] = normalize_adjacency[j, i]\n                            else:\n                                a_further[j, i] = normalize_adjacency[j, i]\n                if hop == 0:\n                    A.append(a_root)\n                else:\n                    A.append(a_root + a_close)\n                    A.append(a_further)\n            A = np.stack(A)\n            self.A = A\n        else:\n            raise ValueError(\"Do Not Exist This Strategy\")\nclass ConvTemporalGraphical(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 t_kernel_size=1,\n                 t_stride=1,\n                 t_padding=0,\n                 t_dilation=1):\n        super().__init__()\n        self.kernel_size = kernel_size\n        self.conv = nn.Conv2D(in_channels,\n                              out_channels * kernel_size,"
        },
        {
            "comment": "The code defines a ConvTemporalGraphical layer and an STGCNBlock. The ConvTemporalGraphical layer is a 2D convolutional layer with temporal kernel size, padding, stride, and dilation. The STGCNBlock is a residual block that takes input and output channels, temporal kernel size, stride, and dropout as inputs. It initializes the GCN layer and TCN layers sequentially, with the GCN layer performing temporal graph convolution and the TCN layers performing temporal convolutions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":174-208",
            "content": "                              kernel_size=(t_kernel_size, 1),\n                              padding=(t_padding, 0),\n                              stride=(t_stride, 1),\n                              dilation=(t_dilation, 1))\n    def forward(self, x, A):\n        assert A.shape[0] == self.kernel_size\n        x = self.conv(x)\n        n, kc, t, v = x.shape\n        x = x.reshape((n, self.kernel_size, kc // self.kernel_size, t, v))\n        x = einsum(x, A)\n        return x, A\nclass st_gcn_block(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 kernel_size,\n                 stride=1,\n                 dropout=0,\n                 residual=True):\n        super(st_gcn_block, self).__init__()\n        assert len(kernel_size) == 2\n        assert kernel_size[0] % 2 == 1\n        padding = ((kernel_size[0] - 1) // 2, 0)\n        self.gcn = ConvTemporalGraphical(in_channels, out_channels,\n                                         kernel_size[1])\n        self.tcn = nn.Sequential("
        },
        {
            "comment": "This code defines a STGCN (Spatio-Temporal Graph Convolutional Network) model. It includes layers such as BatchNormalization, ReLU activation, and convolution operations for processing spatial and temporal data. The forward method applies these operations to input features x and adjacency matrix A.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":209-250",
            "content": "            nn.BatchNorm2D(out_channels),\n            nn.ReLU(),\n            nn.Conv2D(\n                out_channels,\n                out_channels,\n                (kernel_size[0], 1),\n                (stride, 1),\n                padding,\n            ),\n            nn.BatchNorm2D(out_channels),\n            nn.Dropout(dropout),\n        )\n        if not residual:\n            self.residual = zero\n        elif (in_channels == out_channels) and (stride == 1):\n            self.residual = iden\n        else:\n            self.residual = nn.Sequential(\n                nn.Conv2D(in_channels,\n                          out_channels,\n                          kernel_size=1,\n                          stride=(stride, 1)),\n                nn.BatchNorm2D(out_channels),\n            )\n        self.relu = nn.ReLU()\n    def forward(self, x, A):\n        res = self.residual(x)\n        x, A = self.gcn(x, A)\n        x = self.tcn(x) + res\n        return self.relu(x), A\n@BACKBONES.register()\nclass STGCN(nn.Layer):\n    \"\"\"\n    ST-GCN model from:\n "
        },
        {
            "comment": "This code defines the STGCN (Spatial Temporal Graph Convolutional Networks) class, which is a model for skeleton-based action recognition. It takes arguments like in_channels, edge_importance_weighting, and data_bn to determine the network configuration. It loads graph data and builds networks with specific kernel sizes for spatial and temporal dimensions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":250-277",
            "content": "   `\"Spatial Temporal Graph Convolutional Networks for Skeleton-Based Action Recognition\" <https://arxiv.org/abs/1801.07455>`_\n    Args:\n        in_channels: int, channels of vertex coordinate. 2 for (x,y), 3 for (x,y,z). Default 2.\n        edge_importance_weighting: bool, whether to use edge attention. Default True.\n        data_bn: bool, whether to use data BatchNorm. Default True.\n    \"\"\"\n    def __init__(self,\n                 in_channels=2,\n                 edge_importance_weighting=True,\n                 data_bn=True,\n                 layout='fsd10',\n                 strategy='spatial',\n                 **kwargs):\n        super(STGCN, self).__init__()\n        self.data_bn = data_bn\n        # load graph\n        self.graph = Graph(\n            layout=layout,\n            strategy=strategy,\n        )\n        A = paddle.to_tensor(self.graph.A, dtype='float32')\n        self.register_buffer('A', A)\n        # build networks\n        spatial_kernel_size = A.shape[0]\n        temporal_kernel_size = 9\n        kernel_size = (temporal_kernel_size, spatial_kernel_size)"
        },
        {
            "comment": "This code initializes a series of ST-GCN blocks with different configurations for the ST-GCN backbone, including batch normalization and specific layer dimensions. These blocks are stored in a LayerList for flexibility and efficient computation.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":278-299",
            "content": "        self.data_bn = nn.BatchNorm1D(in_channels *\n                                      A.shape[1]) if self.data_bn else iden\n        kwargs0 = {k: v for k, v in kwargs.items() if k != 'dropout'}\n        self.st_gcn_networks = nn.LayerList((\n            st_gcn_block(in_channels,\n                         64,\n                         kernel_size,\n                         1,\n                         residual=False,\n                         **kwargs0),\n            st_gcn_block(64, 64, kernel_size, 1, **kwargs),\n            st_gcn_block(64, 64, kernel_size, 1, **kwargs),\n            st_gcn_block(64, 64, kernel_size, 1, **kwargs),\n            st_gcn_block(64, 128, kernel_size, 2, **kwargs),\n            st_gcn_block(128, 128, kernel_size, 1, **kwargs),\n            st_gcn_block(128, 128, kernel_size, 1, **kwargs),\n            st_gcn_block(128, 256, kernel_size, 2, **kwargs),\n            st_gcn_block(256, 256, kernel_size, 1, **kwargs),\n            st_gcn_block(256, 256, kernel_size, 1, **kwargs),\n        ))\n        # initialize parameters for edge importance weighting"
        },
        {
            "comment": "Code creates edge importance parameters if edge_importance_weighting is True, otherwise sets all edge importances to 1. Initializes weights for convolutional layers and batch normalization layers with specified means and standard deviations. The forward function transposes the input tensor shape before processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":300-326",
            "content": "        if edge_importance_weighting:\n            self.edge_importance = nn.ParameterList([\n                self.create_parameter(\n                    shape=self.A.shape,\n                    default_initializer=nn.initializer.Constant(1))\n                for i in self.st_gcn_networks\n            ])\n        else:\n            self.edge_importance = [1] * len(self.st_gcn_networks)\n        self.pool = nn.AdaptiveAvgPool2D(output_size=(1, 1))\n    def init_weights(self):\n        \"\"\"Initiate the parameters.\n        \"\"\"\n        for layer in self.sublayers():\n            if isinstance(layer, nn.Conv2D):\n                weight_init_(layer, 'Normal', mean=0.0, std=0.02)\n            elif isinstance(layer, nn.BatchNorm2D):\n                weight_init_(layer, 'Normal', mean=1.0, std=0.02)\n            elif isinstance(layer, nn.BatchNorm1D):\n                weight_init_(layer, 'Normal', mean=1.0, std=0.02)\n    def forward(self, x):\n        # data normalization\n        N, C, T, V, M = x.shape\n        x = x.transpose((0, 4, 3, 1, 2))  # N, M, V, C, T"
        },
        {
            "comment": "This code reshapes the input tensor and applies batch normalization before reshaping again. It then transposes the dimensions and reshapes once more. The main operation involves iterating through each ST-GCN network and applying it to the input with multiplied edge importance, followed by pooling. Finally, it reshapes the output, performs averaging over the third dimension, and returns the result.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/stgcn.py\":327-342",
            "content": "        x = x.reshape((N * M, V * C, T))\n        if self.data_bn:\n            x.stop_gradient = False\n        x = self.data_bn(x)\n        x = x.reshape((N, M, V, C, T))\n        x = x.transpose((0, 1, 3, 4, 2))  # N, M, C, T, V\n        x = x.reshape((N * M, C, T, V))\n        # forward\n        for gcn, importance in zip(self.st_gcn_networks, self.edge_importance):\n            x, _ = gcn(x, paddle.multiply(self.A, importance))\n        x = self.pool(x)  # NM,C,T,V --> NM,C,1,1\n        C = x.shape[1]\n        x = paddle.reshape(x, (N, M, C, 1, 1)).mean(axis=1)  # N,C,1,1\n        return x"
        }
    ]
}