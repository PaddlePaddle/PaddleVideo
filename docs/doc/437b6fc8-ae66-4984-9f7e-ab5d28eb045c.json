{
    "summary": "This code imports libraries, defines a class for metrics calculation, retrieves data from ActivityNet API, compares results, creates DataFrames, evaluates proposals using AUC-RC, and calculates average recall. It extracts videos, computes proposal scores, IOU scores, handles exceptions, determines recall with thresholds, and efficiently computes IoU for target and candidate segments.",
    "details": [
        {
            "comment": "This code imports necessary libraries, defines a class for calculating AR@N and AUC, and sets the API URL for accessing ActivityNet data. The class uses ground truth fields and proposal fields to compare results. Code is transferred from the ActivityNet GitHub repository.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":0-28",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nimport json\nimport numpy as np\nimport pandas as pd\nimport urllib.request as urllib2\nfrom paddlevideo.utils import get_logger\nlogger = get_logger(\"paddlevideo\")\nclass ANETproposal(object):\n    \"\"\"\n    This class is used for calculating AR@N and AUC;\n    Code transfer from ActivityNet Gitub repository](https://github.com/activitynet/ActivityNet.git)\n    \"\"\"\n    GROUND_TRUTH_FIELDS = ['database', 'taxonomy', 'version']\n    PROPOSAL_FIELDS = ['results', 'version', 'external_data']\n    API = 'http://ec2-52-25-205-214.us-west-2.compute.amazonaws.com/challenge19/api.py'"
        },
        {
            "comment": "Initializing the class with ground truth and proposal filenames as required, setting default parameters, and checking if both files exist.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":30-53",
            "content": "    def __init__(self,\n                 ground_truth_filename=None,\n                 proposal_filename=None,\n                 ground_truth_fields=GROUND_TRUTH_FIELDS,\n                 proposal_fields=PROPOSAL_FIELDS,\n                 tiou_thresholds=np.linspace(0.5, 0.95, 10),\n                 max_avg_nr_proposals=None,\n                 subset='validation',\n                 verbose=False,\n                 check_status=True):\n        if not ground_truth_filename:\n            raise IOError('Please input a valid ground truth file.')\n        if not proposal_filename:\n            raise IOError('Please input a valid proposal file.')\n        self.subset = subset\n        self.tiou_thresholds = tiou_thresholds\n        self.max_avg_nr_proposals = max_avg_nr_proposals\n        self.verbose = verbose\n        self.gt_fields = ground_truth_fields\n        self.pred_fields = proposal_fields\n        self.recall = None\n        self.avg_recall = None\n        self.proposals_per_video = None\n        self.check_status = check_status"
        },
        {
            "comment": "This code retrieves blocked videos from a server, imports ground truth and proposals, and checks if the ground truth file is well formatted. It also prints information about the number of ground truth instances and proposals, as well as the fixed threshold for tiou score.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":54-76",
            "content": "        # Retrieve blocked videos from server.\n        if self.check_status:\n            self.blocked_videos = self.get_blocked_videos()\n        else:\n            self.blocked_videos = list()\n        # Import ground truth and proposals.\n        self.ground_truth, self.activity_index = self._import_ground_truth(\n            ground_truth_filename)\n        self.proposal = self._import_proposal(proposal_filename)\n        if self.verbose:\n            print('[INIT] Loaded annotations from {} subset.'.format(subset))\n            nr_gt = len(self.ground_truth)\n            print('\\tNumber of ground truth instances: {}'.format(nr_gt))\n            nr_pred = len(self.proposal)\n            print('\\tNumber of proposals: {}'.format(nr_pred))\n            print('\\tFixed threshold for tiou score: {}'.format(\n                self.tiou_thresholds))\n    def _import_ground_truth(self, ground_truth_filename):\n        \"\"\"\n        Reads ground truth file, checks if it is well formatted, and returns\n        the ground truth instances and the activity classes."
        },
        {
            "comment": "This function reads a ground truth JSON file and returns a DataFrame containing the instances. It also returns a dictionary of class indices. The function checks if the input file has the required fields, skips videos not in the specified subset, and ignores blocked videos. If an activity label is not found in the activity_index, it adds it to the index and increments the counter.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":78-101",
            "content": "        Parameters:\n        ground_truth_filename (str): full path to the ground truth json file.\n        Returns:\n        ground_truth (df): Data frame containing the ground truth instances.\n        activity_index (dict): Dictionary containing class index.\n        \"\"\"\n        with open(ground_truth_filename, 'r') as fobj:\n            data = json.load(fobj)\n        # Checking format\n        if not all([field in data.keys() for field in self.gt_fields]):\n            raise IOError('Please input a valid ground truth file.')\n        # Read ground truth data.\n        activity_index, cidx = {}, 0\n        video_lst, t_start_lst, t_end_lst, label_lst = [], [], [], []\n        for videoid, v in data['database'].items():\n            if self.subset != v['subset']:\n                continue\n            if videoid in self.blocked_videos:\n                continue\n            for ann in v['annotations']:\n                if ann['label'] not in activity_index:\n                    activity_index[ann['label']] = cidx\n                    cidx += 1"
        },
        {
            "comment": "The code reads a proposal file, checks its format and returns proposal instances in the form of a data frame. It also generates ground truth data by appending video IDs, start and end times, and labels to lists before creating a DataFrame. The function takes a string as input for the full path to the proposal JSON file and returns a data frame containing the proposal instances.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":102-129",
            "content": "                video_lst.append(videoid)\n                t_start_lst.append(float(ann['segment'][0]))\n                t_end_lst.append(float(ann['segment'][1]))\n                label_lst.append(activity_index[ann['label']])\n        ground_truth = pd.DataFrame({\n            'video-id': video_lst,\n            't-start': t_start_lst,\n            't-end': t_end_lst,\n            'label': label_lst\n        })\n        return ground_truth, activity_index\n    def _import_proposal(self, proposal_filename):\n        \"\"\"\n        Reads proposal file, checks if it is well formatted, and returns\n        the proposal instances.\n        Parameters:\n        proposal_filename (str): Full path to the proposal json file.\n        Returns:\n        proposal (df): Data frame containing the proposal instances.\n        \"\"\"\n        with open(proposal_filename, 'r') as fobj:\n            data = json.load(fobj)\n        # Checking format...\n        if not all([field in data.keys() for field in self.pred_fields]):\n            raise IOError('Please input a valid proposal file.')"
        },
        {
            "comment": "The code reads predictions from a data source, extracts relevant information (video IDs, start and end timestamps, scores), stores them in a DataFrame, and defines two functions: one for evaluating proposal files by computing area under the average recall vs average number of proposals per video curve. The evaluation function calls another function to compute this metric using ground truth data and the stored proposal data.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":131-157",
            "content": "        # Read predictions.\n        video_lst, t_start_lst, t_end_lst = [], [], []\n        score_lst = []\n        for videoid, v in data['results'].items():\n            if videoid in self.blocked_videos:\n                continue\n            for result in v:\n                video_lst.append(videoid)\n                t_start_lst.append(float(result['segment'][0]))\n                t_end_lst.append(float(result['segment'][1]))\n                score_lst.append(result['score'])\n        proposal = pd.DataFrame({\n            'video-id': video_lst,\n            't-start': t_start_lst,\n            't-end': t_end_lst,\n            'score': score_lst\n        })\n        return proposal\n    def evaluate(self):\n        \"\"\"\n        Evaluates a proposal file. To measure the performance of a\n        method for the proposal task, we computes the area under the\n        average recall vs average number of proposals per video curve.\n        \"\"\"\n        recall, avg_recall, proposals_per_video = self.average_recall_vs_avg_nr_proposals(\n            self.ground_truth,"
        },
        {
            "comment": "Calculates the area under the curve of recall vs average number of proposals for ActivityNet proposal task, writes result to file and stores recall, average recall, and proposals per video in class attributes.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":158-181",
            "content": "            self.proposal,\n            max_avg_nr_proposals=self.max_avg_nr_proposals,\n            tiou_thresholds=self.tiou_thresholds)\n        area_under_curve = np.trapz(avg_recall, proposals_per_video)\n        if self.verbose:\n            print('[RESULTS] Performance on ActivityNet proposal task.')\n            with open(\"data/bmn/BMN_Test_results/auc_result.txt\",\n                      \"a\") as text_file:\n                text_file.write(\n                    '\\tArea Under the AR vs AN curve: {}% \\n'.format(\n                        100. * float(area_under_curve) /\n                        proposals_per_video[-1]))\n            print('\\tArea Under the AR vs AN curve: {}%'.format(\n                100. * float(area_under_curve) / proposals_per_video[-1]))\n        self.recall = recall\n        self.avg_recall = avg_recall\n        self.proposals_per_video = proposals_per_video\n    def average_recall_vs_avg_nr_proposals(self,\n                                           ground_truth,\n                                           proposals,"
        },
        {
            "comment": "This code defines a function that computes average recall for given average number of proposals per video. It takes ground truth and proposal data frames as input, along with optional tiou_thresholds. It returns recall and average_recall arrays.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":182-201",
            "content": "                                           max_avg_nr_proposals=None,\n                                           tiou_thresholds=np.linspace(\n                                               0.5, 0.95, 10)):\n        \"\"\"\n        Computes the average recall given an average number of\n        proposals per video.\n        Parameters:\n        ground_truth(df): Data frame containing the ground truth instances.\n            Required fields: ['video-id', 't-start', 't-end']\n        proposal(df): Data frame containing the proposal instances.\n            Required fields: ['video-id, 't-start', 't-end', 'score']\n        tiou_thresholds(1d-array | optional): array with tiou thresholds.\n        Returns:\n        recall(2d-array): recall[i,j] is recall at ith tiou threshold at the jth\n            average number of average number of proposals per video.\n        average_recall(1d-array): recall averaged over a list of tiou threshold.\n            This is equivalent to recall.mean(axis=0).\n        proposals_per_video(1d-array): average number of proposals per video."
        },
        {
            "comment": "This code retrieves a list of videos, calculates the maximum average number of proposals per video, groups proposals and ground truth by video ID, and then computes Tiou scores between ground-truth instances and retrieved proposals for each video.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":202-230",
            "content": "        \"\"\"\n        # Get list of videos.\n        video_lst = ground_truth['video-id'].unique()\n        if not max_avg_nr_proposals:\n            max_avg_nr_proposals = float(\n                proposals.shape[0]) / video_lst.shape[0]\n        ratio = max_avg_nr_proposals * float(\n            video_lst.shape[0]) / proposals.shape[0]\n        # Adaptation to query faster\n        ground_truth_gbvn = ground_truth.groupby('video-id')\n        proposals_gbvn = proposals.groupby('video-id')\n        # For each video, computes tiou scores among the retrieved proposals.\n        score_lst = []\n        total_nr_proposals = 0\n        for videoid in video_lst:\n            # Get ground-truth instances associated to this video.\n            ground_truth_videoid = ground_truth_gbvn.get_group(videoid)\n            this_video_ground_truth = ground_truth_videoid.loc[:, [\n                't-start', 't-end'\n            ]].values\n            # Get proposals for this video.\n            try:\n                proposals_videoid = proposals_gbvn.get_group(videoid)"
        },
        {
            "comment": "This code block is part of a function that handles exceptions when dealing with video proposals and ground truth. It appends a zero matrix to the score list if there are no video proposals or ground truth data for the current video. If there are proposals, it sorts them by score in descending order and expands dimensions as necessary before proceeding.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":231-254",
            "content": "            except:\n                n = this_video_ground_truth.shape[0]\n                score_lst.append(np.zeros((n, 1)))\n                continue\n            this_video_proposals = proposals_videoid.loc[:,\n                                                         ['t-start', 't-end'\n                                                          ]].values\n            if this_video_proposals.shape[0] == 0:\n                n = this_video_ground_truth.shape[0]\n                score_lst.append(np.zeros((n, 1)))\n                continue\n            # Sort proposals by score.\n            sort_idx = proposals_videoid['score'].argsort()[::-1]\n            this_video_proposals = this_video_proposals[sort_idx, :]\n            if this_video_proposals.ndim != 2:\n                this_video_proposals = np.expand_dims(this_video_proposals,\n                                                      axis=0)\n            if this_video_ground_truth.ndim != 2:\n                this_video_ground_truth = np.expand_dims(\n                    this_video_ground_truth, axis=0)"
        },
        {
            "comment": "This code calculates average recall for a set of video proposals. It sets the number of proposals based on a ratio, computes IOU scores, and stores the results in lists. The average recall is computed using a predetermined maximum number of proposals and the total number of proposals retrieved, considering the variable length of videos.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":256-277",
            "content": "            nr_proposals = np.minimum(\n                int(this_video_proposals.shape[0] * ratio),\n                this_video_proposals.shape[0])\n            total_nr_proposals += nr_proposals\n            this_video_proposals = this_video_proposals[:nr_proposals, :]\n            # Compute tiou scores.\n            tiou = self.wrapper_segment_iou(this_video_proposals,\n                                            this_video_ground_truth)\n            score_lst.append(tiou)\n        # Given that the length of the videos is really varied, we\n        # compute the number of proposals in terms of a ratio of the total\n        # proposals retrieved, i.e. average recall at a percentage of proposals\n        # retrieved per video.\n        # Computes average recall.\n        pcn_lst = np.arange(1, 101) / 100.0 * (max_avg_nr_proposals * float(\n            video_lst.shape[0]) / total_nr_proposals)\n        matches = np.empty((video_lst.shape[0], pcn_lst.shape[0]))\n        positives = np.empty(video_lst.shape[0])\n        recall = np.empty((tiou_thresholds.shape[0], pcn_lst.shape[0]))"
        },
        {
            "comment": "Code iterates over different tiou thresholds and positive scores, computing the number of true positives based on threshold and percentage of proposals. It calculates matches per video and computes recall for each set of matches.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":278-297",
            "content": "        # Iterates over each tiou threshold.\n        for ridx, tiou in enumerate(tiou_thresholds):\n            # Inspect positives retrieved per video at different\n            # number of proposals (percentage of the total retrieved).\n            for i, score in enumerate(score_lst):\n                # Total positives per video.\n                positives[i] = score.shape[0]\n                # Find proposals that satisfies minimum tiou threshold.\n                true_positives_tiou = score >= tiou\n                # Get number of proposals as a percentage of total retrieved.\n                pcn_proposals = np.minimum(\n                    (score.shape[1] * pcn_lst).astype(int), score.shape[1])\n                for j, nr_proposals in enumerate(pcn_proposals):\n                    # Compute the number of matches for each percentage of the proposals\n                    matches[i, j] = np.count_nonzero(\n                        (true_positives_tiou[:, :nr_proposals]).sum(axis=1))\n            # Computes recall given the set of matches per video."
        },
        {
            "comment": "The function calculates recall and average recall for detected objects in videos, based on the number of true positives and total proposals. It also returns the average number of proposals per video. The second function retrieves a list of blocked videos from an API. The third function computes intersection over union between target and candidate segments efficiently.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":298-323",
            "content": "            recall[ridx, :] = matches.sum(axis=0) / positives.sum()\n        # Recall is averaged.\n        avg_recall = recall.mean(axis=0)\n        # Get the average number of proposals per video.\n        proposals_per_video = pcn_lst * (float(total_nr_proposals) /\n                                         video_lst.shape[0])\n        return recall, avg_recall, proposals_per_video\n    def get_blocked_videos(self, api=API):\n        api_url = '{}?action=get_blocked'.format(api)\n        req = urllib2.Request(api_url)\n        response = urllib2.urlopen(req)\n        return json.loads(response.read())\n    def wrapper_segment_iou(self, target_segments, candidate_segments):\n        \"\"\"\n        Compute intersection over union btw segments\n        Parameters:\n        target_segments(nd-array): 2-dim array in format [m x 2:=[init, end]]\n        candidate_segments(nd-array): 2-dim array in format [n x 2:=[init, end]]\n        Returns:\n        tiou(nd-array): 2-dim array [n x m] with IOU ratio.\n        Note: It assumes that candidate-segments are more scarce that target-segments"
        },
        {
            "comment": "This function calculates the temporal intersection over union (TIOU) between a target segment and multiple candidate segments. If the dimensions of arguments are not 2, it raises a ValueError. It loops through each candidate segment, compares their starting and ending times with the target segment's times using np.maximum, and stores the TIOU results in a 2D array.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":324-348",
            "content": "        \"\"\"\n        if candidate_segments.ndim != 2 or target_segments.ndim != 2:\n            raise ValueError('Dimension of arguments is incorrect')\n        n, m = candidate_segments.shape[0], target_segments.shape[0]\n        tiou = np.empty((n, m))\n        for i in range(m):\n            tiou[:, i] = self.segment_iou(target_segments[i, :],\n                                          candidate_segments)\n        return tiou\n    def segment_iou(self, target_segment, candidate_segments):\n        \"\"\"\n        Compute the temporal intersection over union between a\n        target segment and all the test segments.\n        Parameters:\n        target_segment(1d-array): Temporal target segment containing [starting, ending] times.\n        candidate_segments(2d-array): Temporal candidate segments containing N x [starting, ending] times.\n        Returns:\n        tiou(1d-array): Temporal intersection over union score of the N's candidate segments.\n        \"\"\"\n        tt1 = np.maximum(target_segment[0], candidate_segments[:, 0])"
        },
        {
            "comment": "Computes intersection over union (IoU) of two segments by finding the minimum endpoints, calculating intersection and union, and dividing intersection by union.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/metrics/ActivityNet/anet_prop.py\":349-358",
            "content": "        tt2 = np.minimum(target_segment[1], candidate_segments[:, 1])\n        # Intersection including Non-negative overlap score.\n        segments_intersection = (tt2 - tt1).clip(0)\n        # Segment union.\n        segments_union = (candidate_segments[:, 1] - candidate_segments[:, 0]) \\\n                         + (target_segment[1] - target_segment[0]) - segments_intersection\n        # Compute overlap as the ratio of the intersection\n        # over union of two segments.\n        tIoU = segments_intersection.astype(float) / segments_union\n        return tIoU"
        }
    ]
}