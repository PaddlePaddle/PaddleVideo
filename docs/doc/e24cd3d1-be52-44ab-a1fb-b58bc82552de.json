{
    "summary": "This code performs object detection in computer vision tasks and evaluates table tennis action predictions, computing evaluation metrics to optimize F1 scores. The best performing combination is stored for future use.",
    "details": [
        {
            "comment": "This code is importing necessary libraries and defining global variables. It loads ground truth data from specified labels for different datasets and evaluation splits, setting frame per second (fps) values as well. It uses these loaded gts to calculate proposal-box related information based on ground truth sequence.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":0-40",
            "content": "\"\"\"\nget instance for lstm\n\u6839\u636egts\u8ba1\u7b97\u6bcf\u4e2aproposal_bmn\u7684iou\u3001ioa\u3001label\u7b49\u4fe1\u606f\n\"\"\"\nimport os\nimport sys\nimport json\nimport random\nimport pickle\nimport numpy as np\nimport io\nsys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')\ndataset = \"/home/work/datasets\"\nlabel_index_file = './configs/index_label_football_7.json'\neval_datasets = ['EuroCup2016']\nlabel_files = {\n    'train': 'label_cls8_train.json',\n    'validation': 'label_cls8_val.json'\n}\nglobal fps, mode\nlabel_index = json.load(open(label_index_file, 'rb'))\ndef load_gts():\n    global fps\n    gts_data = {'fps': 0, 'gts': {}}\n    for eval_data in eval_datasets:\n        for item, value in label_files.items():\n            label_file = '{}/{}/{}'.format(dataset, eval_data, value)\n            gts = json.load(open(label_file, 'rb'))\n            gts_data['fps'] = gts['fps']\n            fps = gts['fps']\n            for gt in gts['gts']:\n                gt['mode'] = item\n                basename = '{}/{}/mp4/{}'.format(dataset, eval_data,\n                                                 os.path.basename(gt['url']))"
        },
        {
            "comment": "This code defines a function to compute the intersection of union (IoU) between two intervals, and another function that converts a list of proposals into final detections based on a score threshold. The computed IoU is used to filter out unwanted proposals, and only keep those with high confidence scores. This can be useful for object detection tasks in computer vision applications.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":41-72",
            "content": "                gts_data['gts'][basename] = gt\n    return gts_data['gts']\ndef computeIoU(e1, e2):\n    \"\"\"\n    clc iou and ioa\n    \"\"\"\n    if not (e1['label'] == e2['label'] and e1['basename'] == e2['basename']):\n        return 0.\n    area1 = e1[\"end\"] - e1[\"start\"]\n    area2 = e2[\"end\"] - e2[\"start\"]\n    x1 = np.maximum(e1[\"start\"], e2[\"start\"])\n    x2 = np.minimum(e1[\"end\"], e2[\"end\"])\n    inter = np.maximum(0.0, x2 - x1)\n    iou = 0.0 if (area1 + area2 -\n                  inter) == 0 else inter * 1.0 / (area1 + area2 - inter)\n    if not mode == 'proposal':\n        iou = 0.0 if area2 == 0 else inter * 1.0 / area2\n    return iou\ndef convert_proposal(boxes, basename, score_threshold=0.01):\n    boxes = sorted(boxes, key=lambda x: float(x['score']), reverse=True)\n    res = []\n    for box in boxes:\n        if not float(box['score']) >= score_threshold:\n            continue\n        res.append({\n            'basename': basename,\n            'start': int(float(box['start']) / fps),\n            'end': int(float(box['end']) / fps),"
        },
        {
            "comment": "The code contains three functions: 'convert_classify', 'convert_groundtruth', and 'convert_time_to_frame'. The 'convert_classify' function sorts boxes based on their classify and iou scores, then appends qualified boxes to a result list. 'convert_groundtruth' appends box labels to the result list based on the phase parameter. The 'convert_time_to_frame' function converts time strings to frames.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":73-107",
            "content": "            'label': 0\n        })\n    return res\ndef convert_classify(boxes, basename, iou_threshold, score_threshold):\n    boxes = sorted(boxes,\n                   key=lambda x:\n                   (float(x['classify_score']), float(x['iou_score'])),\n                   reverse=True)\n    def convert_time_to_frame(time_type):\n        return int(time_type)\n        h, m, s = time_type.split(':')\n        return int(h) * 3600 + int(m) * 60 + int(s)\n    res = []\n    for box in boxes:\n        if not (box['iou_score'] >= iou_threshold\n                and box['classify_score'] >= score_threshold):\n            continue\n        res.append({\n            'basename': basename,\n            'start': convert_time_to_frame(box['start_time']),\n            'end': convert_time_to_frame(box['end_time']),\n            'label': box['label_id']\n        })\n    return res\ndef convert_groundtruth(boxes, basename, phase=None):\n    res = []\n    for box in boxes:\n        for item in box['label_ids']:\n            label = 0 if phase == 'proposal' else item"
        },
        {
            "comment": "This code contains three functions: \"res.append\" appends a dictionary to a list with information about video frames, \"print_head\" prints headers for table output, and \"print_result\" prints the evaluation results of the model in a formatted way. The code is likely part of an image classification or object detection algorithm that evaluates the performance of the model on a set of video frames.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":108-141",
            "content": "            res.append({\n                'basename': basename,\n                'start': box['start_id'],\n                'end': box['end_id'],\n                'label': label\n            })\n    return res\ndef print_head(iou):\n    print(\"\\nioa = {:.1f}\".format(iou))\n    res_str = ''\n    for item in ['label_name']:\n        res_str += '{:<12s}'.format(item)\n    for item in [\n            'label_id', 'precision', 'recall', 'hit_prop', 'num_prop',\n            'hit_gts', 'num_gts'\n    ]:\n        res_str += '{:<10s}'.format(item)\n    print(res_str)\ndef print_result(res_dict, label='avg'):\n    if label == 'avg':\n        res_str = '{:<22s}'.format(str(label))\n    else:\n        res_str = '{0:{2}<6s}{1:<10s}'.format(label_index[str(label)],\n                                              str(label), chr(12288))\n    for item in ['prec', 'recall']:\n        res_str += '{:<10.4f}'.format(res_dict[item])\n    for item in ['hit_prop', 'num_prop', 'hit_gts', 'num_gts']:\n        res_str += '{:<10d}'.format(res_dict[item])\n    print(res_str)"
        },
        {
            "comment": "Function `evaluation` takes in lists of predicted boxes (`res_boxes`) and ground truth boxes (`gts_boxes`), along with IOU and label ranges. It computes intersection over union (IoU) between each predicted box and ground truth box, creating a map of IoUs. The map is then reshaped into a 2D array for easier computation. The function calculates the maximum IoU per row in the map, and the index of this maximum value. It also loops through label and IOU ranges to calculate various statistics for subsets of labels and IOU thresholds. If `show_sub` is True, it prints a header indicating the current subset being evaluated. If there are no predicted boxes for a particular label in the current iteration, the function skips that iteration without computing results.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":144-165",
            "content": "def evaluation(res_boxes, gts_boxes, label_range, iou_range, show_sub=False):\n    iou_map = [computeIoU(resId, gtsId) for resId in res_boxes \\\n                                        for gtsId in gts_boxes]\n    iou_map = np.array(iou_map).reshape((len(res_boxes), len(gts_boxes)))\n    hit_map_prop_total = np.max(iou_map, axis=1)\n    hit_map_index_total = np.argmax(iou_map, axis=1)\n    res_dict = ['hit_prop', 'num_prop', 'hit_gts', 'num_gts']\n    for iou_threshold in iou_range:\n        if show_sub:\n            print_head(iou_threshold)\n        iou_prop = np.array([k >= iou_threshold for k in hit_map_prop_total])\n        average_results = {}\n        for label_id in label_range:\n            sub_results = {}\n            label_prop = np.array([k['label'] == label_id for k in res_boxes])\n            label_gts = np.array([k['label'] == label_id for k in gts_boxes])\n            sub_results['num_prop'] = sum(label_prop)\n            sub_results['num_gts'] = sum(label_gts)\n            if sub_results['num_prop'] == 0:"
        },
        {
            "comment": "The code calculates precision and recall scores for a set of results. It checks if there are any hits, then calculates the hit properties and ground truths. If show_sub is True, it prints the subresults for each label. The average results are also updated based on these calculations.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":166-185",
            "content": "                hit_prop_index = []\n            else:\n                hit_prop_index = label_prop & iou_prop\n            sub_results['hit_prop'] = sum(hit_prop_index)\n            sub_results['hit_gts'] = len(\n                set(hit_map_index_total[hit_prop_index]))\n            sub_results['prec'] = 0.0 if sub_results['num_prop'] == 0 \\\n                                      else sub_results['hit_prop'] * 1.0 / sub_results['num_prop']\n            sub_results['recall'] = 0.0 if sub_results['num_gts'] == 0 \\\n                                        else sub_results['hit_gts'] * 1.0 / sub_results['num_gts']\n            if show_sub:\n                print_result(sub_results, label=label_id)\n            for item in res_dict:\n                if not item in average_results:\n                    average_results[item] = 0\n                average_results[item] += sub_results[item]\n        if len(label_range) == 1:  # proposal \u4e0d\u9700\u8981\u8f93\u51faaverage\u503c\n            continue\n        average_results['prec'] = 0.0 if average_results['num_prop'] == 0 \\"
        },
        {
            "comment": "This code calculates average precision and recall for a table tennis prediction model. It returns an F1 score, considers IOU and score thresholds, handles different phases, and optionally prints the results.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":186-209",
            "content": "                                      else average_results['hit_prop'] * 1.0 / average_results['num_prop']\n        average_results['recall'] = 0.0 if average_results['num_gts'] == 0 \\\n                                        else average_results['hit_gts'] * 1.0 / average_results['num_gts']\n        if show_sub:\n            print_result(average_results)\n        average_results['F1'] = 0.0 if (average_results['prec'] + average_results['recall'] == 0) \\\n                                    else 2 * average_results['prec'] * average_results['recall'] / \\\n                                            (average_results['prec'] + average_results['recall'])\n        return average_results\ndef get_eval_results(predicts,\n                     gts_data,\n                     phase,\n                     iou_threshold=0.3,\n                     score_threshold=0.3,\n                     show_sub=False):\n    global mode\n    mode = phase\n    res_boxes = []\n    gts_boxes = []\n    for ped_data in predicts:\n        basename = ped_data['video_name']"
        },
        {
            "comment": "This code evaluates the performance of a video analysis model for table tennis. It determines if the data is an evaluation dataset and then extends the results and ground truth boxes based on the phase (proposal or classification). It sets label and iou thresholds for evaluation and finally calculates the evaluation results.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":211-238",
            "content": "        # eval sub data\n        such_eval = False\n        for eval_name in eval_datasets:\n            if eval_name in basename:\n                such_eval = True\n                break\n        if not such_eval:\n            continue\n        gts = gts_data[basename]['actions']\n        if phase == 'proposal':\n            res_boxes.extend(\n                convert_proposal(ped_data['bmn_results'], basename,\n                                 score_threshold))\n            gts_boxes.extend(\n                convert_groundtruth(gts, basename, phase='proposal'))\n            label_range = [0]\n            iou_range = np.arange(0.1, 1, 0.1)\n        else:\n            res_boxes.extend(\n                convert_classify(ped_data['action_results'], basename,\n                                 iou_threshold, score_threshold))\n            gts_boxes.extend(convert_groundtruth(gts, basename))\n            label_range = range(1, len(label_index))\n            iou_range = np.arange(0.5, 0.6, 0.1)\n    eval_results = evaluation(res_boxes,\n                              gts_boxes,"
        },
        {
            "comment": "This code evaluates the performance of table tennis action predictions. It takes in predicted results and ground truth data, then computes evaluation metrics for different IOU and score thresholds. The best performing combination is stored for future reference.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":239-269",
            "content": "                              label_range,\n                              iou_range,\n                              show_sub=show_sub)\n    return eval_results\nif __name__ == \"__main__\":\n    result_file = sys.argv[1]\n    predicts = json.load(open(result_file, 'r', encoding='utf-8'))\n    gts_data = load_gts()\n    get_eval_results(predicts,\n                     gts_data,\n                     'proposal',\n                     score_threshold=0.03,\n                     show_sub=True)\n    #get_eval_results(predicts, gts_data, 'actions')\n    best_F1 = -0.1\n    best_res = {}\n    best_iou_threshold = 0.\n    best_score_threshold = 0.\n    for iou_threshold in np.arange(0.1, 0.9, 0.1):\n        for score_threshold in np.arange(0.1, 1, 0.1):\n            avg_res = get_eval_results(predicts,\n                                       gts_data,\n                                       'actions',\n                                       iou_threshold=iou_threshold,\n                                       score_threshold=score_threshold,\n                                       show_sub=False)"
        },
        {
            "comment": "This code snippet is optimizing the iou and score thresholds for better F1 scores, then printing them and using the best values to get evaluation results.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/predict/eval.py\":270-286",
            "content": "            if best_F1 < avg_res['F1']:\n                best_F1 = avg_res['F1']\n                best_res = avg_res\n                best_iou_threshold = iou_threshold\n                best_score_threshold = score_threshold\n    print(\"best iou threshold = {:.1f}\".format(best_iou_threshold))\n    print(\"best score threshold = {:.1f}\".format(best_score_threshold))\n    print('best F1 score = {:.4f}'.format(best_F1))\n    print_head(0.5)\n    print_result(best_res)\n    get_eval_results(predicts,\n                     gts_data,\n                     'actions',\n                     iou_threshold=best_iou_threshold,\n                     score_threshold=best_score_threshold,\n                     show_sub=True)"
        }
    ]
}