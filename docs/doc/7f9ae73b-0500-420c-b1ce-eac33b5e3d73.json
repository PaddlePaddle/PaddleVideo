{
    "summary": "The TSMINFReader class is a specialized data reader for JPG video datasets, utilizing threading for image preprocessing and data augmentation. It improves action detection models by manipulating football game images via functions like \"crop_and_resize\", \"group_random_crop\", and \"group_random_flip\" to fit target size and apply random crop sizes for augmentation.",
    "details": [
        {
            "comment": "The code defines a class called TSMINFReader that inherits from DataReader. It is a data reader for video datasets in the JPG format and can be used in specific modes with different configurations. The class takes parameters such as name, mode, cfg, and material (optional) to initialize its instance.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":0-37",
            "content": "\"\"\"\ntsn frame reader\n\"\"\"\n#  Copyright (c) 2019 PaddlePaddle Authors. All Rights Reserve.\n#\n#Licensed under the Apache License, Version 2.0 (the \"License\");\n#you may not use this file except in compliance with the License.\n#You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n#Unless required by applicable law or agreed to in writing, software\n#distributed under the License is distributed on an \"AS IS\" BASIS,\n#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#See the License for the specific language governing permissions and\n#limitations under the License.\nimport os\nimport sys\nimport random\nimport functools\nimport concurrent.futures\nimport multiprocessing\nimport numpy as np\nimport paddle\nfrom PIL import Image, ImageEnhance\nfrom .reader_utils import DataReader\nclass TSMINFReader(DataReader):\n    \"\"\"\n    Data reader for video dataset of jpg folder.\n    \"\"\"\n    def __init__(self, name, mode, cfg, material=None):\n        super(TSMINFReader, self).__init__(name, mode, cfg)"
        },
        {
            "comment": "This code initializes the TSN video reader by setting various attributes based on provided configuration (name) and then calls a function to create the reader object with specified parameters. It also sets image mean and std values for normalization, and stores the material type.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":38-63",
            "content": "        name = name.upper()\n        self.seg_num        = cfg[name]['seg_num']\n        self.seglen         = cfg[name]['seglen']\n        self.short_size     = cfg[name]['short_size']\n        self.target_size    = cfg[name]['target_size']\n        self.batch_size     = cfg[name]['batch_size']\n        self.reader_threads = cfg[name]['reader_threads']\n        self.buf_size       = cfg[name]['buf_size']\n        self.video_path     = cfg[name]['frame_list']\n        self.img_mean       = np.array(cfg[name]['image_mean']).reshape([3, 1, 1]).astype(np.float32)\n        self.img_std        = np.array(cfg[name]['image_std']).reshape([3, 1, 1]).astype(np.float32)\n        self.material = material\n    def create_reader(self):\n        \"\"\"\n        batch loader for TSN\n        \"\"\"\n        _reader = self._inference_reader_creator_longvideo(\n                self.video_path,\n                self.mode,\n                seg_num=self.seg_num,\n                seglen=self.seglen,\n                short_size=self.short_size,\n                target_size=self.target_size,"
        },
        {
            "comment": "This code defines a class with an image batch reader for inference on video data. The reader function reads images from the specified video path, applying mean and standard deviation normalization. It also sets the number of threads, buffer size, and creates a batch generator using _batch_reader method.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":64-96",
            "content": "                img_mean=self.img_mean,\n                img_std=self.img_std,\n                num_threads = self.reader_threads,\n                buf_size = self.buf_size)\n        def _batch_reader():\n            batch_out = []\n            for imgs, label in _reader():\n                if imgs is None:\n                    continue\n                batch_out.append((imgs, label))\n                if len(batch_out) == self.batch_size:\n                    yield batch_out\n                    batch_out = []\n            if len(batch_out) > 1:\n                yield batch_out[:-1]\n        return _batch_reader\n    def _inference_reader_creator_longvideo(self, video_path, mode, seg_num, seglen,\n                                  short_size, target_size, img_mean, img_std, num_threads, buf_size):\n        \"\"\"\n        inference reader for video\n        \"\"\"\n        def reader():\n            \"\"\"\n            reader\n            \"\"\"\n            def image_buf(image_id_path_buf):\n                \"\"\"\n                image_buf reader\n                \"\"\"  "
        },
        {
            "comment": "The code segment is responsible for reading images from a video file in chunks using multiple threads. It opens each image, converts it to RGB format and stores them in an array. The code handles exceptions for opening bad or missing images and uses the ThreadPoolExecutor class from concurrent futures module to execute operations asynchronously with maximum worker threads specified. Finally, it creates a list of images from the segments and adds a fault-tolerant mechanism to handle bad images.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":97-118",
            "content": "                try:\n                    img_path = image_id_path_buf[1]\n                    img = Image.open(img_path).convert(\"RGB\")\n                    image_id_path_buf[2] = img\n                except:\n                    image_id_path_buf[2] = None\n            frame_len = len(video_path)\n            read_thread_num = seg_num\n            for i in range(0, frame_len, read_thread_num):\n                image_list_part = video_path[i: i + read_thread_num]\n                image_id_path_buf_list = []\n                for k in range(len(image_list_part)):\n                    image_id_path_buf_list.append([k, image_list_part[k], None])\n                with concurrent.futures.ThreadPoolExecutor(max_workers=read_thread_num) as executor:\n                    executor.map(lambda image_id_path_buf: image_buf(image_id_path_buf), image_id_path_buf_list)\n                imgs_seg_list = [x[2] for x in image_id_path_buf_list]\n                # add the fault-tolerant for bad image\n                for k in range(len(image_id_path_buf_list)):"
        },
        {
            "comment": "This code aims to read image data and perform inference by transforming the images. It appends missing image buffers to imgs_seg_list, handles reading errors, and yields the complete list of transformed images. The imgs_transform function performs further transformations on the input images based on provided parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":119-140",
            "content": "                    img_buf = image_id_path_buf_list[k][2]\n                    pad_id = 1\n                    while pad_id < seg_num and img_buf is None:\n                        img_buf = imgs_seg_list[(k + pad_id)%seg_num][2]\n                    if img_buf is None:\n                        logger.info(\"read img erro from {} to {}\".format(i, i + read_thread_num))\n                        exit(0)\n                    else:\n                        imgs_seg_list[k] = img_buf\n                for pad_id in range(len(imgs_seg_list), seg_num):\n                    imgs_seg_list.append(imgs_seg_list[-1])\n                yield imgs_seg_list      \n        def inference_imgs_transform(imgs_list, mode, seg_num, seglen, short_size,\\\n                                    target_size, img_mean, img_std):\n            \"\"\"\n            inference_imgs_transform\n            \"\"\" \n            imgs_ret = imgs_transform(imgs_list, mode, seg_num, seglen, short_size,\n                        target_size, img_mean, img_std)\n            label_ret = 0"
        },
        {
            "comment": "This code defines a function `imgs_transform` which performs various image transformations on input images based on the given mode. It groups images by scale, crops them randomly if in training mode (using TSM or center crop otherwise), and applies horizontal flips. The function returns the transformed images as a numpy array.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":142-179",
            "content": "            return imgs_ret, label_ret\n        mapper = functools.partial(\n            inference_imgs_transform,\n            mode=mode,\n            seg_num=seg_num,\n            seglen=seglen,\n            short_size=short_size,\n            target_size=target_size,\n            img_mean=img_mean,\n            img_std=img_std)\n        return paddle.reader.xmap_readers(mapper, reader, num_threads, buf_size, order=True)\ndef imgs_transform(imgs,\n                   mode,\n                   seg_num,\n                   seglen,\n                   short_size,\n                   target_size,\n                   img_mean,\n                   img_std,\n                   name=''):\n    \"\"\"\n    imgs_transform\n    \"\"\"\n    imgs = group_scale(imgs, short_size)\n    if mode == 'train':\n        if name == \"TSM\":\n            imgs = group_multi_scale_crop(imgs, short_size)\n        imgs = group_random_crop(imgs, target_size)\n        imgs = group_random_flip(imgs)\n    else:\n        imgs = group_center_crop(imgs, target_size)\n    np_imgs = (np.array(imgs[0]).astype('float32').transpose("
        },
        {
            "comment": "This code is responsible for loading and preprocessing images for an action detection model in a football game. It resizes, normalizes, and concatenates the images, then applies data augmentation techniques to create a more diverse dataset for training the model. The `group_multi_scale_crop` function generates crop offsets and resizes the images with different scales, providing a robust dataset for improving the model's performance in recognizing various actions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":180-211",
            "content": "        (2, 0, 1))).reshape(1, 3, target_size, target_size) / 255\n    for i in range(len(imgs) - 1):\n        img = (np.array(imgs[i + 1]).astype('float32').transpose(\n            (2, 0, 1))).reshape(1, 3, target_size, target_size) / 255\n        np_imgs = np.concatenate((np_imgs, img))\n    imgs = np_imgs\n    imgs -= img_mean\n    imgs /= img_std\n    imgs = np.reshape(imgs, (seg_num, seglen * 3, target_size, target_size))\n    return imgs\ndef group_multi_scale_crop(img_group, target_size, scales=None, \\\n        max_distort=1, fix_crop=True, more_fix_crop=True):\n    \"\"\"\n    group_multi_scale_crop\n    \"\"\"\n    scales = scales if scales is not None else [1, .875, .75, .66]\n    input_size = [target_size, target_size]\n    im_size = img_group[0].size\n    # get random crop offset\n    def _sample_crop_size(im_size):\n        \"\"\"\n         _sample_crop_size\n        \"\"\"\n        image_w, image_h = im_size[0], im_size[1]\n        base_size = min(image_w, image_h)\n        crop_sizes = [int(base_size * x) for x in scales]\n        crop_h = ["
        },
        {
            "comment": "This code calculates crop sizes, generates pairs of crop heights and widths, and randomly selects a pair to use for cropping an image. If the 'fix_crop' parameter is True, it also applies random offsets or steps to adjust the position of the cropped area in the image.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":212-241",
            "content": "            input_size[1] if abs(x - input_size[1]) < 3 else x\n            for x in crop_sizes\n        ]\n        crop_w = [\n            input_size[0] if abs(x - input_size[0]) < 3 else x\n            for x in crop_sizes\n        ]\n        pairs = []\n        for i, h in enumerate(crop_h):\n            for j, w in enumerate(crop_w):\n                if abs(i - j) <= max_distort:\n                    pairs.append((w, h))\n        crop_pair = random.choice(pairs)\n        if not fix_crop:\n            w_offset = random.randint(0, image_w - crop_pair[0])\n            h_offset = random.randint(0, image_h - crop_pair[1])\n        else:\n            w_step = (image_w - crop_pair[0]) / 4\n            h_step = (image_h - crop_pair[1]) / 4\n            ret = list()\n            ret.append((0, 0))  # upper left\n            if w_step != 0:\n                ret.append((4 * w_step, 0))  # upper right\n            if h_step != 0:\n                ret.append((0, 4 * h_step))  # lower left\n            if h_step != 0 and w_step != 0:\n                ret.append((4 * w_step, 4 * h_step))  # lower right"
        },
        {
            "comment": "This code sample is from a video action detection application and generates random crop sizes for data augmentation. It considers different crop positions based on the step values provided, then randomly selects one of them to create a dictionary of crop information including width, height, offset for width, and offset for height.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":242-266",
            "content": "            if h_step != 0 or w_step != 0:\n                ret.append((2 * w_step, 2 * h_step))  # center\n            if more_fix_crop:\n                ret.append((0, 2 * h_step))  # center left\n                ret.append((4 * w_step, 2 * h_step))  # center right\n                ret.append((2 * w_step, 4 * h_step))  # lower center\n                ret.append((2 * w_step, 0 * h_step))  # upper center\n                ret.append((1 * w_step, 1 * h_step))  # upper left quarter\n                ret.append((3 * w_step, 1 * h_step))  # upper right quarter\n                ret.append((1 * w_step, 3 * h_step))  # lower left quarter\n                ret.append((3 * w_step, 3 * h_step))  # lower righ quarter\n            w_offset, h_offset = random.choice(ret)\n            crop_info = {\n                'crop_w': crop_pair[0],\n                'crop_h': crop_pair[1],\n                'offset_w': w_offset,\n                'offset_h': h_offset\n                }\n        return crop_info\n    crop_info = _sample_crop_size(im_size)"
        },
        {
            "comment": "The code contains three functions: \"crop_and_resize\" which crops and resizes images based on provided crop information, \"group_random_crop\" which randomly crops a group of images to the target size, and \"group_random_flip\" which performs random horizontal flipping on a group of images.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":267-306",
            "content": "    crop_w = crop_info['crop_w']\n    crop_h = crop_info['crop_h']\n    offset_w = crop_info['offset_w']\n    offset_h = crop_info['offset_h']\n    crop_img_group = [\n        img.crop((offset_w, offset_h, offset_w + crop_w, offset_h + crop_h))\n        for img in img_group\n    ]\n    ret_img_group = [\n        img.resize((input_size[0], input_size[1]), Image.BILINEAR)\n        for img in crop_img_group\n    ]\n    return ret_img_group\ndef group_random_crop(img_group, target_size):\n    \"\"\"\n    group_random_crop\n    \"\"\"\n    w, h = img_group[0].size\n    th, tw = target_size, target_size\n    assert (w >= target_size) and (h >= target_size), \\\n          \"image width({}) and height({}) should be larger than crop size\".format(w, h)\n    out_images = []\n    x1 = random.randint(0, w - tw)\n    y1 = random.randint(0, h - th)\n    for img in img_group:\n        if w == tw and h == th:\n            out_images.append(img)\n        else:\n            out_images.append(img.crop((x1, y1, x1 + tw, y1 + th)))\n    return out_images\ndef group_random_flip(img_group):"
        },
        {
            "comment": "The code defines three functions: `group_random_flip`, `group_center_crop`, and `group_scale`. These functions are used to manipulate image groups by flipping, cropping, or resizing them to fit a target size.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":307-348",
            "content": "    \"\"\"\n    group_random_flip\n    \"\"\"\n    v = random.random()\n    if v < 0.5:\n        ret = [img.transpose(Image.FLIP_LEFT_RIGHT) for img in img_group]\n        return ret\n    else:\n        return img_group\ndef group_center_crop(img_group, target_size):\n    \"\"\"\n    group_center_crop\n    \"\"\"\n    img_crop = []\n    for img in img_group:\n        w, h = img.size\n        th, tw = target_size, target_size\n        assert (w >= target_size) and (h >= target_size), \\\n             \"image width({}) and height({}) should be larger than crop size\".format(w, h)\n        x1 = int(round((w - tw) / 2.))\n        y1 = int(round((h - th) / 2.))\n        img_crop.append(img.crop((x1, y1, x1 + tw, y1 + th)))\n    return img_crop\ndef group_scale(imgs, target_size):\n    \"\"\"\n    group_scale\n    \"\"\"\n    resized_imgs = []\n    for i in range(len(imgs)):\n        img = imgs[i]\n        w, h = img.size\n        if (w <= h and w == target_size) or (h <= w and h == target_size):\n            resized_imgs.append(img)\n            continue\n        if w < h:\n            ow = target_size"
        },
        {
            "comment": "This code resizes images according to the aspect ratio. If the image's aspect ratio is 4:3, it resizes to target_size; otherwise, it resizes to target_size and then calculates a new height and width for the image. It appends these resized images to the 'resized_imgs' list and returns this list.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/predict/action_detect/reader/tsminf_reader.py\":349-356",
            "content": "            oh = int(target_size * 4.0 / 3.0)\n            resized_imgs.append(img.resize((ow, oh), Image.BILINEAR))\n        else:\n            oh = target_size\n            ow = int(target_size * 4.0 / 3.0)\n            resized_imgs.append(img.resize((ow, oh), Image.BILINEAR))\n    return resized_imgs"
        }
    ]
}