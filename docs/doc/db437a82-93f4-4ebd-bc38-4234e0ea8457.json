{
    "summary": "The code enables image resizing, flipping, multi-scale segmentation in PaddleVideo's pipeline, with metadata addition and normalization. It performs image normalization and transposition before storing the result in a samples data structure.",
    "details": [
        {
            "comment": "This code is for PaddleVideo's segmentation pipeline. It includes the class definition MultiRestrictSize, which can be used with minimum and maximum size limits, flipping option, and multiple scales for image resizing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/segmentation.py\":0-31",
            "content": "# copyright (c) 2021 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport numpy as np\nfrom PIL import Image\nimport copy\nimport cv2\nfrom ..registry import PIPELINES\n@PIPELINES.register()\nclass MultiRestrictSize(object):\n    def __init__(self,\n                 min_size=None,\n                 max_size=800,\n                 flip=False,\n                 multi_scale=[1.3]):\n        self.min_size = min_size\n        self.max_size = max_size\n        self.multi_scale = multi_scale\n        self.flip = flip"
        },
        {
            "comment": "This code is a function that applies image segmentation using multi-scale technique. It scales the input image based on a fixed range of scales and aligns short or long edges to meet minimum or maximum size requirements, respectively. The scaled images are stored in a list for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/segmentation.py\":32-64",
            "content": "        assert ((min_size is None)) or ((max_size is None))\n    def __call__(self, sample):\n        samples = []\n        image = sample['current_img']\n        h, w = image.shape[:2]\n        for scale in self.multi_scale:\n            # Fixed range of scales\n            sc = None\n            # Align short edge\n            if not (self.min_size is None):\n                if h > w:\n                    short_edge = w\n                else:\n                    short_edge = h\n                if short_edge > self.min_size:\n                    sc = float(self.min_size) / short_edge\n            else:\n                if h > w:\n                    long_edge = h\n                else:\n                    long_edge = w\n                if long_edge > self.max_size:\n                    sc = float(self.max_size) / long_edge\n            if sc is None:\n                new_h = h\n                new_w = w\n            else:\n                new_h = sc * h\n                new_w = sc * w\n            new_h = int(new_h * scale)\n            new_w = int(new_w * scale)"
        },
        {
            "comment": "Code resizes input images to a multiple of 16x16, appends samples with matching metadata, and optionally flips the image if enabled.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/segmentation.py\":66-91",
            "content": "            if (new_h - 1) % 16 != 0:\n                new_h = int(np.around((new_h - 1) / 16.) * 16 + 1)\n            if (new_w - 1) % 16 != 0:\n                new_w = int(np.around((new_w - 1) / 16.) * 16 + 1)\n            if new_h == h and new_w == w:\n                samples.append(sample)\n            else:\n                new_sample = {}\n                for elem in sample.keys():\n                    if 'meta' in elem:\n                        new_sample[elem] = sample[elem]\n                        continue\n                    tmp = sample[elem]\n                    if 'label' in elem:\n                        new_sample[elem] = sample[elem]\n                        continue\n                    else:\n                        flagval = cv2.INTER_CUBIC\n                        tmp = cv2.resize(tmp,\n                                         dsize=(new_w, new_h),\n                                         interpolation=flagval)\n                        new_sample[elem] = tmp\n                samples.append(new_sample)\n            if self.flip:"
        },
        {
            "comment": "This code segment is from the PaddleVideo library, specifically in the loader/pipelines/segmentation.py file. It appears to be a function that adds flipped image data to a list of samples, after normalizing each image by dividing it by 255 and subtracting (0.485, 0.456, 0.406). This function is part of the MultiNorm pipeline registered in the PIPELINES module.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/segmentation.py\":92-123",
            "content": "                now_sample = samples[-1]\n                new_sample = {}\n                for elem in now_sample.keys():\n                    if 'meta' in elem:\n                        new_sample[elem] = now_sample[elem].copy()\n                        new_sample[elem]['flip'] = True\n                        continue\n                    tmp = now_sample[elem]\n                    tmp = tmp[:, ::-1].copy()\n                    new_sample[elem] = tmp\n                samples.append(new_sample)\n        return samples\n@PIPELINES.register()\nclass MultiNorm(object):\n    def __call__(self, samples):\n        for idx in range(len(samples)):\n            sample = samples[idx]\n            for elem in sample.keys():\n                if 'meta' in elem:\n                    continue\n                tmp = sample[elem]\n                if tmp is None:\n                    continue\n                if tmp.ndim == 2:\n                    tmp = tmp[:, :, np.newaxis]\n                else:\n                    tmp = tmp / 255.\n                    tmp -= (0.485, 0.456, 0.406)"
        },
        {
            "comment": "This code segment performs image normalization and transposition before storing the result in a dictionary-like samples data structure. It divides each RGB channel value by the average RGB values, then transposes the image channels. Finally, it adds the transformed image to the samples dictionary for the given index and element.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/segmentation.py\":124-129",
            "content": "                    tmp /= (0.229, 0.224, 0.225)\n                tmp = tmp.transpose((2, 0, 1))\n                samples[idx][elem] = tmp\n        return samples"
        }
    ]
}