{
    "summary": "This code defines 3D head projection classes for PaddleVideo library, initializes a SlowFast head model with dropout regularization and adaptive average pooling, performs convolutional inference, applies softmax activation, averages when not training, and reshapes before returning.",
    "details": [
        {
            "comment": "This code is from the PaddleVideo library and defines a SlowFastHead class for ResNe(X)t 3D head. It performs a fully-connected projection during training and convolutional projection during testing, with different input sizes handled accordingly. The code includes import statements, registration using HEADS registry, and base class inheritance from BaseHead.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/slowfast_head.py\":0-29",
            "content": "# copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom ..registry import HEADS\nfrom .base import BaseHead\nimport paddle\nimport paddle.nn.functional as F\nfrom ..weight_init import weight_init_\n@HEADS.register()\nclass SlowFastHead(BaseHead):\n    \"\"\"\n    ResNe(X)t 3D head.\n    This layer performs a fully-connected projection during training, when the\n    input size is 1x1x1. It performs a convolutional projection during testing\n    when the input size is larger than 1x1x1. If the inputs are from multiple"
        },
        {
            "comment": "The code defines a class for SlowFast_Head, which takes different pathways as input and concatenates the inputs after pooling. It has various parameters such as width_per_group, alpha, beta, etc. The ResNetBasicHead takes p pathways as input where p can be in the range of 1 to infinity. It has arguments for dim_in (list), num_classes (int), pool_size (list), and dropout_rate (float).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/slowfast_head.py\":30-55",
            "content": "    different pathways, the inputs will be concatenated after pooling.\n    \"\"\"\n    def __init__(self,\n                 width_per_group,\n                 alpha,\n                 beta,\n                 num_classes,\n                 num_frames,\n                 crop_size,\n                 dropout_rate,\n                 pool_size_ratio=[[1, 1, 1], [1, 1, 1]],\n                 loss_cfg=dict(name='CrossEntropyLoss'),\n                 multigrid_short=False,\n                 **kwargs):\n        \"\"\"\n        ResNetBasicHead takes p pathways as input where p in [1, infty].\n        Args:\n            dim_in (list): the list of channel dimensions of the p inputs to the\n                ResNetHead.\n            num_classes (int): the channel dimensions of the p outputs to the\n                ResNetHead.\n            pool_size (list): the list of kernel sizes of p spatial temporal\n                poolings, temporal pool kernel size, spatial pool kernel size,\n                spatial pool kernel size in order.\n            dropout_rate (float): dropout rate. If equal to 0.0, perform no"
        },
        {
            "comment": "This code is initializing a SlowFast head model with specified parameters such as multigrid_short, width_per_group, alpha, beta, num_classes, num_frames, crop_size, and dropout_rate. It also sets the dimension input (dim_in) based on these parameters, and determines the pool size accordingly based on whether multigrid_short is True or False.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/slowfast_head.py\":56-82",
            "content": "                dropout.\n        \"\"\"\n        super().__init__(num_classes, loss_cfg, **kwargs)\n        self.multigrid_short = multigrid_short\n        self.width_per_group = width_per_group\n        self.alpha = alpha\n        self.beta = beta\n        self.num_classes = num_classes\n        self.num_frames = num_frames\n        self.crop_size = crop_size\n        self.dropout_rate = dropout_rate\n        self.pool_size_ratio = pool_size_ratio\n        self.dim_in = [\n            self.width_per_group * 32,\n            self.width_per_group * 32 // self.beta,\n        ]\n        self.pool_size = [None, None] if self.multigrid_short else [\n            [\n                self.num_frames // self.alpha // self.pool_size_ratio[0][0],\n                self.crop_size // 32 // self.pool_size_ratio[0][1],\n                self.crop_size // 32 // self.pool_size_ratio[0][2],\n            ],\n            [\n                self.num_frames // self.pool_size_ratio[1][0],\n                self.crop_size // 32 // self.pool_size_ratio[1][1],\n                self.crop_size // 32 // self.pool_size_ratio[1][2],"
        },
        {
            "comment": "This code initializes a SlowFast head model. It defines the number of pathways, applies dropout regularization, and initializes weights for linear projection. The forward method expects inputs with the same number of pathways as defined in the model. It then performs adaptive average pooling on each input pathway separately.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/slowfast_head.py\":83-112",
            "content": "            ],\n        ]\n        assert (len({len(self.pool_size), len(self.dim_in)\n                     }) == 1), \"pathway dimensions are not consistent.\"\n        self.num_pathways = len(self.pool_size)\n        self.dropout = paddle.nn.Dropout(p=self.dropout_rate)\n        self.projection = paddle.nn.Linear(\n            in_features=sum(self.dim_in),\n            out_features=self.num_classes,\n        )\n    def init_weights(self):\n        weight_init_(self.projection,\n                     \"Normal\",\n                     bias_value=0.0,\n                     mean=0.0,\n                     std=0.01)\n    def forward(self, inputs):\n        assert (len(inputs) == self.num_pathways\n                ), \"Input tensor does not contain {} pathway\".format(\n                    self.num_pathways)\n        pool_out = []\n        for pathway in range(self.num_pathways):\n            if self.pool_size[pathway] is None:\n                tmp_out = F.adaptive_avg_pool3d(x=inputs[pathway],\n                                                output_size=(1, 1, 1),"
        },
        {
            "comment": "This code performs pooling and dropout operations on input tensors, followed by projection and fully convolutional inference. It also applies softmax activation and averaging when not in training mode. The resulting tensor is reshaped before returning.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/slowfast_head.py\":113-136",
            "content": "                                                data_format=\"NCDHW\")\n            else:\n                tmp_out = F.avg_pool3d(x=inputs[pathway],\n                                       kernel_size=self.pool_size[pathway],\n                                       stride=1,\n                                       data_format=\"NCDHW\")\n            pool_out.append(tmp_out)\n        x = paddle.concat(x=pool_out, axis=1)\n        x = paddle.transpose(x=x, perm=(0, 2, 3, 4, 1))\n        # Perform dropout.\n        if self.dropout_rate > 0.0:\n            x = self.dropout(x)\n        x = self.projection(x)\n        # Performs fully convlutional inference.\n        if not self.training:  # attr of base class\n            x = F.softmax(x, axis=4)\n            x = paddle.mean(x, axis=[1, 2, 3])\n        x = paddle.reshape(x, shape=(x.shape[0], -1))\n        return x"
        }
    ]
}