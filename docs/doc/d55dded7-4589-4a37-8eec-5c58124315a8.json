{
    "summary": "The Python module supports PaddleVideo's VideoTag app, includes a model class for subclassing with base methods, and handles weights, dataloader, pre-trained models, weight file paths, and downloads. It also provides a ModelZoo class for managing models and functions to get/register models.",
    "details": [
        {
            "comment": "This code is a Python module for the PaddleVideo project's VideoTag application. It imports necessary libraries, sets the storage location for weights, and defines functions for parameter checking and handling exceptions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/model.py\":0-35",
            "content": "#  Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n#Licensed under the Apache License, Version 2.0 (the \"License\");\n#you may not use this file except in compliance with the License.\n#You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n#Unless required by applicable law or agreed to in writing, software\n#distributed under the License is distributed on an \"AS IS\" BASIS,\n#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#See the License for the specific language governing permissions and\n#limitations under the License.\nimport os\nimport wget\nimport logging\nimport paddle\nimport paddle.static as static\ntry:\n    from configparser import ConfigParser\nexcept:\n    from ConfigParser import ConfigParser\nfrom .utils import download, AttrDict\nWEIGHT_DIR = os.path.join(os.path.expanduser('~'), '.paddle', 'weights')\nlogger = logging.getLogger(__name__)\ndef is_parameter(var):\n    return isinstance(var, paddle.framework.Parameter)\nclass NotImplementError(Exception):"
        },
        {
            "comment": "This code defines two custom exceptions, \"NotImplementError\" and \"ModelNotFoundError\", to handle specific model-related issues. The \"ModelBase\" class serves as a base for creating different models with different modes (train, valid, test, infer). The code also checks if the mode input is valid.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/model.py\":36-68",
            "content": "    \"Error: model function not implement\"\n    def __init__(self, model, function):\n        super(NotImplementError, self).__init__()\n        self.model = model.__class__.__name__\n        self.function = function.__name__\n    def __str__(self):\n        return \"Function {}() is not implemented in model {}\".format(\n            self.function, self.model)\nclass ModelNotFoundError(Exception):\n    \"Error: model not found\"\n    def __init__(self, model_name, avail_models):\n        super(ModelNotFoundError, self).__init__()\n        self.model_name = model_name\n        self.avail_models = avail_models\n    def __str__(self):\n        msg = \"Model {} Not Found.\\nAvailiable models:\\n\".format(\n            self.model_name)\n        for model in self.avail_models:\n            msg += \"  {}\\n\".format(model)\n        return msg\nclass ModelBase(object):\n    def __init__(self, name, cfg, mode='train'):\n        assert mode in ['train', 'valid', 'test', 'infer'], \\\n                \"Unknown mode type {}\".format(mode)\n        self.name = name"
        },
        {
            "comment": "The code is a model class that requires subclassing for implementation. It defines various methods such as build_model, build_input, optimizer, outputs, loss, feeds, and fetches. However, the actual implementation of these methods should be provided in the subclass since they are all raising NotImplementedError. The weights_info method returns model weight default path and download URL.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/model.py\":69-104",
            "content": "        self.is_training = (mode == 'train')\n        self.mode = mode\n        self.cfg = cfg\n        self.dataloader = None\n    def build_model(self):\n        \"build model struct\"\n        raise NotImplementError(self, self.build_model)\n    def build_input(self, use_dataloader):\n        \"build input Variable\"\n        raise NotImplementError(self, self.build_input)\n    def optimizer(self):\n        \"get model optimizer\"\n        raise NotImplementError(self, self.optimizer)\n    def outputs(self):\n        \"get output variable\"\n        raise NotImplementError(self, self.outputs)\n    def loss(self):\n        \"get loss variable\"\n        raise NotImplementError(self, self.loss)\n    def feeds(self):\n        \"get feed inputs list\"\n        raise NotImplementError(self, self.feeds)\n    def fetches(self):\n        \"get fetch list of model\"\n        raise NotImplementError(self, self.fetches)\n    def weights_info(self):\n        \"get model weight default path and download url\"\n        raise NotImplementError(self, self.weights_info)"
        },
        {
            "comment": "This code defines several methods for a model class. The `get_weights` method returns the weight file path, downloading it from Paddle if it doesn't exist. The `dataloader` method returns the dataloader object. The `epoch_num` method returns the train epoch number. The `pretrain_info` method returns the pre-trained base model directory. The `get_pretrain_weights` method returns the weight file path, downloading it from Paddle if necessary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/model.py\":106-138",
            "content": "    def get_weights(self):\n        \"get model weight file path, download weight from Paddle if not exist\"\n        path, url = self.weights_info()\n        path = os.path.join(WEIGHT_DIR, path)\n        if not os.path.isdir(WEIGHT_DIR):\n            logger.info('{} not exists, will be created automatically.'.format(\n                WEIGHT_DIR))\n            os.makedirs(WEIGHT_DIR)\n        if os.path.exists(path):\n            return path\n        logger.info(\"Download weights of {} from {}\".format(self.name, url))\n        wget.download(url, path)\n        return path\n    def dataloader(self):\n        return self.dataloader\n    def epoch_num(self):\n        \"get train epoch num\"\n        return self.cfg.TRAIN.epoch\n    def pretrain_info(self):\n        \"get pretrain base model directory\"\n        return (None, None)\n    def get_pretrain_weights(self):\n        \"get model weight file path, download weight from Paddle if not exist\"\n        path, url = self.pretrain_info()\n        if not path:\n            return None\n        path = os.path.join(WEIGHT_DIR, path)"
        },
        {
            "comment": "The code includes functions for handling model weights. It checks if a directory exists, downloads pretrain weights if necessary, loads pretrain and test weights into programs, and retrieves configuration from a config file.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/model.py\":139-166",
            "content": "        if not os.path.isdir(WEIGHT_DIR):\n            logger.info('{} not exists, will be created automatically.'.format(\n                WEIGHT_DIR))\n            os.makedirs(WEIGHT_DIR)\n        if os.path.exists(path):\n            return path\n        logger.info(\"Download pretrain weights of {} from {}\".format(\n            self.name, url))\n        download(url, path)\n        return path\n    def load_pretrain_params(self, exe, pretrain, prog):\n        logger.info(\"Load pretrain weights from {}\".format(pretrain))\n        state_dict = paddle.static.load_program_state(pretrain)\n        paddle.static.set_program_state(prog, state_dict)\n    def load_test_weights(self, exe, weights, prog):\n        params_list = list(filter(is_parameter, prog.list_vars()))\n        static.load(prog, weights, executor=exe, var_list=params_list)\n    def get_config_from_sec(self, sec, item, default=None):\n        if sec.upper() not in self.cfg:\n            return default\n        return self.cfg[sec.upper()].get(item, default)\nclass ModelZoo(object):"
        },
        {
            "comment": "This code defines a ModelZoo class for managing different models, allowing registration and retrieval of models based on their names. The get() function returns the model instance with the specified name, while regist() registers new model classes to the ModelZoo. The get_model() and regist_model() functions provide convenient methods to interact with the singleton ModelZoo instance.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/model.py\":167-191",
            "content": "    def __init__(self):\n        self.model_zoo = {}\n    def regist(self, name, model):\n        assert model.__base__ == ModelBase, \"Unknow model type {}\".format(\n            type(model))\n        self.model_zoo[name] = model\n    def get(self, name, cfg, mode='train', is_videotag=False):\n        for k, v in self.model_zoo.items():\n            if k.upper() == name.upper():\n                return v(name, cfg, mode, is_videotag)\n        raise ModelNotFoundError(name, self.model_zoo.keys())\n# singleton model_zoo\nmodel_zoo = ModelZoo()\ndef regist_model(name, model):\n    model_zoo.regist(name, model)\ndef get_model(name, cfg, mode='train', is_videotag=False):\n    return model_zoo.get(name, cfg, mode, is_videotag)"
        }
    ]
}