{
    "summary": "The PaddleVideo class in PaddlePipelines uses PIL and skimage for image decoding operations. It accepts parameters such as scales, side map, and backend. This class can be used with datasets like KITTI and KITTI ODOM, supporting the retrieval of image paths and resizing of depth images. The code organizes results into a dictionary structure, processes image data based on 'train' or 'val', retrieves color images, adjusts intrinsics for depth estimation, stores results in the 'imgs' dictionary, and adds processed 'imgs' to 'results'.",
    "details": [
        {
            "comment": "This code is a Python class for decoding images, registered with the PADDLEPIPELINES module. It uses the PIL and skimage libraries, and is part of the PaddleVideo package in PaddlePaddle. The class takes in a dataset and frame_idxs as parameters for image decoding operations.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_image.py\":0-36",
            "content": "#  Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport os\nimport numpy as np\nimport PIL.Image as pil\ntry:\n    import skimage.transform\nexcept ImportError as e:\n    print(\n        f\"Warning! {e}, [scikit-image] package and it's dependencies is required for ADDS.\"\n    )\nfrom PIL import Image\nfrom ..registry import PIPELINES\n@PIPELINES.register()\nclass ImageDecoder(object):\n    \"\"\"Decode Image\n    \"\"\"\n    def __init__(self,\n                 dataset,\n                 frame_idxs,"
        },
        {
            "comment": "This code defines a class for image decoding pipelines, accepting parameters such as number of scales, side map, full resolution shape, image extension, and backend. It also includes methods for loading images using the PIL library and retrieving image paths based on the dataset. The class is intended to be used for decoding images from specific datasets like KITTI and KITTI ODOM.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_image.py\":37-65",
            "content": "                 num_scales,\n                 side_map,\n                 full_res_shape,\n                 img_ext,\n                 backend='cv2'):\n        self.backend = backend\n        self.dataset = dataset\n        self.frame_idxs = frame_idxs\n        self.num_scales = num_scales\n        self.side_map = side_map\n        self.full_res_shape = full_res_shape\n        self.img_ext = img_ext\n    def _pil_loader(self, path):\n        with open(path, 'rb') as f:\n            with Image.open(f) as img:\n                return img.convert('RGB')\n    def get_color(self, folder, frame_index, side):\n        color = self._pil_loader(\n            self.get_image_path(self.dataset, folder, frame_index, side))\n        return color\n    def get_image_path(self, dataset, folder, frame_index, side):\n        if dataset == \"kitti\":\n            f_str = \"{:010d}{}\".format(frame_index, self.img_ext)\n            image_path = os.path.join(self.data_path, folder, f_str)\n        elif dataset == \"kitti_odom\":\n            f_str = \"{:06d}{}\".format(frame_index, self.img_ext)"
        },
        {
            "comment": "This code defines a class with two methods: `get_image_path` and `get_depth`. The first method returns the path of an image based on the dataset, folder, frame index, and side. If the dataset is \"kitti_depth\", it constructs the path using frame index and extension. The second method retrieves depth data for a given dataset, folder, frame index, and side. It uses the \"kitii_depth\" dataset, constructs the path to the depth file, opens the image, resizes it, and converts it into a float32 array divided by 256.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_image.py\":66-88",
            "content": "            image_path = os.path.join(self.data_path,\n                                      \"sequences/{:02d}\".format(int(folder)),\n                                      \"image_{}\".format(self.side_map[side]),\n                                      f_str)\n        elif dataset == \"kitti_depth\":\n            f_str = \"{:010d}{}\".format(frame_index, self.img_ext)\n            image_path = os.path.join(\n                self.data_path, folder,\n                \"image_0{}/data\".format(self.side_map[side]), f_str)\n        return image_path\n    def get_depth(self, dataset, folder, frame_index, side):\n        if dataset == \"kitii_depth\":\n            f_str = \"{:010d}.png\".format(frame_index)\n            depth_path = os.path.join(\n                self.data_path, folder,\n                \"proj_depth/groundtruth/image_0{}\".format(self.side_map[side]),\n                f_str)\n            depth_gt = pil.open(depth_path)\n            depth_gt = depth_gt.resize(self.full_res_shape, pil.NEAREST)\n            depth_gt = np.array(depth_gt).astype(np.float32) / 256"
        },
        {
            "comment": "This function reads the depth image from file and resizes it to the desired shape, ensuring that it is a 16-bit depth map. It also checks if the maximum value exceeds 255, asserting that this is not an 8-bit image. The final output is a resized depth_gt with dimensions self.full_res_shape[::-1]. The function returns this resized depth_gt after performing any necessary operations for mp4 decode operations.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_image.py\":90-115",
            "content": "        else:\n            f_str = \"{:010d}{}\".format(frame_index, self.img_ext)\n            depth_path = os.path.join(self.data_path, folder + '_gt', f_str)\n            img_file = Image.open(depth_path)\n            depth_png = np.array(img_file, dtype=int)\n            img_file.close()\n            # make sure we have a proper 16bit depth map here.. not 8bit!\n            assert np.max(depth_png) > 255, \\\n                \"np.max(depth_png)={}, path={}\".format(np.max(depth_png), depth_path)\n            depth_gt = depth_png.astype(np.float) / 256.\n            depth_gt = depth_gt[160:960 - 160, :]\n            depth_gt = skimage.transform.resize(depth_gt,\n                                                self.full_res_shape[::-1],\n                                                order=0,\n                                                preserve_range=True,\n                                                mode='constant')\n        return depth_gt\n    def __call__(self, results):\n        \"\"\"\n        Perform mp4 decode operations."
        },
        {
            "comment": "This code handles the decoding of images and organizes the results into a dictionary structure. It checks if the mode is set to 'infer', where it opens an image in RGB format, stores it in the results dictionary under 'imgs' key, and returns the results. If the mode is not set or is 'train', it sets up necessary variables for organizing data based on day or night folders and whether the folder is real or fake.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_image.py\":116-148",
            "content": "        return:\n            List where each item is a numpy array after decoder.\n        \"\"\"\n        if results.get('mode', None) == 'infer':\n            imgs = {}\n            imgs[(\"color\", 0,\n                  -1)] = Image.open(results[\"filename\"]).convert(\"RGB\")\n            results['imgs'] = imgs\n            return results\n        self.data_path = results['data_path']\n        results['backend'] = self.backend\n        imgs = {}\n        results['frame_idxs'] = self.frame_idxs\n        results['num_scales'] = self.num_scales\n        file_name = results['filename']\n        folder = results['folder']\n        frame_index = results['frame_index']\n        line = file_name.split('/')\n        istrain = folder.split('_')[1]\n        if 'mode' not in results:\n            results['mode'] = istrain\n        results['day_or_night'] = folder.split('_')[0]\n        if istrain == \"train\":\n            if folder[0] == 'd':\n                folder2 = folder + '_fake_night'\n                flag = 0\n            else:\n                folder2 = folder + '_fake_day'"
        },
        {
            "comment": "This code is setting up image files for decoding from a given folder and folder2 based on the frame indexes. It also considers whether the images are for the left or right side, identified by 'r' and 'l'. The flag variable is used to check if there's a change in side. If the folder name does not contain 'train', it executes something else (not shown in this code snippet).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_image.py\":149-178",
            "content": "                tmp = folder\n                folder = folder2\n                folder2 = tmp\n                flag = 1\n            if len(line) == 3:\n                side = line[2]\n            else:\n                side = None\n            results['side'] = side\n            for i in self.frame_idxs:\n                if i == \"s\":\n                    other_side = {\"r\": \"l\", \"l\": \"r\"}[side]\n                    imgs[(\"color\", i,\n                          -1)] = self.get_color(folder, frame_index, other_side)\n                    imgs[(\"color_n\", i,\n                          -1)] = self.get_color(folder2, frame_index,\n                                                other_side)\n                else:\n                    imgs[(\"color\", i,\n                          -1)] = self.get_color(folder, frame_index + i, side)\n                    imgs[(\"color_n\", i,\n                          -1)] = self.get_color(folder2, frame_index + i, side)\n            istrain = folder.split('_')[1]\n            if istrain != 'train':\n                if flag:"
        },
        {
            "comment": "The code checks the 'train' or 'val' flag and processes image data accordingly. It retrieves color images based on 'frame_idxs', adjusts intrinsics for depth estimation, and stores results in 'imgs' dictionary. The processed 'imgs' is then added to 'results' before returning it.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_image.py\":179-205",
            "content": "                    depth_gt = self.get_depth(folder2, frame_index, side)\n                else:\n                    depth_gt = self.get_depth(folder, frame_index, side)\n                imgs[\"depth_gt\"] = np.expand_dims(depth_gt, 0)\n        elif istrain == 'val':\n            if len(line) == 3:\n                side = line[2]\n            else:\n                side = None\n            for i in self.frame_idxs:\n                if i == \"s\":\n                    other_side = {\"r\": \"l\", \"l\": \"r\"}[side]\n                    imgs[(\"color\", i,\n                          -1)] = self.get_color(folder, frame_index, other_side)\n                else:\n                    imgs[(\"color\", i,\n                          -1)] = self.get_color(folder, frame_index + i, side)\n            # adjusting intrinsics to match each scale in the pyramid\n            depth_gt = self.get_depth(self.dataset, folder, frame_index, side)\n            imgs[\"depth_gt\"] = np.expand_dims(depth_gt, 0)\n        results['imgs'] = imgs\n        return results"
        }
    ]
}