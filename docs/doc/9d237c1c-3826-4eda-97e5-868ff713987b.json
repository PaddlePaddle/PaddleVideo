{
    "summary": "The code cleans and processes NTU RGB-D dataset data by removing noisy frames, handling missing values, updating arrays, logging counts, denoising raw skeleton data, and generating log files for sequences with multiple actors. It reads sequence data, extracts joints and color data, handles multiple actors and missing frames, and stores the processed data for further processing while counting missing data.",
    "details": [
        {
            "comment": "This code is setting up directories and loggers for processing raw data and identifying noisy sequences. It checks if the required folders exist, creates them if not, sets up loggers to track noise length and spread thresholds, and initializes variables for the process.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":0-37",
            "content": "# ref: https://github.com/Uason-Chen/CTR-GCN/blob/main/data/ntu/get_raw_denoised_data.py\nimport os\nimport os.path as osp\nimport numpy as np\nimport pickle\nimport logging\nroot_path = './'\nraw_data_file = osp.join(root_path, 'raw_data', 'raw_skes_data.pkl')\nsave_path = osp.join(root_path, 'denoised_data')\nif not osp.exists(save_path):\n    os.mkdir(save_path)\nrgb_ske_path = osp.join(save_path, 'rgb+ske')\nif not osp.exists(rgb_ske_path):\n    os.mkdir(rgb_ske_path)\nactors_info_dir = osp.join(save_path, 'actors_info')\nif not osp.exists(actors_info_dir):\n    os.mkdir(actors_info_dir)\nmissing_count = 0\nnoise_len_thres = 11\nnoise_spr_thres1 = 0.8\nnoise_spr_thres2 = 0.69754\nnoise_mot_thres_lo = 0.089925\nnoise_mot_thres_hi = 2\nnoise_len_logger = logging.getLogger('noise_length')\nnoise_len_logger.setLevel(logging.INFO)\nnoise_len_logger.addHandler(\n    logging.FileHandler(osp.join(save_path, 'noise_length.log')))\nnoise_len_logger.info('{:^20}\\t{:^17}\\t{:^8}\\t{}'.format(\n    'Skeleton', 'bodyID', 'Motion', 'Length'))\nnoise_spr_logger = logging.getLogger('noise_spread')"
        },
        {
            "comment": "The code sets up multiple loggers for different types of output: 'noise_spread.log', 'noise_motion.log', 'denoised_failed_1.log', and 'denoised_failed_2.log'. It also creates a logger for missing frames named 'missing_frames'. Each logger is configured with a specific level of logging (INFO) and a file handler to store the logs in designated files within the specified save path. This allows for organized and easily accessible logging during program execution.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":38-62",
            "content": "noise_spr_logger.setLevel(logging.INFO)\nnoise_spr_logger.addHandler(\n    logging.FileHandler(osp.join(save_path, 'noise_spread.log')))\nnoise_spr_logger.info('{:^20}\\t{:^17}\\t{:^8}\\t{:^8}'.format(\n    'Skeleton', 'bodyID', 'Motion', 'Rate'))\nnoise_mot_logger = logging.getLogger('noise_motion')\nnoise_mot_logger.setLevel(logging.INFO)\nnoise_mot_logger.addHandler(\n    logging.FileHandler(osp.join(save_path, 'noise_motion.log')))\nnoise_mot_logger.info('{:^20}\\t{:^17}\\t{:^8}'.format('Skeleton', 'bodyID',\n                                                     'Motion'))\nfail_logger_1 = logging.getLogger('noise_outliers_1')\nfail_logger_1.setLevel(logging.INFO)\nfail_logger_1.addHandler(\n    logging.FileHandler(osp.join(save_path, 'denoised_failed_1.log')))\nfail_logger_2 = logging.getLogger('noise_outliers_2')\nfail_logger_2.setLevel(logging.INFO)\nfail_logger_2.addHandler(\n    logging.FileHandler(osp.join(save_path, 'denoised_failed_2.log')))\nmissing_skes_logger = logging.getLogger('missing_frames')\nmissing_skes_logger.setLevel(logging.INFO)"
        },
        {
            "comment": "Creates multiple loggers for tracking missing skeleton frames, with different handlers and levels of information. Function denoising_by_length takes a skeleton name and bodies_data as input to perform data denoising based on frame length for each bodyID.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":63-85",
            "content": "missing_skes_logger.addHandler(\n    logging.FileHandler(osp.join(save_path, 'missing_skes.log')))\nmissing_skes_logger.info('{:^20}\\t{}\\t{}'.format('Skeleton', 'num_frames',\n                                                 'num_missing'))\nmissing_skes_logger1 = logging.getLogger('missing_frames_1')\nmissing_skes_logger1.setLevel(logging.INFO)\nmissing_skes_logger1.addHandler(\n    logging.FileHandler(osp.join(save_path, 'missing_skes_1.log')))\nmissing_skes_logger1.info('{:^20}\\t{}\\t{}\\t{}\\t{}\\t{}'.format(\n    'Skeleton', 'num_frames', 'Actor1', 'Actor2', 'Start', 'End'))\nmissing_skes_logger2 = logging.getLogger('missing_frames_2')\nmissing_skes_logger2.setLevel(logging.INFO)\nmissing_skes_logger2.addHandler(\n    logging.FileHandler(osp.join(save_path, 'missing_skes_2.log')))\nmissing_skes_logger2.info('{:^20}\\t{}\\t{}\\t{}'.format('Skeleton', 'num_frames',\n                                                      'Actor1', 'Actor2'))\ndef denoising_by_length(ske_name, bodies_data):\n    \"\"\"\n    Denoising data based on the frame length for each bodyID."
        },
        {
            "comment": "Code snippet filters out bodies with a length less than or equal to the predefined threshold and finds valid frames based on the spread of X and Y. It also logs the filtered body information and returns the updated bodies data along with filter information.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":86-115",
            "content": "    Filter out the bodyID which length is less or equal than the predefined threshold.\n    \"\"\"\n    noise_info = str()\n    new_bodies_data = bodies_data.copy()\n    for (bodyID, body_data) in new_bodies_data.items():\n        length = len(body_data['interval'])\n        if length <= noise_len_thres:\n            noise_info += 'Filter out: %s, %d (length).\\n' % (bodyID, length)\n            noise_len_logger.info('{}\\t{}\\t{:.6f}\\t{:^6d}'.format(\n                ske_name, bodyID, body_data['motion'], length))\n            del bodies_data[bodyID]\n    if noise_info != '':\n        noise_info += '\\n'\n    return bodies_data, noise_info\ndef get_valid_frames_by_spread(points):\n    \"\"\"\n    Find the valid (or reasonable) frames (index) based on the spread of X and Y.\n    :param points: joints or colors\n    \"\"\"\n    num_frames = points.shape[0]\n    valid_frames = []\n    for i in range(num_frames):\n        x = points[i, :, 0]\n        y = points[i, :, 1]\n        if (x.max() - x.min()) <= noise_spr_thres1 * (y.max() - y.min()):  # 0.8"
        },
        {
            "comment": "The function \"denoising_by_spread\" takes a sequence of body data and filters out any bodies with a high ratio of noisy frames. It uses the spread of Y and X values to determine if a frame is valid or not. If the ratio of noisy frames exceeds a predefined threshold, the corresponding body is removed from the data. This function ensures that only clean data is used for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":116-146",
            "content": "            valid_frames.append(i)\n    return valid_frames\ndef denoising_by_spread(ske_name, bodies_data):\n    \"\"\"\n    Denoising data based on the spread of Y value and X value.\n    Filter out the bodyID which the ratio of noisy frames is higher than the predefined\n    threshold.\n    bodies_data: contains at least 2 bodyIDs\n    \"\"\"\n    noise_info = str()\n    denoised_by_spr = False  # mark if this sequence has been processed by spread.\n    new_bodies_data = bodies_data.copy()\n    # for (bodyID, body_data) in bodies_data.items():\n    for (bodyID, body_data) in new_bodies_data.items():\n        if len(bodies_data) == 1:\n            break\n        valid_frames = get_valid_frames_by_spread(body_data['joints'].reshape(\n            -1, 25, 3))\n        num_frames = len(body_data['interval'])\n        num_noise = num_frames - len(valid_frames)\n        if num_noise == 0:\n            continue\n        ratio = num_noise / float(num_frames)\n        motion = body_data['motion']\n        if ratio >= noise_spr_thres2:  # 0.69754\n            del bodies_data[bodyID]"
        },
        {
            "comment": "This function filters out frames with high noise (spread rate) and updates the motion values for each bodyID. It also returns a list of tuples sorted by motion, potentially removing noisy frames for each bodyID.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":147-171",
            "content": "            denoised_by_spr = True\n            noise_info += 'Filter out: %s (spread rate >= %.2f).\\n' % (\n                bodyID, noise_spr_thres2)\n            noise_spr_logger.info('%s\\t%s\\t%.6f\\t%.6f' %\n                                  (ske_name, bodyID, motion, ratio))\n        else:  # Update motion\n            joints = body_data['joints'].reshape(-1, 25, 3)[valid_frames]\n            body_data['motion'] = min(\n                motion, np.sum(np.var(joints.reshape(-1, 3), axis=0)))\n            noise_info += '%s: motion %.6f -> %.6f\\n' % (bodyID, motion,\n                                                         body_data['motion'])\n            # TODO: Consider removing noisy frames for each bodyID\n    if noise_info != '':\n        noise_info += '\\n'\n    return bodies_data, noise_info, denoised_by_spr\ndef denoising_by_motion(ske_name, bodies_data, bodies_motion):\n    \"\"\"\n    Filter out the bodyID which motion is out of the range of predefined interval\n    \"\"\"\n    # Sort bodies based on the motion, return a list of tuples"
        },
        {
            "comment": "This code sorts the motion data for each body, discards data with low or high motion values, and returns denoised body data along with information about filtered out bodies. The denoising process is based on heuristic methods that may not be correct for all samples.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":172-197",
            "content": "    # bodies_motion = sorted(bodies_motion.items(), key=lambda x, y: cmp(x[1], y[1]), reverse=True)\n    bodies_motion = sorted(bodies_motion.items(),\n                           key=lambda x: x[1],\n                           reverse=True)\n    # Reserve the body data with the largest motion\n    denoised_bodies_data = [(bodies_motion[0][0],\n                             bodies_data[bodies_motion[0][0]])]\n    noise_info = str()\n    for (bodyID, motion) in bodies_motion[1:]:\n        if (motion < noise_mot_thres_lo) or (motion > noise_mot_thres_hi):\n            noise_info += 'Filter out: %s, %.6f (motion).\\n' % (bodyID, motion)\n            noise_mot_logger.info('{}\\t{}\\t{:.6f}'.format(\n                ske_name, bodyID, motion))\n        else:\n            denoised_bodies_data.append((bodyID, bodies_data[bodyID]))\n    if noise_info != '':\n        noise_info += '\\n'\n    return denoised_bodies_data, noise_info\ndef denoising_bodies_data(bodies_data):\n    \"\"\"\n    Denoising data based on some heuristic methods, not necessarily correct for all samples."
        },
        {
            "comment": "This code performs denoising on bodies data based on frame length and spread. It first denoises the data by frame length and then by spread, if necessary. The function returns a tuple containing the denoised bodies data and the noise information for each step. The code also sorts the bodies based on their motion and returns it in a sorted manner.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":199-224",
            "content": "    Return:\n      denoised_bodies_data (list): tuple: (bodyID, body_data).\n    \"\"\"\n    ske_name = bodies_data['name']\n    bodies_data = bodies_data['data']\n    # Step 1: Denoising based on frame length.\n    bodies_data, noise_info_len = denoising_by_length(ske_name, bodies_data)\n    if len(bodies_data) == 1:  # only has one bodyID left after step 1\n        return bodies_data.items(), noise_info_len\n    # Step 2: Denoising based on spread.\n    bodies_data, noise_info_spr, denoised_by_spr = denoising_by_spread(\n        ske_name, bodies_data)\n    if len(bodies_data) == 1:\n        return bodies_data.items(), noise_info_len + noise_info_spr\n    bodies_motion = dict()  # get body motion\n    for (bodyID, body_data) in bodies_data.items():\n        bodies_motion[bodyID] = body_data['motion']\n    # Sort bodies based on the motion\n    # bodies_motion = sorted(bodies_motion.items(), key=lambda x, y: cmp(x[1], y[1]), reverse=True)\n    bodies_motion = sorted(bodies_motion.items(),\n                           key=lambda x: x[1],"
        },
        {
            "comment": "This code retrieves denoised data from the NTU RGB-D dataset, and considers further denoising by integrating motion. It also defines a function to get joints and colors for only one actor.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":225-251",
            "content": "                           reverse=True)\n    denoised_bodies_data = list()\n    for (bodyID, _) in bodies_motion:\n        denoised_bodies_data.append((bodyID, bodies_data[bodyID]))\n    return denoised_bodies_data, noise_info_len + noise_info_spr\n    # TODO: Consider denoising further by integrating motion method\n    # if denoised_by_spr:  # this sequence has been denoised by spread\n    #     bodies_motion = sorted(bodies_motion.items(), lambda x, y: cmp(x[1], y[1]), reverse=True)\n    #     denoised_bodies_data = list()\n    #     for (bodyID, _) in bodies_motion:\n    #         denoised_bodies_data.append((bodyID, bodies_data[bodyID]))\n    #     return denoised_bodies_data, noise_info\n    # Step 3: Denoising based on motion\n    # bodies_data, noise_info = denoising_by_motion(ske_name, bodies_data, bodies_motion)\n    # return bodies_data, noise_info\ndef get_one_actor_points(body_data, num_frames):\n    \"\"\"\n    Get joints and colors for only one actor.\n    For joints, each frame contains 75 X-Y-Z coordinates.\n    For colors, each frame contains 25 x 2 (X, Y) coordinates."
        },
        {
            "comment": "This code segment defines a function to get raw denoised data from body_data and another function to remove missing frames in the sequence. The first function initializes joints and colors arrays, extracts relevant data from body_data, and returns the joints and colors. The second function cuts off missing frames when all joint positions are 0s and records the number of missing frames for each actor if there are two actors' data.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":252-279",
            "content": "    \"\"\"\n    joints = np.zeros((num_frames, 75), dtype=np.float32)\n    colors = np.ones((num_frames, 1, 25, 2), dtype=np.float32) * np.nan\n    start, end = body_data['interval'][0], body_data['interval'][-1]\n    joints[start:end + 1] = body_data['joints'].reshape(-1, 75)\n    colors[start:end + 1, 0] = body_data['colors']\n    return joints, colors\ndef remove_missing_frames(ske_name, joints, colors):\n    \"\"\"\n    Cut off missing frames which all joints positions are 0s\n    For the sequence with 2 actors' data, also record the number of missing frames for\n    actor1 and actor2, respectively (for debug).\n    \"\"\"\n    num_frames = joints.shape[0]\n    num_bodies = colors.shape[1]  # 1 or 2\n    if num_bodies == 2:  # DEBUG\n        missing_indices_1 = np.where(joints[:, :75].sum(axis=1) == 0)[0]\n        missing_indices_2 = np.where(joints[:, 75:].sum(axis=1) == 0)[0]\n        cnt1 = len(missing_indices_1)\n        cnt2 = len(missing_indices_2)\n        start = 1 if 0 in missing_indices_1 else 0\n        end = 1 if num_frames - 1 in missing_indices_1 else 0"
        },
        {
            "comment": "This code checks if any data is missing or lost for two subjects in a video. If there are missing frames, it updates the joints and colors arrays, marks missing indices with NaN, and logs the number of missing frames and total missing counts.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":280-302",
            "content": "        if max(cnt1, cnt2) > 0:\n            if cnt1 > cnt2:\n                info = '{}\\t{:^10d}\\t{:^6d}\\t{:^6d}\\t{:^5d}\\t{:^3d}'.format(\n                    ske_name, num_frames, cnt1, cnt2, start, end)\n                missing_skes_logger1.info(info)\n            else:\n                info = '{}\\t{:^10d}\\t{:^6d}\\t{:^6d}'.format(\n                    ske_name, num_frames, cnt1, cnt2)\n                missing_skes_logger2.info(info)\n    # Find valid frame indices that the data is not missing or lost\n    # For two-subjects action, this means both data of actor1 and actor2 is missing.\n    valid_indices = np.where(joints.sum(axis=1) != 0)[0]  # 0-based index\n    missing_indices = np.where(joints.sum(axis=1) == 0)[0]\n    num_missing = len(missing_indices)\n    if num_missing > 0:  # Update joints and colors\n        joints = joints[valid_indices]\n        colors[missing_indices] = np.nan\n        global missing_count\n        missing_count += 1\n        missing_skes_logger.info('{}\\t{:^10d}\\t{:^11d}'.format(\n            ske_name, num_frames, num_missing))"
        },
        {
            "comment": "Function get_bodies_info formats the bodies' data into a string with bodyID, interval (start and end frame), and motion amount.\nFunction get_two_actors_points retrieves the first and second actor's joints positions and colors locations from given data.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":304-328",
            "content": "    return joints, colors\ndef get_bodies_info(bodies_data):\n    bodies_info = '{:^17}\\t{}\\t{:^8}\\n'.format('bodyID', 'Interval', 'Motion')\n    for (bodyID, body_data) in bodies_data.items():\n        start, end = body_data['interval'][0], body_data['interval'][-1]\n        bodies_info += '{}\\t{:^8}\\t{:f}\\n'.format(bodyID, str([start, end]),\n                                                  body_data['motion'])\n    return bodies_info + '\\n'\ndef get_two_actors_points(bodies_data):\n    \"\"\"\n    Get the first and second actor's joints positions and colors locations.\n    # Arguments:\n        bodies_data (dict): 3 key-value pairs: 'name', 'data', 'num_frames'.\n        bodies_data['data'] is also a dict, while the key is bodyID, the value is\n        the corresponding body_data which is also a dict with 4 keys:\n          - joints: raw 3D joints positions. Shape: (num_frames x 25, 3)\n          - colors: raw 2D color locations. Shape: (num_frames, 25, 2)\n          - interval: a list which records the frame indices.\n          - motion: motion amount"
        },
        {
            "comment": "This function denoises bodies data and extracts joints and colors information for each frame. If only one actor remains after denoising, it checks if the action is for two subjects (label >= 50) and retrieves joints and colors from the remaining actor. If there are still multiple actors but the action is for one subject (label < 50), it initializes joints as zeros and colors as nans.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":330-357",
            "content": "    # Return:\n        joints, colors.\n    \"\"\"\n    ske_name = bodies_data['name']\n    label = int(ske_name[-2:])\n    num_frames = bodies_data['num_frames']\n    bodies_info = get_bodies_info(bodies_data['data'])\n    bodies_data, noise_info = denoising_bodies_data(\n        bodies_data)  # Denoising data\n    bodies_info += noise_info\n    bodies_data = list(bodies_data)\n    if len(bodies_data) == 1:  # Only left one actor after denoising\n        if label >= 50:  # DEBUG: Denoising failed for two-subjects action\n            fail_logger_2.info(ske_name)\n        bodyID, body_data = bodies_data[0]\n        joints, colors = get_one_actor_points(body_data, num_frames)\n        bodies_info += 'Main actor: %s' % bodyID\n    else:\n        if label < 50:  # DEBUG: Denoising failed for one-subject action\n            fail_logger_1.info(ske_name)\n        joints = np.zeros((num_frames, 150), dtype=np.float32)\n        colors = np.ones((num_frames, 2, 25, 2), dtype=np.float32) * np.nan\n        bodyID, actor1 = bodies_data[0]  # the 1st actor with largest motion"
        },
        {
            "comment": "Code snippet extracts joints, colors and other information from actors' data and assigns them to relevant arrays. It also generates formatted information about each actor including their interval and motion. The while loop iterates through the bodies_data list, considering only those actors whose intervals do not overlap with Actor1, appending their joints and colors to the respective arrays.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":358-376",
            "content": "        start1, end1 = actor1['interval'][0], actor1['interval'][-1]\n        joints[start1:end1 + 1, :75] = actor1['joints'].reshape(-1, 75)\n        colors[start1:end1 + 1, 0] = actor1['colors']\n        actor1_info = '{:^17}\\t{}\\t{:^8}\\n'.format('Actor1', 'Interval', 'Motion') + \\\n                      '{}\\t{:^8}\\t{:f}\\n'.format(bodyID, str([start1, end1]), actor1['motion'])\n        del bodies_data[0]\n        actor2_info = '{:^17}\\t{}\\t{:^8}\\n'.format('Actor2', 'Interval',\n                                                   'Motion')\n        start2, end2 = [0, 0]  # initial interval for actor2 (virtual)\n        while len(bodies_data) > 0:\n            bodyID, actor = bodies_data[0]\n            start, end = actor['interval'][0], actor['interval'][-1]\n            if min(end1, end) - max(start1,\n                                    start) <= 0:  # no overlap with actor1\n                joints[start:end + 1, :75] = actor['joints'].reshape(-1, 75)\n                colors[start:end + 1, 0] = actor['colors']\n                actor1_info += '{}\\t{:^8}\\t{:f}\\n'.format("
        },
        {
            "comment": "This function extracts and denoises joint positions and color locations from raw skeleton sequences. It takes intervals of actor1 and actor2, updates their intervals if there's no overlap, and then stores the information in separate variables. Finally, it writes the information to a text file.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":377-402",
            "content": "                    bodyID, str([start, end]), actor['motion'])\n                # Update the interval of actor1\n                start1 = min(start, start1)\n                end1 = max(end, end1)\n            elif min(end2, end) - max(start2,\n                                      start) <= 0:  # no overlap with actor2\n                joints[start:end + 1, 75:] = actor['joints'].reshape(-1, 75)\n                colors[start:end + 1, 1] = actor['colors']\n                actor2_info += '{}\\t{:^8}\\t{:f}\\n'.format(\n                    bodyID, str([start, end]), actor['motion'])\n                # Update the interval of actor2\n                start2 = min(start, start2)\n                end2 = max(end, end2)\n            del bodies_data[0]\n        bodies_info += ('\\n' + actor1_info + '\\n' + actor2_info)\n    with open(osp.join(actors_info_dir, ske_name + '.txt'), 'w') as fw:\n        fw.write(bodies_info + '\\n')\n    return joints, colors\ndef get_raw_denoised_data():\n    \"\"\"\n    Get denoised data (joints positions and color locations) from raw skeleton sequences."
        },
        {
            "comment": "This code reads raw skeleton data from a file, then processes and reshapes the 3D positions of each joint into a 75-dimensional vector for each frame. If there's only one actor, it fills zeros to complete the 150-dimensional vector. It selects the main and second actors based on motion amount. The resulting 2D arrays are stored in a list and serialized into a cPickle file. Additionally, log files record the filename and actors' information for skeleton sequences with two or more actors. The code also generates RGB+skeleton videos for better visualization.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":404-418",
            "content": "    For each frame of a skeleton sequence, an actor's 3D positions of 25 joints represented\n    by an 2D array (shape: 25 x 3) is reshaped into a 75-dim vector by concatenating each\n    3-dim (x, y, z) coordinates along the row dimension in joint order. Each frame contains\n    two actor's joints positions constituting a 150-dim vector. If there is only one actor,\n    then the last 75 values are filled with zeros. Otherwise, select the main actor and the\n    second actor based on the motion amount. Each 150-dim vector as a row vector is put into\n    a 2D numpy array where the number of rows equals the number of valid frames. All such\n    2D arrays are put into a list and finally the list is serialized into a cPickle file.\n    For the skeleton sequence which contains two or more actors (mostly corresponds to the\n    last 11 classes), the filename and actors' information are recorded into log files.\n    For better understanding, also generate RGB+skeleton videos for visualization.\n    \"\"\"\n    with open(raw_data_file, 'rb') as fr:  # load raw skeletons data"
        },
        {
            "comment": "Code reads raw skeleton sequence data from file, counts the number of sequences, and processes each sequence by extracting joints and color data. It handles single or multiple actors in a sequence, removes missing frames if necessary, and stores processed data into separate lists for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":419-444",
            "content": "        raw_skes_data = pickle.load(fr)\n    num_skes = len(raw_skes_data)\n    print('Found %d available skeleton sequences.' % num_skes)\n    raw_denoised_joints = []\n    raw_denoised_colors = []\n    frames_cnt = []\n    for (idx, bodies_data) in enumerate(raw_skes_data):\n        ske_name = bodies_data['name']\n        print('Processing %s' % ske_name)\n        num_bodies = len(bodies_data['data'])\n        if num_bodies == 1:  # only 1 actor\n            num_frames = bodies_data['num_frames']\n            body_data = list(bodies_data['data'].values())[0]\n            joints, colors = get_one_actor_points(body_data, num_frames)\n        else:  # more than 1 actor, select two main actors\n            joints, colors = get_two_actors_points(bodies_data)\n            # Remove missing frames\n            joints, colors = remove_missing_frames(ske_name, joints, colors)\n            num_frames = joints.shape[0]  # Update\n            # Visualize selected actors' skeletons on RGB videos.\n        raw_denoised_joints.append(joints)"
        },
        {
            "comment": "The code iterates over a set of skes, appends raw denoised joints and colors to lists, prints progress, and saves the data into pickle files and text file. It also counts missing data and reports it at the end.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/get_raw_denoised_data.py\":445-470",
            "content": "        raw_denoised_colors.append(colors)\n        frames_cnt.append(num_frames)\n        if (idx + 1) % 1000 == 0:\n            print('Processed: %.2f%% (%d / %d), ' % \\\n                  (100.0 * (idx + 1) / num_skes, idx + 1, num_skes) + \\\n                  'Missing count: %d' % missing_count)\n    raw_skes_joints_pkl = osp.join(save_path, 'raw_denoised_joints.pkl')\n    with open(raw_skes_joints_pkl, 'wb') as f:\n        pickle.dump(raw_denoised_joints, f, pickle.HIGHEST_PROTOCOL)\n    raw_skes_colors_pkl = osp.join(save_path, 'raw_denoised_colors.pkl')\n    with open(raw_skes_colors_pkl, 'wb') as f:\n        pickle.dump(raw_denoised_colors, f, pickle.HIGHEST_PROTOCOL)\n    frames_cnt = np.array(frames_cnt, dtype=np.int)\n    np.savetxt(osp.join(save_path, 'frames_cnt.txt'), frames_cnt, fmt='%d')\n    print('Saved raw denoised positions of {} frames into {}'.format(\n        np.sum(frames_cnt), raw_skes_joints_pkl))\n    print('Found %d files that have missing data' % missing_count)\nif __name__ == '__main__':\n    get_raw_denoised_data()"
        }
    ]
}