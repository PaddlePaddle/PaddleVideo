{
    "summary": "This code initializes a PaddlePaddle model for video training, sets up feeds and outputs, configures loss and optimizer, builds the model, prepares programs, trains, logs, and saves it. The main function handles arguments, checks save directory, and executes the training process.",
    "details": [
        {
            "comment": "The code imports necessary libraries and modules, enables static mode for PaddlePaddle, initializes a model (AttentionLstmErnie), defines train_with_pyreader function, and handles config file operations. It follows the Apache License 2.0 and provides information for obtaining the license.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":0-33",
            "content": "\"\"\"\ntrain main\n\"\"\"\n#  Copyright (c) 2019 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport os\nimport sys\nimport time\nimport argparse\nimport logging\nimport numpy as np\nimport paddle\npaddle.enable_static()\nimport paddle.static as static\nfrom accuracy_metrics import MetricsCalculator\nfrom datareader import get_reader\nfrom config import print_configs, merge_configs, parse_config\nfrom models.attention_lstm_ernie import AttentionLstmErnie\nfrom utils import init_pretraining_params, train_with_pyreader"
        },
        {
            "comment": "This code sets up the logging configuration and parses command-line arguments for training a video model using Paddle Video. The default model name is 'BaiduNet', and the config file path is 'configs/conf.txt'. It also allows setting the batch size, learning rate, and pretrain weights through command-line flags.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":36-70",
            "content": "logging.root.handlers = []\nFORMAT = '[%(levelname)s: %(filename)s: %(lineno)4d]: %(message)s'\nlogging.basicConfig(level=logging.INFO, format=FORMAT, stream=sys.stdout)\nlogger = logging.getLogger(__name__)\ndef parse_args():\n    \"\"\"parse_args\n    \"\"\"\n    parser = argparse.ArgumentParser(\"Paddle Video train script\")\n    parser.add_argument(\n        '--model_name',\n        type=str,\n        default='BaiduNet',\n        help='name of model to train.')\n    parser.add_argument(\n        '--config',\n        type=str,\n        default='configs/conf.txt',\n        help='path to config file of model')\n    parser.add_argument(\n        '--batch_size',\n        type=int,\n        default=None,\n        help='training batch size. None to use config file setting.')\n    parser.add_argument(\n        '--learning_rate',\n        type=float,\n        default=None,\n        help='learning rate use for training. None to use config file setting.')\n    parser.add_argument(\n        '--pretrain',\n        type=str,\n        default=None,\n        help='path to pretrain weights. None to use default weights path in  ~/.paddle/weights.'"
        },
        {
            "comment": "This code snippet from the PaddleVideo library's MultimodalVideoTag application defines command line argument options for training. Options include resuming training, GPU usage, disabling pyreader, memory optimization during training, epoch number, validation interval, and saving directory.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":71-104",
            "content": "    )\n    parser.add_argument(\n        '--resume',\n        type=str,\n        default=None,\n        help='path to resume training based on previous checkpoints. '\n        'None for not resuming any checkpoints.')\n    parser.add_argument(\n        '--use_gpu', type=bool, default=True, help='default use gpu.')\n    parser.add_argument(\n        '--no_use_pyreader',\n        action='store_true',\n        default=False,\n        help='whether to use pyreader')\n    parser.add_argument(\n        '--no_memory_optimize',\n        action='store_true',\n        default=False,\n        help='whether to use memory optimize in train')\n    parser.add_argument(\n        '--epoch_num',\n        type=int,\n        default=0,\n        help='epoch number, 0 for read from config file')\n    parser.add_argument(\n        '--valid_interval',\n        type=int,\n        default=1,\n        help='validation epoch interval, 0 for no validation.')\n    parser.add_argument(\n        '--save_dir',\n        type=str,\n        default='checkpoints',\n        help='directory name to save train snapshoot')"
        },
        {
            "comment": "This code defines command-line arguments for the mini-batch interval to log and the save filename, parses the configuration file, creates train and valid models based on the model name and configurations, sets the maximum number of training steps, and prepares static programs for building the model.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":105-135",
            "content": "    parser.add_argument(\n        '--log_interval',\n        type=int,\n        default=10,\n        help='mini-batch interval to log.')\n    parser.add_argument(\n        '--save_log_name',\n        type=str,\n        default='train_val',\n        help='save to tensorboard filename recommand model name.')\n    args = parser.parse_args()\n    return args\ndef train(args):\n    \"\"\"train main\n    \"\"\"\n    # parse config\n    config = parse_config(args.config)\n    train_config = merge_configs(config, 'train', vars(args))\n    valid_config = merge_configs(config, 'valid', vars(args))\n    print_configs(train_config, 'Train')\n    train_model = AttentionLstmErnie(args.model_name, train_config, mode='train')\n    valid_model = AttentionLstmErnie(args.model_name, valid_config, mode='valid')\n    max_train_steps = train_config.TRAIN.epoch * train_config.TRAIN.num_samples // train_config.TRAIN.batch_size\n    print('max train steps %d' % (max_train_steps))\n    # build model\n    startup = static.Program()\n    train_prog = static.Program()\n    with static.program_guard(train_prog, startup):"
        },
        {
            "comment": "This code snippet prepares the model for training by setting up feeds, outputs, loss, and optimizer. It also enables memory optimization if specified by arguments.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":136-159",
            "content": "        paddle.disable_static()\n        train_model.build_input(use_pyreader=True)\n        train_model.build_model()\n            # for the input, has the form [data1, data2,..., label], so train_feeds[-1] is label\n        train_feeds = train_model.feeds()\n        train_feeds[-1].persistable = True\n            # for the output of classification model, has the form [pred]\n        train_outputs = train_model.outputs()\n        for output in train_outputs:\n            output.persistable = True\n        train_loss = train_model.loss()\n        train_loss.persistable = True\n            # outputs, loss, label should be fetched, so set persistable to be true\n        optimizer = train_model.optimizer()\n        optimizer.minimize(train_loss)\n        train_pyreader = train_model.pyreader()\n        paddle.enable_static()\n    if not args.no_memory_optimize:\n        paddle.distributed.transpiler.memory_optimize(train_prog)\n    valid_prog = static.Program()\n    with static.program_guard(valid_prog, startup):\n        paddle.disable_static()"
        },
        {
            "comment": "The code is building the model, setting up executor and place (CPU or GPU), checking if resume weights exist to load them if necessary, and initializing pre-trained parameters for Ernie model.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":160-189",
            "content": "        valid_model.build_input(True)\n        valid_model.build_model()\n        valid_feeds = valid_model.feeds()\n        valid_outputs = valid_model.outputs()\n        valid_loss = valid_model.loss()\n        valid_pyreader = valid_model.pyreader()\n        paddle.enable_static()\n    place = paddle.CUDAPlace(0) if args.use_gpu else paddle.CPUPlace()\n    exe = static.Executor(place)\n    exe.run(startup)\n    if args.resume:\n        # if resume weights is given, load resume weights directly\n        assert os.path.exists(args.resume), \\\n            \"Given resume weight dir {} not exist.\".format(args.resume)\n        def if_exist(var):\n            \"\"\"if_exist\n            \"\"\"\n            return os.path.exists(os.path.join(args.resume, var.name))\n        print('resuming ,,,,,,,,,,,,,,')\n        paddle.fluid.io.load_persistables(\n                    exe, '', main_program=train_prog, filename=args.resume)\n    else:\n        # load ernie pretrain model\n        init_pretraining_params(exe,\n                                train_config.TRAIN.ernie_pretrain_dict_path,"
        },
        {
            "comment": "Loading pre-trained weights if provided, enabling inplace for faster execution and creating compiled programs with data parallelism for both training and validation programs. If not using PyReader and GPU is enabled, it sets the device list to use CUDA places.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":190-212",
            "content": "                                main_program=train_prog)\n        # if not in resume mode, load pretrain weights\n        # this pretrain may be only audio or video\n        if args.pretrain:\n            assert os.path.exists(args.pretrain), \\\n                \"Given pretrain weight dir {} not exist.\".format(args.pretrain)\n        if args.pretrain:\n            train_model.load_test_weights_file(exe, args.pretrain, train_prog, place)\n    build_strategy = paddle.static.BuildStrategy()\n    build_strategy.enable_inplace = True\n    compiled_train_prog = static.CompiledProgram(\n        train_prog).with_data_parallel(loss_name=train_loss.name,\n                                       build_strategy=build_strategy)\n    compiled_valid_prog = static.CompiledProgram(\n        valid_prog).with_data_parallel(share_vars_from=compiled_train_prog,\n                                       build_strategy=build_strategy)\n    # get reader\n    bs_denominator = 1\n    if (not args.no_use_pyreader) and args.use_gpu:\n        dev_list = static.cuda_places()"
        },
        {
            "comment": "This code sets the batch size for training and validation based on the length of the development list. It initializes train and valid readers with these batch sizes, decorates them with specified places, and creates MetricsCalculator objects to get metrics for training and validation.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":213-230",
            "content": "        bs_denominator = len(dev_list)\n    train_config.TRAIN.batch_size = int(train_config.TRAIN.batch_size /\n                                        bs_denominator)\n    valid_config.VALID.batch_size = int(valid_config.VALID.batch_size /\n                                        bs_denominator)\n    train_reader = get_reader(args.model_name.upper(), 'train', train_config)\n    valid_reader = get_reader(args.model_name.upper(), 'valid', valid_config)\n    exe_places = static.cuda_places() if args.use_gpu else static.cpu_places()\n    train_pyreader.decorate_sample_list_generator(train_reader,\n                                                  places=exe_places)\n    valid_pyreader.decorate_sample_list_generator(valid_reader,\n                                                  places=exe_places)\n    # get metrics\n    train_metrics = MetricsCalculator(args.model_name.upper(), 'train', train_config)\n    valid_metrics = MetricsCalculator(args.model_name.upper(), 'valid', valid_config)\n    # print(\"****************************valid_metrics\", valid_metrics.get())"
        },
        {
            "comment": "The code initializes training and validation fetch lists, sets the number of epochs based on argument or model default, then trains the model using the specified executor, programs, feeds, and fetch lists. It also handles logging intervals, valid intervals, save directory, and save model name. The main function parses arguments, checks if the save directory exists, and calls the train function to execute the training process.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/MultimodalVideoTag/scenario_lib/train.py\":231-262",
            "content": "    train_fetch_list = [train_loss.name] + [x.name for x in train_outputs\n                                            ] + [train_feeds[-1].name]\n    valid_fetch_list = [valid_loss.name] + [x.name for x in valid_outputs\n                                            ] + [valid_feeds[-1].name]\n    epochs = args.epoch_num or train_model.epoch_num()\n    train_with_pyreader(\n        exe,\n        train_prog,\n        compiled_train_prog,\n        train_pyreader,\n        train_fetch_list,\n        train_metrics,\n        epochs=epochs,\n        log_interval=args.log_interval,\n        valid_interval=args.valid_interval,\n        save_dir=args.save_dir,\n        save_model_name=args.model_name,\n        test_exe=compiled_valid_prog,\n        test_pyreader=valid_pyreader,\n        test_fetch_list=valid_fetch_list,\n        test_metrics=valid_metrics)\nif __name__ == \"__main__\":\n    args = parse_args()\n    logger.info(args)\n    if not os.path.exists(args.save_dir):\n        os.makedirs(args.save_dir)\n    train(args)"
        }
    ]
}