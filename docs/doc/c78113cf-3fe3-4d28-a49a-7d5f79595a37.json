{
    "summary": "The PaddleVideo library's VideoDecoder class decodes mp4 files into frames, handles RGB frames and audio, and provides data with masks. It includes functions for decoding, dequantizing feature vectors, and making one-hot labels.",
    "details": [
        {
            "comment": "This code is for a VideoDecoder class in the PaddleVideo library. It decodes mp4 files into frames as part of a pipeline. The class takes a file path argument and performs mp4 decode operations using the __call__ method, which processes results returned.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoQualityAssessment/paddlevideo/loader/pipelines/decode.py\":0-41",
            "content": "\"\"\"\n#  Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nimport sys\nfrom io import BytesIO\nimport os\nimport random\nimport numpy as np\nimport pickle\nimport cv2\nfrom ..registry import PIPELINES\n@PIPELINES.register()\nclass VideoDecoder(object):\n    \"\"\"\n    Decode mp4 file to frames.\n    Args:\n        filepath: the file path of mp4 file\n    \"\"\"\n    def __init__(self):\n        pass\n    def __call__(self, results):\n        \"\"\"\n        Perform mp4 decode operations.\n        return:"
        },
        {
            "comment": "This code defines three classes for decoding different types of data: video, frames, and features. The VideoDecoder reads a video file frame by frame, the FrameDecoder parses results as individual frames, and the FeatureDecoder handles feature decode operations like YouTube8M. The results are stored in 'frames', 'frames_len', and 'format' fields respectively.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoQualityAssessment/paddlevideo/loader/pipelines/decode.py\":42-79",
            "content": "            List where each item is a numpy array after decoder.\n        \"\"\"\n        #XXX get info from results!!!\n        file_path = results['filename']\n        cap = cv2.VideoCapture(file_path)\n        videolen = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\n        sampledFrames = []\n        for i in range(videolen):\n            ret, frame = cap.read()\n            # maybe first frame is empty\n            if ret == False:\n                continue\n            img = frame[:, :, ::-1]\n            sampledFrames.append(img)\n        results['frames'] = sampledFrames\n        results['frames_len'] = len(sampledFrames)\n        results['format'] = 'video'\n        return results\n@PIPELINES.register()\nclass FrameDecoder(object):\n    \"\"\"just parse results\n    \"\"\"\n    def __init__(self):\n        pass\n    def __call__(self, results):\n        results['format'] = 'frame'\n        return results\n@PIPELINES.register()\nclass FeatureDecoder(object):\n    \"\"\"\n        Perform feature decode operations.e.g.youtube8m\n    \"\"\"\n    def __init__(self, num_classes, max_len=512, has_label=True):"
        },
        {
            "comment": "This code is part of a decoding pipeline that loads and preprocesses data from a .pkl file. It extracts RGB frames, audio, and labels (if available), performs dequantization, and applies padding as needed. The results are returned as numpy arrays for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoQualityAssessment/paddlevideo/loader/pipelines/decode.py\":80-112",
            "content": "        self.max_len = max_len\n        self.num_classes = num_classes\n        self.has_label = has_label\n    def __call__(self, results):\n        \"\"\"\n        Perform feature decode operations.\n        return:\n            List where each item is a numpy array after decoder.\n        \"\"\"\n        #1. load pkl\n        #2. parse to rgb/audio/\n        #3. padding\n        filepath = results['filename']\n        data = pickle.load(open(filepath, 'rb'), encoding='bytes')\n        record = data\n        nframes = record[b'nframes']\n        rgb = record[b'feature'].astype(float)\n        audio = record[b'audio'].astype(float)\n        if self.has_label:\n            label = record[b'label']\n            one_hot_label = self.make_one_hot(label, self.num_classes)\n        rgb = rgb[0:nframes, :]\n        audio = audio[0:nframes, :]\n        rgb = self.dequantize(rgb,\n                              max_quantized_value=2.,\n                              min_quantized_value=-2.)\n        audio = self.dequantize(audio,\n                                max_quantized_value=2,"
        },
        {
            "comment": "The code snippet initializes a list of feature paddings, lengths, and masks for both rgb and audio data. It iterates through the two types of data (rgb and audio) to populate the results dictionary with information about each type of data, including its length and padded feature data along with their respective masks.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoQualityAssessment/paddlevideo/loader/pipelines/decode.py\":113-138",
            "content": "                                min_quantized_value=-2)\n        if self.has_label:\n            results['labels'] = one_hot_label.astype(\"float32\")\n        feat_pad_list = []\n        feat_len_list = []\n        mask_list = []\n        vitem = [rgb, audio]\n        for vi in range(2):  #rgb and audio\n            if vi == 0:\n                prefix = \"rgb_\"\n            else:\n                prefix = \"audio_\"\n            feat = vitem[vi]\n            results[prefix + 'len'] = feat.shape[0]\n            #feat pad step 1. padding\n            feat_add = np.zeros((self.max_len - feat.shape[0], feat.shape[1]),\n                                dtype=np.float32)\n            feat_pad = np.concatenate((feat, feat_add), axis=0)\n            results[prefix + 'data'] = feat_pad.astype(\"float32\")\n            #feat pad step 2. mask\n            feat_mask_origin = np.ones(feat.shape, dtype=np.float32)\n            feat_mask_add = feat_add\n            feat_mask = np.concatenate((feat_mask_origin, feat_mask_add),\n                                       axis=0)"
        },
        {
            "comment": "The code contains functions for decoding, dequantizing feature vectors, and making one-hot labels. The decode function stores the feature mask in a dictionary, the dequantize function scales and translates the quantized values back to float format, and the make_one_hot function creates one-hot encoded labels from given indices.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoQualityAssessment/paddlevideo/loader/pipelines/decode.py\":139-164",
            "content": "            results[prefix + 'mask'] = feat_mask.astype(\"float32\")\n        return results\n    def dequantize(self,\n                   feat_vector,\n                   max_quantized_value=2.,\n                   min_quantized_value=-2.):\n        \"\"\"\n        Dequantize the feature from the byte format to the float format\n        \"\"\"\n        assert max_quantized_value > min_quantized_value\n        quantized_range = max_quantized_value - min_quantized_value\n        scalar = quantized_range / 255.0\n        bias = (quantized_range / 512.0) + min_quantized_value\n        return feat_vector * scalar + bias\n    def make_one_hot(self, label, dim=3862):\n        \"\"\"make one hot\"\"\"\n        one_hot_label = np.zeros(dim)\n        one_hot_label = one_hot_label.astype(float)\n        for ind in label:\n            one_hot_label[int(ind)] = 1\n        return one_hot_label"
        }
    ]
}