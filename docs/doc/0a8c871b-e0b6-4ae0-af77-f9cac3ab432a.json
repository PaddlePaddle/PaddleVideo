{
    "summary": "The code introduces a new \"FeaturePadding\" class to PaddlePaddle library, handles data preprocessing for multimodal tasks, and provides masking, region selection, and action perturbation functions for PaddleVideo.",
    "details": [
        {
            "comment": "This code is part of a PaddlePaddle video analysis library. It registers a new class called \"FeaturePadding\" which performs feature padding to target shape. It imports necessary libraries and packages including decord, PIL, numpy, json, paddlenlp for ActBERT, and the PIPELINES registry.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":0-34",
            "content": "# copyright (c) 2021 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport random\nimport numpy as np\nfrom PIL import Image\nimport decord as de\nimport copy\nimport json\nfrom ..registry import PIPELINES\ntry:\n    from paddlenlp.transformers import BertTokenizer\nexcept ImportError as e:\n    print(\n        f\"Warning! {e}, [paddlenlp] package and it's dependencies is required for ActBERT.\"\n    )\n@PIPELINES.register()\nclass FeaturePadding(object):\n    \"\"\"\n    Padding feature to target shape.\n    \"\"\""
        },
        {
            "comment": "This code defines a class with an __init__ method and a __call__ method. The __init__ method initializes the maximum number of regions (36) and actions (5). The __call__ method takes in results as input, including feature packs for image and action data. It pads the features to their maximum allowed dimensions with zeroes if there are less than the specified maximum. This is useful for maintaining consistent input sizes in machine learning models.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":35-58",
            "content": "    def __init__(self, max_region_num=36, max_action_num=5):\n        self.max_region_num = max_region_num\n        self.max_action_num = max_action_num\n    def __call__(self, results):\n        \"\"\"\n        Padding feature.\n        \"\"\"\n        pack_feature = results['feature']\n        tokenizer = results['tokenizer']\n        image_feature_wp, image_target_wp, image_location_wp, \\\n                num_boxes,  image_h, image_w, image_id, caption, \\\n                action_feature_wp, action_target_wp, num_actions = pack_feature\n        image_feature = np.zeros((self.max_region_num, 2048), dtype=np.float32)\n        image_target = np.zeros((self.max_region_num, 1601), dtype=np.float32)\n        image_location = np.zeros((self.max_region_num, 5), dtype=np.float32)\n        action_feature = np.zeros((self.max_action_num, 2048), dtype=np.float32)\n        action_target = np.zeros((self.max_action_num, ), dtype=np.int64)\n        num_boxes = int(num_boxes)\n        image_feature[:num_boxes] = image_feature_wp\n        image_target[:num_boxes] = image_target_wp"
        },
        {
            "comment": "This code segment is responsible for resizing and normalizing the image and action feature coordinates, as well as deep copying the features. It also initializes the results dictionary with keys for image_feat and image_target. This appears to be part of a data preprocessing step in a multimodal pipeline.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":59-80",
            "content": "        image_location[:num_boxes, :4] = image_location_wp\n        image_location[:, 4] = (image_location[:, 3] - image_location[:, 1]) * (\n            image_location[:, 2] - image_location[:, 0]) / (float(image_w) *\n                                                            float(image_h))\n        image_location[:, 0] = image_location[:, 0] / float(image_w)\n        image_location[:, 1] = image_location[:, 1] / float(image_h)\n        image_location[:, 2] = image_location[:, 2] / float(image_w)\n        image_location[:, 3] = image_location[:, 3] / float(image_h)\n        image_feature = copy.deepcopy(image_feature)\n        image_target = copy.deepcopy(image_target)\n        num_actions = int(num_actions)\n        action_feature[:num_actions] = action_feature_wp\n        action_target[:num_actions] = action_target_wp\n        action_feature = copy.deepcopy(action_feature)\n        action_target = copy.deepcopy(action_target)\n        results = dict(image_feat=image_feature,\n                       image_target=image_target,"
        },
        {
            "comment": "The code defines a pipeline that randomly selects captions for the NSP task. It takes caption paths as input and returns random captions. The class has an `__init__` method to initialize the caption path, a `select_caption` method to randomly choose one from multiple captions, a `get_random_caption` method to select a random caption from all provided captions, and finally a `random_cap` method that combines these functionalities.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":81-112",
            "content": "                       caption=caption,\n                       image_loc=image_location,\n                       num_boxes=int(num_boxes),\n                       action_feat=action_feature,\n                       action_target=action_target,\n                       num_actions=int(num_actions),\n                       tokenizer=tokenizer)\n        return results\n@PIPELINES.register()\nclass RandomCap(object):\n    def __init__(self, caption_path):\n        \"\"\"\n        Random Caption for NSP task\n        \"\"\"\n        self.caption_path = caption_path\n    def select_caption(self, caption):\n        captions = caption.split('!')\n        rind = random.randint(0, len(captions) - 1)\n        caption = captions[rind]\n        return caption\n    def get_random_caption(self, all_captions):\n        num_caps = len(all_captions)\n        rand_doc_idx = random.randint(0, num_caps - 1)\n        caption = all_captions[rand_doc_idx]\n        caption = self.select_caption(caption)\n        return caption\n    def random_cap(self, caption, all_captions):"
        },
        {
            "comment": "The code is part of a multi-modal pipeline, where it randomly generates labels (0 or 1) and selects captions from a list. It also includes classes for tokenizing captions and applying random masks on the text data.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":113-150",
            "content": "        if random.random() > 0.5:\n            label = 0\n        else:\n            caption = self.get_random_caption(all_captions)\n            label = 1\n        return caption, label\n    def __call__(self, results):\n        caption = results['caption']\n        all_captions = list(json.load(open(self.caption_path, 'r')))\n        caption = self.select_caption(caption)\n        caption, label = self.random_cap(caption, all_captions)\n        results['caption'] = caption\n        results['is_next'] = label\n        return results\n@PIPELINES.register()\nclass Tokenize(object):\n    def __init__(self, ):\n        \"\"\"\n        Tokenize caption\n        \"\"\"\n        pass\n    def __call__(self, results):\n        caption = results['caption']\n        tokenizer = results['tokenizer']\n        tokens_caption = tokenizer.tokenize(caption)\n        results['caption'] = tokens_caption\n        return results\n@PIPELINES.register()\nclass RandomMask(object):\n    def __init__(self,\n                 max_seq_length=36,\n                 max_action_length=5,"
        },
        {
            "comment": "This code defines a class for loading multimodal data, including images and text, into TensorFlow datasets. The constructor takes the maximum sequence length, action length, and region length as arguments. It also includes functions to generate global image features and truncate a sequence pair if they exceed the maximum length.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":151-174",
            "content": "                 max_region_length=36):\n        self.max_seq_length = max_seq_length\n        self.max_action_length = max_action_length\n        self.max_region_length = max_region_length\n    def get_image_global_feature(self, image_feat, image_loc, image_mask):\n        g_image_feat = np.sum(image_feat, axis=0) / np.sum(\n            image_mask, axis=0, keepdims=True)\n        image_feat = np.concatenate(\n            [np.expand_dims(g_image_feat, axis=0), image_feat],\n            axis=0).astype(\"float32\")\n        g_image_loc = np.array([0, 0, 1, 1, 1]).astype(\"float32\")\n        image_loc = np.concatenate(\n            [np.expand_dims(g_image_loc, axis=0), image_loc], axis=0)\n        g_image_mask = np.array([1])\n        image_mask = np.concatenate([g_image_mask, image_mask], axis=0)\n        return image_feat, image_loc, image_mask\n    def _truncate_seq_pair(self, tokens_b, max_length):\n        \"\"\"Truncates a sequence pair in place to the maximum length.\n        This is a simple heuristic which will always truncate the longer sequence"
        },
        {
            "comment": "The code is implementing a method to mask random tokens in a sentence for Language Model (LM) tasks. It first ensures that all sequences have equal length by truncating one token at a time from the longer sequence, then randomly masks 15% of the tokens in each sequence. The method also includes logic to handle tokenizer and produces masked tokens along with their related labels for LM prediction.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":175-200",
            "content": "        one token at a time. This makes more sense than truncating an equal percent\n        of tokens from each, since if one sequence is very short then each token\n        that's truncated likely contains more information than a longer sequence.\n        \"\"\"\n        while True:\n            total_length = len(tokens_b)\n            if total_length <= max_length:\n                break\n            tokens_b.pop()\n    def random_word(self, tokens, tokenizer):\n        \"\"\"\n        Masking some random tokens for Language Model task with probabilities as in the original BERT paper.\n        Args:\n            tokens: list of str, tokenized sentence.\n            tokenizer: Tokenizer, object used for tokenization (we need it's vocab here)\n        Return:\n            (list of str, list of int), masked tokens and related labels for LM prediction\n        \"\"\"\n        output_label = []\n        for i, token in enumerate(tokens):\n            prob = random.random()\n            # mask token with 15% probability\n            if prob < 0.15:"
        },
        {
            "comment": "This code modifies tokens in a given input sequence by randomly replacing them with mask tokens, random tokens from the vocabulary, or keeping them unchanged. The probability of each action is controlled by a variable 'prob', which is normalized to ensure the total probability sums up to 1.0. The resulting modified sequence is appended to 'output_label' for further prediction. Additionally, it handles unknown words by replacing them with '[UNK]'.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":201-224",
            "content": "                prob /= 0.15\n                # 80% randomly change token to mask token\n                if prob < 0.8:\n                    tokens[i] = \"[MASK]\"\n                # 10% randomly change token to random token\n                elif prob < 0.9:\n                    #tok = random.choice(list(tokenizer.vocab.items()))[0]\n                    tok = tokenizer.vocab.idx_to_token[random.randint(\n                        0,\n                        tokenizer.vocab_size,\n                    )]\n                    tokens[i] = tok\n                # rest 10% randomly keep current token\n                # append current token to output (we will predict these later)\n                try:\n                    output_label.append(tokenizer.vocab[token])\n                except KeyError:\n                    # For unknown words (should not occur with BPE vocab)\n                    output_label.append(tokenizer.vocab[\"[UNK]\"])\n                    print(\n                        \"Cannot find token '{}' in vocab. Using [UNK] insetad\"."
        },
        {
            "comment": "The code defines three functions: \"random_region\", \"mask_token\", and \"random_action\". These functions are responsible for randomly masking tokens, selecting a random region from an image feature map, and randomly perturbing action features respectively. The random_region function masks 15% of the tokens in the input, while the random_action function perturbs 20% of the action features.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":225-254",
            "content": "                        format(token))\n            else:\n                # no masking token (will be ignored by loss function later)\n                output_label.append(-1)\n        return tokens, output_label\n    def random_region(self, image_feat, image_loc, num_boxes):\n        output_label = []\n        for i in range(num_boxes):\n            prob = random.random()\n            # mask token with 15% probability\n            if prob < 0.15:\n                prob /= 0.15\n                # 80% randomly change token to mask token\n                if prob < 0.9:\n                    image_feat[i] = 0\n                # rest 20% randomly keep current token\n                # append current token to output (we will predict these later)\n                output_label.append(1)\n            else:\n                # no masking token (will be ignored by loss function later)\n                output_label.append(-1)\n        return image_feat, image_loc, output_label\n    def random_action(self, action_feat, action_target, num_actions):"
        },
        {
            "comment": "This code defines a function that applies random masking to an input sequence of actions. It randomly chooses to either replace 90% of the tokens with mask tokens, keep them unchanged (10%), or ignore them for loss calculation by setting their value to -1. The function takes as input various results from a pipeline and returns the masked action features and labels.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":255-284",
            "content": "        output_label = []\n        for i in range(num_actions):\n            prob = random.random()\n            # mask token with 15% probability\n            if prob < 0.15:\n                prob /= 0.15\n                # 90% randomly change token to mask token\n                if prob < 0.9:\n                    action_feat[i] = 0\n                # rest 10% randomly keep current token\n                # append current token to output (we will predict these later)\n                output_label.append(action_target[i])\n            else:\n                # no masking token (will be ignored by loss function later)\n                output_label.append(-1)\n        return action_feat, output_label\n    def __call__(self, results):\n        caption = results['caption']\n        tokenizer = results['tokenizer']\n        image_feat = results['image_feat']\n        image_loc = results['image_loc']\n        num_boxes = results['num_boxes']\n        action_feat = results['action_feat']\n        action_target = results['action_target']\n        num_actions = results['num_actions']"
        },
        {
            "comment": "This code is part of a multimodal pipeline that randomly selects words from the caption, regions from an image, and actions, then concatenates them using BERT's convention for sequence pairs. It also handles truncating the caption and assigning labels to the input features.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":285-307",
            "content": "        is_next = results['is_next']\n        image_target = results['image_target']\n        self._truncate_seq_pair(caption, self.max_seq_length - 2)\n        caption, caption_label = self.random_word(caption, tokenizer)\n        image_feat, image_loc, image_label = self.random_region(\n            image_feat, image_loc, num_boxes)\n        action_feat, action_label = self.random_action(action_feat,\n                                                       action_target,\n                                                       num_actions)\n        # concatenate lm labels and account for CLS, SEP, SEP\n        lm_label_ids = [-1] + caption_label + [-1]\n        # The convention in BERT is:\n        # (a) For sequence pairs:\n        #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n        #  type_ids: 0   0  0    0    0     0       0 0    1  1  1  1   1 1\n        # (b) For single sequences:\n        #  tokens:   [CLS] the dog is hairy . [SEP]\n        #  type_ids: 0   0   0   0  0     0 0\n        #"
        },
        {
            "comment": "This code prepares input data for a multimodal pipeline in PaddleVideo. It appends special tokens \"[CLS]\" and \"[SEP]\" to the token list, assigns segment ID 0 to all tokens (indicating first sequence), converts tokens to input IDs using tokenizer, and creates a mask with 1 for real tokens and 0 for padding tokens. This allows the model to learn sequences and use the [CLS] vector as a \"sentence vector\" for classification tasks.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":308-332",
            "content": "        # Where \"type_ids\" are used to indicate whether this is the first\n        # sequence or the second sequence. The embedding vectors for `type=0` and\n        # `type=1` were learned during pre-training and are added to the wordpiece\n        # embedding vector (and position vector). This is not *strictly* necessary\n        # since the [SEP] token unambigiously separates the sequences, but it makes\n        # it easier for the model to learn the concept of sequences.\n        #\n        # For classification tasks, the first vector (corresponding to [CLS]) is\n        # used as as the \"sentence vector\". Note that this only makes sense because\n        # the entire model is fine-tuned.\n        tokens = []\n        segment_ids = []\n        tokens.append(\"[CLS]\")\n        segment_ids.append(0)\n        for token in caption:\n            tokens.append(token)\n            segment_ids.append(0)\n        tokens.append(\"[SEP]\")\n        segment_ids.append(0)\n        input_ids = tokenizer.convert_tokens_to_ids(tokens)\n        # The mask has 1 for real tokens and 0 for padding tokens. Only real tokens are attended to."
        },
        {
            "comment": "Zero-padding visual, action, and input sequences to the maximum lengths. Asserting that all lists are of equal length after padding and match their respective max lengths.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":333-358",
            "content": "        input_mask = [1] * (len(input_ids))\n        image_mask = [1] * (num_boxes)\n        action_mask = [1] * (num_actions)\n        # Zero-pad up to the visual sequence length.\n        while len(image_mask) < self.max_region_length:\n            image_mask.append(0)\n            image_label.append(-1)\n        while len(action_mask) < self.max_action_length:\n            action_mask.append(0)\n            action_label.append(-1)\n        # Zero-pad up to the sequence length.\n        while len(input_ids) < self.max_seq_length:\n            input_ids.append(0)\n            input_mask.append(0)\n            segment_ids.append(0)\n            lm_label_ids.append(-1)\n        assert len(input_ids) == self.max_seq_length\n        assert len(input_mask) == self.max_seq_length\n        assert len(segment_ids) == self.max_seq_length\n        assert len(lm_label_ids) == self.max_seq_length\n        assert len(image_mask) == self.max_region_length\n        assert len(image_label) == self.max_region_length\n        assert len(action_mask) == self.max_action_length"
        },
        {
            "comment": "This code snippet is part of a pipeline function that asserts the length of 'action_label' matches the maximum allowed action length. It then calls another function to get global image features, and forms a list of feature arrays including input ids, action feature, image feature, location, segment ids, input mask, image mask, action label, lm_label_ids, is_next, image label, and image target. The results dictionary is updated with these features before the function returns.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/multimodal.py\":359-379",
            "content": "        assert len(action_label) == self.max_action_length\n        image_feat, image_loc, image_mask = self.get_image_global_feature(\n            image_feat, image_loc, np.array(image_mask))\n        features = [\n            np.array(input_ids),\n            action_feat,\n            image_feat,\n            image_loc,\n            np.array(segment_ids),\n            np.array(input_mask),\n            image_mask,\n            np.array(action_mask),\n            np.array(lm_label_ids),\n            np.array(action_label),\n            np.array(is_next),\n            np.array(image_label),\n            image_target,\n        ]\n        results['features'] = features\n        return results"
        }
    ]
}