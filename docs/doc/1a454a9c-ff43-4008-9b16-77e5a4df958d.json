{
    "summary": "The code defines a PaddleVideo classification head base class and function for loss/accuracy calculation, supporting binary, multi-class, and specific MRI scenarios with label smoothing. It also calculates top5 accuracy, hard/soft labels, and performs all-reduce operation in distributed training.",
    "details": [
        {
            "comment": "Base class for head part, all subclass should overwrite init_weights method for initializing weights.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/base.py\":0-33",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport numpy as np\nfrom abc import abstractmethod\nimport paddle\nimport paddle.nn as nn\nimport paddle.nn.functional as F\nfrom ..builder import build_loss\nfrom paddlevideo.utils import get_logger, get_dist_info\nlogger = get_logger(\"paddlevideo\")\nclass BaseHead(nn.Layer):\n    \"\"\"Base class for head part.\n    All head should subclass it.\n    All subclass should overwrite:\n    - Methods: ```init_weights```, initializing weights."
        },
        {
            "comment": "This code is defining a base class for a classification head in PaddleVideo. It has an `__init__` method that sets the number of classes, input channels, and loss configuration. It also builds the loss function using the provided configuration. The `forward` method must be implemented by any subclasses, as it defines how the head will run during model inference.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/base.py\":34-64",
            "content": "    - Methods: ```forward```, forward function.\n    Args:\n        num_classes (int): The number of classes to be classified.\n        in_channels (int): The number of channels in input feature.\n        loss_cfg (dict): Config for building loss. Default: dict(type='CrossEntropyLoss').\n        ls_eps (float): label smoothing epsilon. Default: 0. .\n    \"\"\"\n    def __init__(\n        self,\n        num_classes=None,\n        in_channels=None,\n        loss_cfg=dict(\n            name=\"CrossEntropyLoss\"\n        ),  #TODO(shipping): only pass a name or standard build cfg format.\n        #multi_class=False, NOTE(shipping): not supported now.\n        ls_eps=0.):\n        super().__init__()\n        self.num_classes = num_classes\n        self.in_channels = in_channels\n        self.loss_func = build_loss(loss_cfg)\n        #self.multi_class = multi_class NOTE(shipping): not supported now\n        self.ls_eps = ls_eps\n    @abstractmethod\n    def forward(self, x):\n        \"\"\"Define how the head is going to run.\n        \"\"\"\n        raise NotImplemented"
        },
        {
            "comment": "This function calculates the loss based on model output (scores) and target output (labels). It returns a dictionary containing 'loss', 'top1_acc', and 'top5_acc'. If labels are single, they are expanded. Label smoothing is applied if ls_eps is non-zero and not in valid mode. The loss function is used if label smoothing is not applicable. Top-1 and top-5 accuracy are also calculated if top-5 is set to True.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/base.py\":66-90",
            "content": "    def loss(self, scores, labels, valid_mode=False, if_top5=True, **kwargs):\n        \"\"\"Calculate the loss accroding to the model output ```scores```,\n           and the target ```labels```.\n        Args:\n            scores (paddle.Tensor): The output of the model.\n            labels (paddle.Tensor): The target output of the model.\n        Returns:\n            losses (dict): A dict containing field 'loss'(mandatory) and 'top1_acc', 'top5_acc'(optional).\n        \"\"\"\n        if len(labels) == 1:  #commonly case\n            labels = labels[0]\n            losses = dict()\n            if self.ls_eps != 0. and not valid_mode:  # label_smooth\n                loss = self.label_smooth_loss(scores, labels, **kwargs)\n            else:\n                loss = self.loss_func(scores, labels, **kwargs)\n            if if_top5:\n                top1, top5 = self.get_acc(scores, labels, valid_mode)\n                losses['top1'] = top1\n                losses['top5'] = top5\n                losses['loss'] = loss\n            else:"
        },
        {
            "comment": "This code handles different cases for classification tasks. For binary and multi-class tasks, it calculates top1 accuracy and loss, while for the specific case of MRI with three labels (mix_up), it applies label smoothing or regular loss function and averages results for each sample to get the final loss and top1 accuracy.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/base.py\":91-112",
            "content": "                top1 = self.get_acc(scores, labels, valid_mode, if_top5)\n                losses['top1'] = top1\n                losses['loss'] = loss\n            return losses\n        # MRI\u76ee\u524d\u4e8c\u5206\u7c7b\u65e0top5\n        elif len(labels) == 3:  # mix_up\n            labels_a, labels_b, lam = labels\n            lam = lam[0]  # get lam value\n            losses = dict()\n            if self.ls_eps != 0:\n                loss_a = self.label_smooth_loss(scores, labels_a, **kwargs)\n                loss_b = self.label_smooth_loss(scores, labels_b, **kwargs)\n            else:\n                loss_a = self.loss_func(scores, labels_a, **kwargs)\n                loss_b = self.loss_func(scores, labels_b, **kwargs)\n            loss = lam * loss_a + (1 - lam) * loss_b\n            if if_top5:\n                top1a, top5a = self.get_acc(scores, labels_a, valid_mode)\n                top1b, top5b = self.get_acc(scores, labels_b, valid_mode)\n                top1 = lam * top1a + (1 - lam) * top1b\n                top5 = lam * top5a + (1 - lam) * top5b"
        },
        {
            "comment": "Function defines a loss function for classification tasks, returning a dictionary of losses including top1 and overall loss. If valid_mode is True, calculates accuracy on validation set, otherwise on training set. Top1 accuracies for two sets are combined with specified lambda value to calculate final top1.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/base.py\":113-142",
            "content": "                losses['top1'] = top1\n                losses['top5'] = top5\n                losses['loss'] = loss\n            else:\n                top1a = self.get_acc(scores, labels_a, valid_mode, if_top5)\n                top1b = self.get_acc(scores, labels_b, valid_mode, if_top5)\n                top1 = lam * top1a + (1 - lam) * top1b\n                losses['top1'] = top1\n                losses['loss'] = loss\n            return losses\n        else:\n            raise NotImplemented\n    def label_smooth_loss(self, scores, labels, **kwargs):\n        \"\"\"\n        Args:\n            scores (paddle.Tensor): [N, num_classes]\n            labels (paddle.Tensor): [N, ]\n        Returns:\n            paddle.Tensor: [1,]\n        \"\"\"\n        if paddle.is_compiled_with_custom_device('npu'):\n            \"\"\"\n            Designed for the lack of temporary operators of NPU,\n            main idea is to split smooth loss into uniform distribution loss\n            and hard label calculation\n            \"\"\"\n            hard_loss = (1.0 - self.ls_eps) * F.cross_entropy(scores, labels)"
        },
        {
            "comment": "Code is for computing loss and accuracy in a classification model. If the hard label is given, it calculates uniform_loss based on scores and adds it to hard_loss for total loss. Otherwise, it computes soft labels using one-hot encoding and label smoothing, then calculates loss using the provided loss function with soft_label set to True. The get_acc function computes top1 and top5 accuracy, averages them across all cards if valid mode is on, and returns the accuracy.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/base.py\":143-163",
            "content": "            uniform_loss = (self.ls_eps / self.num_classes) * (\n                -F.log_softmax(scores, -1).sum(-1).mean(0))\n            loss = hard_loss + uniform_loss\n        else:\n            labels = F.one_hot(labels, self.num_classes)\n            labels = F.label_smooth(labels, epsilon=self.ls_eps)\n            labels = paddle.squeeze(labels, axis=1)\n            loss = self.loss_func(scores, labels, soft_label=True, **kwargs)\n        return loss\n    def get_acc(self, scores, labels, valid_mode, if_top5=True):\n        if if_top5:\n            top1 = paddle.metric.accuracy(input=scores, label=labels, k=1)\n            top5 = paddle.metric.accuracy(input=scores, label=labels, k=5)\n            _, world_size = get_dist_info()\n            #NOTE(shipping): deal with multi cards validate\n            if world_size > 1 and valid_mode:  #reduce sum when valid\n                paddle.distributed.all_reduce(\n                    top1, op=paddle.distributed.ReduceOp.SUM)\n                top1 = top1 / world_size\n                paddle.distributed.all_reduce("
        },
        {
            "comment": "This code calculates the top1 and optionally top5 accuracy for a classification task. If distributed training is enabled, it performs all-reduce operation on the calculated metrics to ensure consistency across multiple cards/devices. The reduction operation used is sum, and the results are divided by the total number of devices (world_size) to obtain an average value.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/base.py\":164-177",
            "content": "                    top5, op=paddle.distributed.ReduceOp.SUM)\n                top5 = top5 / world_size\n            return top1, top5\n        else:\n            top1 = paddle.metric.accuracy(input=scores, label=labels, k=1)\n            _, world_size = get_dist_info()\n            #NOTE(shipping): deal with multi cards validate\n            if world_size > 1 and valid_mode:  #reduce sum when valid\n                paddle.distributed.all_reduce(\n                    top1, op=paddle.distributed.ReduceOp.SUM)\n                top1 = top1 / world_size\n            return top1"
        }
    ]
}