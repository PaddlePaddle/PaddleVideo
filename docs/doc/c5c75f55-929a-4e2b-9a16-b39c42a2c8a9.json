{
    "summary": "The code processes ground truth data, generates output for bmn, and combines GT data for each frame. It selects video segments, defines instance parameters, converts label data to BMN format, and saves as a numpy array and JSON labeled file.",
    "details": [
        {
            "comment": "This code reads original ground truth (gts) data for action detection, sets the frame per second (fps), and generates output gts dict for bmn. It processes each sub-item in the gts_data['gts'], extracts the URL, maximum video length, and load features if not already present. The code then creates a new dictionary with fps and gts list as output gts data for bmn.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":0-41",
            "content": "\"\"\"\nget instance for bmn\n\u4f7f\u7528winds=40\u7684\u6ed1\u7a97\uff0c\u5c06\u6240\u6709\u5b50\u7a97\u53e3\u7684\u957f\u5ea6\u4e4b\u548c\u5c0f\u4e8ewinds\u7684\u8fdb\u884c\u5408\u5e76\n\u5408\u5e76\u540e\uff0c\u7236\u7a97\u53e3\u4ee3\u8868bmn\u8bad\u7ec3\u6570\u636e\uff0c\u5b50\u7a97\u53e3\u4ee3\u8868tsn\u8bad\u7ec3\u6570\u636e\n\"\"\"\nimport os\nimport sys\nimport json\nimport random\nimport pickle\nimport numpy as np\nbmn_window = 40\ndataset = \"../EuroCup2016\"\nfeat_dir = dataset + '/features'\nout_dir = dataset + '/input_for_bmn'\nlabel_files = {\n    'train': 'label_cls8_train.json',\n    'validation': 'label_cls8_val.json'\n}\nglobal fps\ndef gen_gts_for_bmn(gts_data):\n    \"\"\"\n    @param, gts_data, original gts for action detection\n    @return, gts_bmn, output gts dict for bmn\n    \"\"\"\n    fps = gts_data['fps']\n    gts_bmn = {'fps': fps, 'gts': []}\n    for sub_item in gts_data['gts']:\n        url = sub_item['url']\n        max_length = sub_item['total_frames']\n        # \u7279\u5f81\u63d0\u53d6\u6ca1\u6709\u83b7\u53d6\u6240\u6709\u5e27\u7279\u5f81\uff0c\u8fd9\u91ccload feature\u83b7\u53d6\u51c6\u786emax_length\n        #feat_path = feat_dir + '/' + os.path.basename(url).replace('.mp4', '.pkl')\n        #feature_video = pickle.load(open(feat_path, 'rb'))['features']\n        #max_length = int(len(feature_video) * 1.0 / fps)\n        gts_bmn['gts'].append({\n            'url': url,"
        },
        {
            "comment": "This code is filtering out sub-actions that exceed a specified duration (bmn_window). It then creates a root_action list from the remaining sub-actions. The code also keeps track of the before_id and after_id to create 'gts' dictionary entries, which include the before_id, after_id, and root_actions for each group of actions that do not exceed the bmn_window duration.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":42-68",
            "content": "            'total_frames': max_length,\n            'root_actions': []\n        })\n        sub_actions = sub_item['actions']\n        # duration > bmn_window\uff0c \u76f4\u63a5\u5220\u9664\n        for idx, sub_action in enumerate(sub_actions):\n            if sub_action['end_id'] - sub_action['start_id'] > bmn_window:\n                sub_actions.pop(idx)\n        root_actions = [sub_actions[0]]\n        # before_id, \u524d\u4e00\u52a8\u4f5c\u7684\u6700\u540e\u4e00\u5e27\n        # after_id, \u540e\u4e00\u52a8\u4f5c\u7684\u7b2c\u4e00\u5e27\n        before_id = 0\n        for idx in range(1, len(sub_actions)):\n            cur_action = sub_actions[idx]\n            duration = (cur_action['end_id'] - root_actions[0]['start_id'])\n            if duration > bmn_window:\n                after_id = cur_action['start_id']\n                gts_bmn['gts'][-1]['root_actions'].append({\n                    'before_id':\n                    before_id,\n                    'after_id':\n                    after_id,\n                    'actions':\n                    root_actions\n                })\n                before_id = root_actions[-1]['end_id']"
        },
        {
            "comment": "This function combines ground truth (GT) data for each frame within a bmn_window range. If there is only one action in the bmn_window, it takes that action; otherwise, it considers three actions: first, last, and all. It then creates segments based on these actions and returns the combined GT data.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":69-101",
            "content": "                root_actions = [cur_action]\n            else:\n                root_actions.append(cur_action)\n            if idx == len(sub_actions) - 1:\n                after_id = max_length\n                gts_bmn['gts'][-1]['root_actions'].append({\n                    'before_id':\n                    before_id,\n                    'after_id':\n                    after_id,\n                    'actions':\n                    root_actions\n                })\n    return gts_bmn\ndef combile_gts(gts_bmn, gts_process, mode):\n    \"\"\"\n    1\u3001bmn_window \u8303\u56f4\u5185\u53ea\u6709\u4e00\u4e2a\u52a8\u4f5c\uff0c\u53ea\u53d6\u4e00\u4e2a\u76ee\u6807\u6846\n    2\u3001bmn_window \u8303\u56f4\u5185\u6709\u591a\u4e2a\u52a8\u4f5c\uff0c\u53d6\u4e09\u4e2a\u76ee\u6807\u6846(\u7b2c\u4e00\u4e2a\u52a8\u4f5c\u3001\u6700\u540e\u4e00\u4e2a\u52a8\u4f5c\u3001\u6240\u6709\u52a8\u4f5c)\n    \"\"\"\n    global fps\n    fps = gts_process['fps']\n    duration_second = bmn_window * 1.0\n    duration_frame = bmn_window * fps\n    feature_frame = duration_frame\n    for item in gts_process['gts']:\n        url = item['url']\n        basename = os.path.basename(url).split('.')[0]\n        root_actions = item['root_actions']\n        for root_action in root_actions:\n            segments = []\n            # all actions"
        },
        {
            "comment": "This code appends segments to a list based on the number of actions in root_action. If there is more than one action, it separates the first and last action into their own segments using before_id and after_id values. Finally, it loops through the segments list using a for loop to assign before_id, after_id, and actions to each segment.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":102-127",
            "content": "            segments.append({\n                'actions': root_action['actions'],\n                'before_id': root_action['before_id'],\n                'after_id': root_action['after_id']\n            })\n            if len(root_action['actions']) > 1:\n                # first action\n                segments.append({\n                    'actions': [root_action['actions'][0]],\n                    'before_id':\n                    root_action['before_id'],\n                    'after_id':\n                    root_action['actions'][1]['start_id']\n                })\n                # last action\n                segments.append({\n                    'actions': [root_action['actions'][-1]],\n                    'before_id':\n                    root_action['actions'][-2]['end_id'],\n                    'after_id':\n                    root_action['after_id']\n                })\n            for segment in segments:\n                before_id = segment['before_id']\n                after_id = segment['after_id']\n                actions = segment['actions']"
        },
        {
            "comment": "This code selects a random segment of video from a list of actions, assigns a label to it, and stores the segment information in a dictionary. It uses the start and end IDs of each action to determine the range for the random start point and calculates the segment's position relative to the cur_start value. The code also handles edge cases where the box0 is less than or equal to box1 and creates the annotation dictionary with label and label_name information, as well as the segment duration in seconds.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":128-146",
            "content": "                box0 = int(max(actions[-1]['end_id'] - bmn_window, before_id))\n                box1 = int(min(actions[0]['start_id'], after_id - bmn_window))\n                if box0 <= box1:\n                    cur_start = random.randint(box0, box1)\n                    cur_end = cur_start + bmn_window\n                    name = '{}_{}_{}'.format(basename, cur_start, cur_end)\n                    annotations = []\n                    for action in actions:\n                        label = str(1.0 * action['label_ids'][0])\n                        label_name = action['label_names'][0]\n                        seg0 = 1.0 * (action['start_id'] - cur_start)\n                        seg1 = 1.0 * (action['end_id'] - cur_start)\n                        annotations.append({\n                            'segment': [seg0, seg1],\n                            'label': label,\n                            'label_name': label_name\n                        })\n                    gts_bmn[name] = {\n                        'duration_second': duration_second,"
        },
        {
            "comment": "The code defines a function `get_instance_for_bmn` that returns a dictionary containing various parameters for an instance, and another function `save_feature_to_numpy` which saves feature data to a file. The features are split into two types: image and pcm, stored in a dictionary named \"feature\" with keys 'image_feature' and 'pcm_feature'. The code then loops through the dictionaries, creating sub-dictionaries for each item with their corresponding start and end indexes, before saving them to a file.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":147-177",
            "content": "                        'duration_frame': duration_frame,\n                        'feature_frame': feature_frame,\n                        'subset': mode,\n                        'annotations': annotations\n                    }\n    return gts_bmn\ndef save_feature_to_numpy(gts_bmn, folder):\n    global fps\n    print('save feature for bmn ...')\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    process_gts_bmn = {}\n    for item, value in gts_bmn.items():\n        basename, start_id, end_id = item.split('_')\n        if not basename in process_gts_bmn:\n            process_gts_bmn[basename] = []\n        process_gts_bmn[basename].append({\n            'name': item,\n            'start': int(start_id),\n            'end': int(end_id)\n        })\n    for item, values in process_gts_bmn.items():\n        feat_path = os.path.join(feat_dir, item + '.pkl')\n        print(feat_path)\n        feature = pickle.load(open(feat_path, 'rb'))\n        image_feature = feature['image_feature']\n        pcm_feature = feature['pcm_feature']"
        },
        {
            "comment": "Reshapes pcm_feature for concatenation, sets min_length based on shorter of two feature arrays, continues if min_length is 0, slices image_feature and pcm_feature to match min_length, concatenates along axis 1 to create feature_video, iterates through values dictionary, creates save_cut_name path, calculates start and end frames in seconds, checks if end frame exceeds length of feature_video, removes key from gts_bmn if end_frame is greater than feature_video length, generates list of feature_video slices within range of start and end frames, converts to numpy array for floating point numbers, saves np_feature_cut as .npy file with name derived from value's 'name'. Returns gts_bmn dictionary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":179-204",
            "content": "        pcm_feature = pcm_feature.reshape((pcm_feature.shape[0] * 5, 640))\n        min_length = min(image_feature.shape[0], pcm_feature.shape[0])\n        if min_length == 0:\n            continue\n        image_feature = image_feature[:min_length, :]\n        pcm_feature = pcm_feature[:min_length, :]\n        feature_video = np.concatenate((image_feature, pcm_feature), axis=1)\n        for value in values:\n            save_cut_name = os.path.join(folder, value['name'])\n            start_frame = (value['start']) * fps\n            end_frame = (value['end']) * fps\n            if end_frame > len(feature_video):\n                del gts_bmn[value['name']]\n                continue\n            feature_cut = [\n                feature_video[i] for i in range(start_frame, end_frame)\n            ]\n            np_feature_cut = np.array(feature_cut, dtype=np.float32)\n            np.save(save_cut_name, np_feature_cut)\n    return gts_bmn\nif __name__ == \"__main__\":\n    if not os.path.exists(out_dir):\n        os.mkdir(out_dir)\n    gts_bmn = {}"
        },
        {
            "comment": "The code is iterating over the label_files, loading JSON data from each file, processing it for BMN format, combining it with existing gts_bmn, and saving the final result as a numpy array and JSON formatted label.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/FootballAction/datasets/script/get_instance_for_bmn.py\":205-215",
            "content": "    for item, value in label_files.items():\n        label_file = os.path.join(dataset, value)\n        gts_data = json.load(open(label_file, 'rb'))\n        gts_process = gen_gts_for_bmn(gts_data)\n        gts_bmn = combile_gts(gts_bmn, gts_process, item)\n    gts_bmn = save_feature_to_numpy(gts_bmn, out_dir + '/feature')\n    with open(out_dir + '/label.json', 'w', encoding='utf-8') as f:\n        data = json.dumps(gts_bmn, indent=4, ensure_ascii=False)\n        f.write(data)"
        }
    ]
}