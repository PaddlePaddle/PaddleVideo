{
    "summary": "This code defines custom loss functions for video modeling, including TMSE and GSTMSE, with the ActionSegmentationLoss class applying various criteria like regression, classification, and temporal segmentation losses.",
    "details": [
        {
            "comment": "The code defines a class TMSE, which is a temporal MSE loss function. It's inspired by the MS-TCN method proposed in CVPR2019 for action segmentation tasks.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":0-31",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# https://github.com/yiskw713/asrf/libs/loss_fn/__init__.py\nimport numpy as np\nimport pandas as pd\nimport paddle\nimport paddle.nn as nn\nimport paddle.nn.functional as F\nimport sys\nimport os\nfrom ..registry import LOSSES\nclass TMSE(nn.Layer):\n    \"\"\"\n    Temporal MSE Loss Function\n    Proposed in Y. A. Farha et al. MS-TCN: Multi-Stage Temporal Convolutional Network for ActionSegmentation in CVPR2019\n    arXiv: https://arxiv.org/pdf/1903.01945.pdf"
        },
        {
            "comment": "The code defines two classes: ASRF_Loss and GaussianSimilarityTMSE. The first class represents the Average Symmetric Ranking Forest Loss, while the second class is a Temporal MSE Loss Function with Gaussian Similarity Weighting. Both classes inherit from nn.Layer and have an __init__ method for initialization, as well as a forward method for calculating losses. The ASRF_Loss class uses an MSELoss function to calculate loss between predicted and ground truth frames, while the GaussianSimilarityTMSE class calculates temporal MSE with Gaussian similarity weighting.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":32-65",
            "content": "    \"\"\"\n    def __init__(self, threshold=4, ignore_index=255):\n        super().__init__()\n        self.threshold = threshold\n        self.ignore_index = ignore_index\n        self.mse = nn.MSELoss(reduction=\"none\")\n    def forward(self, preds, gts):\n        total_loss = 0.0\n        batch_size = preds.shape[0]\n        for pred, gt in zip(preds, gts):\n            pred = paddle.gather(pred,\n                                 paddle.nonzero(gt != self.ignore_index)[:, 0])\n            loss = self.mse(F.log_softmax(pred[:, 1:], axis=1),\n                            F.log_softmax(pred[:, :-1], axis=1))\n            loss = paddle.clip(loss, min=0, max=self.threshold**2)\n            total_loss += paddle.mean(loss)\n        return total_loss / batch_size\nclass GaussianSimilarityTMSE(nn.Layer):\n    \"\"\"\n    Temporal MSE Loss Function with Gaussian Similarity Weighting\n    \"\"\"\n    def __init__(self, threshold=4, sigma=1.0, ignore_index=255):\n        super().__init__()\n        self.threshold = threshold\n        self.ignore_index = ignore_index"
        },
        {
            "comment": "This code calculates a temporal MSE loss weighted by Gaussian similarity. It uses Paddle's nn.MSELoss function, with reduction set to \"none\". The forward method takes in the model's predictions (before softmax), ground truth and similarity index as inputs. It loops through each input, performs non-zero checks for gt != ignore_index, then gathers the relevant rows from the predicted values. It calculates gaussian similarity using the gathered data and the given sigma value. The calculated loss is returned.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":66-91",
            "content": "        self.mse = nn.MSELoss(reduction=\"none\")\n        self.sigma = sigma\n    def forward(self, preds, gts, sim_index):\n        \"\"\"\n        Args:\n            preds: the output of model before softmax. (N, C, T)\n            gts: Ground Truth. (N, T)\n            sim_index: similarity index. (N, C, T)\n        Return:\n            the value of Temporal MSE weighted by Gaussian Similarity.\n        \"\"\"\n        total_loss = 0.0\n        batch_size = preds.shape[0]\n        for pred, gt, sim in zip(preds, gts, sim_index):\n            pred = paddle.gather(pred,\n                                 paddle.nonzero(gt != self.ignore_index)[:, 0],\n                                 axis=1)\n            sim = paddle.gather(sim,\n                                paddle.nonzero(gt != self.ignore_index)[:, 0],\n                                axis=1)\n            # calculate gaussian similarity\n            diff = sim[:, 1:] - sim[:, :-1]\n            similarity = paddle.exp(\n                (-1 * paddle.norm(diff, axis=0)) / (2 * self.sigma**2))"
        },
        {
            "comment": "This code defines a class \"ASRF_Loss\" for calculating ASRF loss using temporal MSE and Gaussian similarity weighting. It also defines a class \"FocalLoss\" for focal loss calculation using CrossEntropyLoss with custom gamma and alpha parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":93-125",
            "content": "            # calculate temporal mse\n            loss = self.mse(F.log_softmax(pred[:, 1:], axis=1),\n                            F.log_softmax(pred[:, :-1], axis=1))\n            loss = paddle.clip(loss, min=0, max=self.threshold**2)\n            # gaussian similarity weighting\n            loss = similarity * loss\n            total_loss += paddle.mean(loss)\n        return total_loss / batch_size\nclass FocalLoss(nn.Layer):\n    def __init__(self,\n                 weight=None,\n                 size_average=True,\n                 batch_average=True,\n                 ignore_index=255,\n                 gamma=2.0,\n                 alpha=0.25):\n        super().__init__()\n        self.gamma = gamma\n        self.alpha = alpha\n        self.batch_average = batch_average\n        self.criterion = nn.CrossEntropyLoss(weight=weight,\n                                             ignore_index=ignore_index,\n                                             size_average=size_average)\n    def forward(self, logit, target):\n        n, _, _ = logit.size()"
        },
        {
            "comment": "This code defines an ActionSegmentationLoss class, which is a loss function for action segmentation tasks. It allows the user to choose from various loss functions including Cross Entropy Loss (CE), Focal Loss, Temporal MSE (TMSE), and Gaussian Similarity TMSE (GSTMSE). The user can specify parameters such as num_classes, file_path, label_path, ce, focal, tmse, gstmse, weight, threshold, ignore_index, ce_weight, focal_weight, and tmse_weight. The class initializes the chosen loss functions and calculates the overall loss based on user inputs.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":127-166",
            "content": "        logpt = -self.criterion(logit, target.long())\n        pt = paddle.exp(logpt)\n        if self.alpha is not None:\n            logpt *= self.alpha\n        loss = -((1 - pt)**self.gamma) * logpt\n        if self.batch_average:\n            loss /= n\n        return loss\nclass ActionSegmentationLoss(nn.Layer):\n    \"\"\"\n    Loss Function for Action Segmentation\n    You can choose the below loss functions and combine them.\n        - Cross Entropy Loss (CE)\n        - Focal Loss\n        - Temporal MSE (TMSE)\n        - Gaussian Similarity TMSE (GSTMSE)\n    \"\"\"\n    def __init__(self,\n                 num_classes,\n                 file_path,\n                 label_path,\n                 ce=True,\n                 focal=True,\n                 tmse=False,\n                 gstmse=False,\n                 weight=None,\n                 threshold=4.,\n                 ignore_index=255,\n                 ce_weight=1.0,\n                 focal_weight=1.0,\n                 tmse_weight=0.15,\n                 gstmse_weight=0.15):\n        super().__init__()"
        },
        {
            "comment": "The code initializes criterions and weights for different loss functions based on the provided parameters. It adds CrossEntropyLoss, FocalLoss, TMSE, and GaussianSimilarityTMSE to self.criterions list, and their corresponding weights to self.weights list. The weight parameter determines whether class weights are used in CrossEntropyLoss. Ignore_index is added for all loss functions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":167-197",
            "content": "        self.criterions = []\n        self.weights = []\n        self.num_classes = num_classes\n        self.file_path = file_path\n        self.label_path = label_path\n        if weight:\n            class_weight = self.get_class_weight()\n        else:\n            class_weight = None\n        if ce:\n            self.criterions.append(\n                nn.CrossEntropyLoss(weight=class_weight,\n                                    ignore_index=ignore_index))\n            self.weights.append(ce_weight)\n        if focal:\n            self.criterions.append(FocalLoss(ignore_index=ignore_index))\n            self.weights.append(focal_weight)\n        if tmse:\n            self.criterions.append(\n                TMSE(threshold=threshold, ignore_index=ignore_index))\n            self.weights.append(tmse_weight)\n        if gstmse:\n            self.criterions.append(\n                GaussianSimilarityTMSE(threshold=threshold,\n                                       ignore_index=ignore_index))\n            self.weights.append(gstmse_weight)"
        },
        {
            "comment": "The code snippet loads file information from a given path and calculates class weights for CrossEntropy loss function, based on the method described in the Eigen and Fergus paper. It reads file names and their corresponding labels, and stores them as lists for later use.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":199-220",
            "content": "        if len(self.criterions) == 0:\n            print(\"You have to choose at least one loss function.\")\n            sys.exit(1)\n    def get_class_weight(self):\n        \"\"\"\n        Class weight for CrossEntropy\n        Class weight is calculated in the way described in:\n            D. Eigen and R. Fergus, \u201cPredicting depth, surface normals and semantic labels with a common multi-scale convolutional architecture,\u201d in ICCV,\n            openaccess: https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Eigen_Predicting_Depth_Surface_ICCV_2015_paper.pdf\n        \"\"\"\n        # load file list\n        file_ptr = open(self.file_path, 'r')\n        info = file_ptr.read().split('\\n')[:-1]\n        file_ptr.close()\n        nums = [0 for i in range(self.num_classes)]\n        for i in range(len(info)):\n            video_name = info[i]\n            file_name = video_name.split('.')[0] + \".npy\"\n            label_file_path = os.path.join(self.label_path, file_name)\n            label = np.load(label_file_path).astype(np.int64)"
        },
        {
            "comment": "This code defines a class that calculates class weights based on the frequency of occurrence in labels. It also includes a forward function for applying different loss functions to predictions and ground truths, with associated weights. The criterion types include GaussianSimilarityTMSE and nn.CrossEntropyLoss.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":221-247",
            "content": "            num, cnt = np.unique(label, return_counts=True)\n            for n, c in zip(num, cnt):\n                nums[n] += c\n        class_num = paddle.to_tensor(nums, dtype=\"float32\")\n        total = class_num.sum().item()\n        frequency = class_num / total\n        median = paddle.median(frequency)\n        class_weight = median / frequency\n        return class_weight\n    def forward(self, preds, gts, sim_index):\n        \"\"\"\n        Args:\n            preds: paddle.float (N, C, T).\n            gts: paddle.int64 (N, T).\n            sim_index: paddle.float (N, C', T).\n        \"\"\"\n        loss = 0.0\n        for criterion, weight in zip(self.criterions, self.weights):\n            if isinstance(criterion, GaussianSimilarityTMSE):\n                loss += weight * criterion(preds, gts, sim_index)\n            elif isinstance(criterion, nn.CrossEntropyLoss):\n                preds_t = paddle.transpose(preds, perm=[0, 2, 1])\n                loss += weight * criterion(preds_t, gts)\n            else:\n                loss += weight * criterion(preds, gts)"
        },
        {
            "comment": "This class defines a boundary regression loss function, which combines different loss types such as Binary Cross Entropy Loss (bce), Mean Squared Error (mse) and Focal Loss (focal). It initializes with file_path, label_path, bce, focal, mse, weight and pos_weight parameters. The get_pos_weight method retrieves a position weight depending on the norm parameter. If at least one loss function is chosen, the criterions list is created. If not, it prints an error message and exits the program.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":249-290",
            "content": "        return loss\nclass BoundaryRegressionLoss(nn.Layer):\n    \"\"\"\n    Boundary Regression Loss\n        bce: Binary Cross Entropy Loss for Boundary Prediction\n        mse: Mean Squared Error\n    \"\"\"\n    def __init__(self,\n                 file_path,\n                 label_path,\n                 bce=True,\n                 focal=False,\n                 mse=False,\n                 weight=None,\n                 pos_weight=None):\n        super().__init__()\n        self.criterions = []\n        self.file_path = file_path\n        self.label_path = label_path\n        pos_weight = self.get_pos_weight()\n        if bce:\n            self.criterions.append(\n                nn.BCEWithLogitsLoss(weight=weight, pos_weight=pos_weight))\n        if focal:\n            self.criterions.append(FocalLoss())\n        if mse:\n            self.criterions.append(nn.MSELoss())\n        if len(self.criterions) == 0:\n            print(\"You have to choose at least one loss function.\")\n            sys.exit(1)\n    def get_pos_weight(self, norm=None):\n        \"\"\""
        },
        {
            "comment": "This code calculates the positive weight for binary cross-entropy with logits loss. It loads file information from a given path, counts the number of positive and negative samples, then calculates the ratio of positive samples to total samples. The positive weight is set as the reciprocal of this ratio. If a normalization factor is provided, it divides the positive weight by this factor before returning it in float32 tensor format.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":291-320",
            "content": "        pos_weight for binary cross entropy with logits loss\n        pos_weight is defined as reciprocal of ratio of positive samples in the dataset\n        \"\"\"\n        # load file list\n        file_ptr = open(self.file_path, 'r')\n        info = file_ptr.read().split('\\n')[:-1]\n        file_ptr.close()\n        n_classes = 2  # boundary or not\n        nums = [0 for i in range(n_classes)]\n        for i in range(len(info)):\n            video_name = info[i]\n            file_name = video_name.split('.')[0] + \".npy\"\n            label_file_path = os.path.join(self.label_path, file_name)\n            label = np.load(label_file_path).astype(np.int64)\n            num, cnt = np.unique(label, return_counts=True)\n            for n, c in zip(num, cnt):\n                nums[n] += c\n        pos_ratio = nums[1] / sum(nums)\n        pos_weight = 1 / pos_ratio\n        if norm is not None:\n            pos_weight /= norm\n        return paddle.to_tensor(pos_weight, dtype=\"float32\")\n    def forward(self, preds, gts):\n        \"\"\"\n        Args:"
        },
        {
            "comment": "The ASRFLoss class is an ASR (Automatic Speech Recognition) loss function implemented with various criteria for prediction and ground truth. It uses different weights for CE, Focal, TMSE, GST MSE, BCE, and BR LFocal losses depending on the input parameters. The function returns the average loss across all criterions and samples.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":321-358",
            "content": "            preds: paddle.float (N, 1, T).\n            gts: paddle.float (N, 1, T).\n        \"\"\"\n        loss = 0.0\n        batch_size = float(preds.shape[0])\n        for criterion in self.criterions:\n            for pred, gt in zip(preds, gts):\n                loss += criterion(pred, gt)\n        return loss / batch_size\n@LOSSES.register()\nclass ASRFLoss(nn.Layer):\n    def __init__(self,\n                 lambda_bound_loss,\n                 num_classes,\n                 file_path,\n                 label_path,\n                 boundary_path,\n                 ce=True,\n                 asl_focal=True,\n                 tmse=False,\n                 gstmse=False,\n                 asl_weight=None,\n                 threshold=4.,\n                 ignore_index=255,\n                 ce_weight=1.0,\n                 focal_weight=1.0,\n                 tmse_weight=0.15,\n                 gstmse_weight=0.15,\n                 bce=True,\n                 brl_focal=False,\n                 mse=False,\n                 brl_weight=None):\n        super().__init__()"
        },
        {
            "comment": "This code initializes an ActionSegmentationLoss object with specified parameters for classification loss, focal loss, and temporal segmentation losses. It also takes weights and file paths as inputs to optimize the model's performance.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":359-372",
            "content": "        self.criterion_cls = ActionSegmentationLoss(ce=ce,\n                                                    focal=asl_focal,\n                                                    tmse=tmse,\n                                                    gstmse=gstmse,\n                                                    weight=asl_weight,\n                                                    threshold=threshold,\n                                                    ignore_index=ignore_index,\n                                                    ce_weight=ce_weight,\n                                                    focal_weight=focal_weight,\n                                                    tmse_weight=tmse_weight,\n                                                    gstmse_weight=gstmse_weight,\n                                                    file_path=file_path,\n                                                    label_path=label_path,\n                                                    num_classes=num_classes)"
        },
        {
            "comment": "This code defines a custom loss function for a video modeling framework. It initializes a boundary regression loss criterion and takes a weighted average of classification and boundary losses. The forward method calculates the total loss by summing weighted classification and boundary losses, and returns the final loss value.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/asrf_loss.py\":373-400",
            "content": "        self.criterion_boundary = BoundaryRegressionLoss(\n            bce=bce,\n            focal=brl_focal,\n            mse=mse,\n            weight=brl_weight,\n            file_path=file_path,\n            label_path=boundary_path)\n        self.lambda_bound_loss = lambda_bound_loss\n    def forward(self, x, output_cls, label, outputs_boundary, boundary):\n        loss = 0.0\n        if isinstance(output_cls, list):\n            n = len(output_cls)\n            for out in output_cls:\n                loss += self.criterion_cls(out, label, x) / n\n        else:\n            loss += self.criterion_cls(output_cls, label, x)\n        if isinstance(outputs_boundary, list):\n            n = len(outputs_boundary)\n            for out in outputs_boundary:\n                loss += self.lambda_bound_loss * self.criterion_boundary(\n                    out, boundary) / n\n        else:\n            loss += self.lambda_bound_loss * self.criterion_boundary(\n                outputs_boundary, boundary)\n        return loss"
        }
    ]
}