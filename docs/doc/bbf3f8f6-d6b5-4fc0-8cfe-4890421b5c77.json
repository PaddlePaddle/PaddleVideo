{
    "summary": "The code implements temporal convolutional networks and GCN units in PaddlePaddle, creating a Graph class and AGCN2s graph convolution layer for the NTURGB+D dataset. This involves initializing variables, obtaining adjacency matrix, normalization, and executing convolutions.",
    "details": [
        {
            "comment": "This code defines a class named \"UnitTCN\" which is a type of layer for temporal convolutional network. It's implemented using PaddlePaddle library and includes methods to define the convolutional layers with specified number of input and output channels, kernel size and stride. The class is registered in the BACKBONES registry of the PaddleVideo module.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":0-31",
            "content": "# Copyright (c) 2021  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport paddle\nimport paddle.nn as nn\nimport numpy as np\nfrom ..registry import BACKBONES\ndef import_class(name):\n    components = name.split('.')\n    mod = __import__(components[0])\n    for comp in components[1:]:\n        mod = getattr(mod, comp)\n    return mod\nclass UnitTCN(nn.Layer):\n    def __init__(self, in_channels, out_channels, kernel_size=9, stride=1):\n        super(UnitTCN, self).__init__()\n        pad = int((kernel_size - 1) / 2)"
        },
        {
            "comment": "This code defines a GCN unit class with convolutional layers for learning spatio-temporal features. It uses batch normalization and ReLU activation, allowing the model to learn representations from the input data. The GCN unit takes in channels, output channels, adjacency matrix A, coefficient embedding, and number of subsets as parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":32-64",
            "content": "        self.conv = nn.Conv2D(in_channels,\n                              out_channels,\n                              kernel_size=(kernel_size, 1),\n                              padding=(pad, 0),\n                              stride=(stride, 1))\n        self.bn = nn.BatchNorm2D(out_channels)\n        self.relu = nn.ReLU()\n    def forward(self, x):\n        \" input size : (N*M, C, T, V)\"\n        x = self.bn(self.conv(x))\n        return x\nclass UnitGCN(nn.Layer):\n    def __init__(self,\n                 in_channels,\n                 out_channels,\n                 A,\n                 coff_embedding=4,\n                 num_subset=3):\n        super(UnitGCN, self).__init__()\n        inter_channels = out_channels // coff_embedding\n        self.inter_c = inter_channels\n        PA = self.create_parameter(shape=A.shape, dtype='float32')\n        self.PA = PA\n        self.A = paddle.to_tensor(A.astype(np.float32))\n        self.num_subset = num_subset\n        self.conv_a = nn.LayerList()\n        self.conv_b = nn.LayerList()\n        self.conv_d = nn.LayerList()"
        },
        {
            "comment": "This code defines a neural network backbone for the AGCN2S model. It initializes and appends convolutional layers, checks if input and output channels are different to determine whether to add a downsampling layer, and defines softmax, batch normalization, and ReLU activation functions. The forward function performs operations on input data to produce the final output.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":65-90",
            "content": "        for i in range(self.num_subset):\n            self.conv_a.append(nn.Conv2D(in_channels, inter_channels, 1))\n            self.conv_b.append(nn.Conv2D(in_channels, inter_channels, 1))\n            self.conv_d.append(nn.Conv2D(in_channels, out_channels, 1))\n        if in_channels != out_channels:\n            self.down = nn.Sequential(nn.Conv2D(in_channels, out_channels, 1),\n                                      nn.BatchNorm2D(out_channels))\n        else:\n            self.down = lambda x: x\n        self.bn = nn.BatchNorm2D(out_channels)\n        self.soft = nn.Softmax(-2)\n        self.relu = nn.ReLU()\n    def forward(self, x):\n        N, C, T, V = x.shape\n        A = self.A + self.PA\n        y = None\n        for i in range(self.num_subset):\n            A1 = paddle.transpose(self.conv_a[i](x),\n                                  perm=[0, 3, 1,\n                                        2]).reshape([N, V, self.inter_c * T])\n            A2 = self.conv_b[i](x).reshape([N, self.inter_c * T, V])\n            A1 = self.soft(paddle.matmul(A1, A2) / A1.shape[-1])"
        },
        {
            "comment": "The code defines a block class for a neural network architecture. It consists of GCN and TCN units in series, followed by a ReLU activation function. The residual connection is either set to zero or equal to the input if not specified, allowing for identity shortcuts within the network. The forward method combines the outputs from GCN and TCN with residual connections.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":91-120",
            "content": "            A1 = A1 + A[i]\n            A2 = x.reshape([N, C * T, V])\n            z = self.conv_d[i](paddle.matmul(A2, A1).reshape([N, C, T, V]))\n            y = z + y if y is not None else z\n        y = self.bn(y)\n        y += self.down(x)\n        return self.relu(y)\nclass Block(nn.Layer):\n    def __init__(self, in_channels, out_channels, A, stride=1, residual=True):\n        super(Block, self).__init__()\n        self.gcn1 = UnitGCN(in_channels, out_channels, A)\n        self.tcn1 = UnitTCN(out_channels, out_channels, stride=stride)\n        self.relu = nn.ReLU()\n        if not residual:\n            self.residual = lambda x: 0\n        elif (in_channels == out_channels) and (stride == 1):\n            self.residual = lambda x: x\n        else:\n            self.residual = UnitTCN(in_channels,\n                                    out_channels,\n                                    kernel_size=1,\n                                    stride=stride)\n    def forward(self, x):\n        x = self.tcn1(self.gcn1(x)) + self.residual(x)"
        },
        {
            "comment": "This code defines a Graph class with a fixed number of nodes (25) and connectivity patterns for the NTURGB+D dataset. It initializes self_link, inward, outward, and neighbor variables based on the specified labeling mode ('spatial' by default). The adjacency matrix is obtained using get_adjacency_matrix method.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":121-143",
            "content": "        return self.relu(x)\n# This Graph structure is for the NTURGB+D dataset. If you use a custom dataset, modify num_node and the corresponding graph adjacency structure.\nclass Graph:\n    def __init__(self, labeling_mode='spatial'):\n        num_node = 25\n        self_link = [(i, i) for i in range(num_node)]\n        inward_ori_index = [(1, 2), (2, 21), (3, 21), (4, 3), (5, 21), (6, 5),\n                            (7, 6), (8, 7), (9, 21), (10, 9), (11, 10),\n                            (12, 11), (13, 1), (14, 13), (15, 14), (16, 15),\n                            (17, 1), (18, 17), (19, 18), (20, 19), (22, 23),\n                            (23, 8), (24, 25), (25, 12)]\n        inward = [(i - 1, j - 1) for (i, j) in inward_ori_index]\n        outward = [(j, i) for (i, j) in inward]\n        neighbor = inward + outward\n        self.num_node = num_node\n        self.self_link = self_link\n        self.inward = inward\n        self.outward = outward\n        self.neighbor = neighbor\n        self.A = self.get_adjacency_matrix(labeling_mode)"
        },
        {
            "comment": "The code defines three functions: `edge2mat()`, `normalize_digraph()`, and `get_spatial_graph()`. `edge2mat()` converts a list of edges into an adjacency matrix. `normalize_digraph()` normalizes a directed graph by computing the in-degree for each node. `get_spatial_graph()` combines the adjacency matrices from self-links, incoming edges, and outgoing edges into one matrix. The last function `get_adjacency_matrix()` returns the adjacency matrix depending on the given labeling mode (default or spatial).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":145-175",
            "content": "    def edge2mat(self, link, num_node):\n        A = np.zeros((num_node, num_node))\n        for i, j in link:\n            A[j, i] = 1\n        return A\n    def normalize_digraph(self, A):\n        Dl = np.sum(A, 0)\n        h, w = A.shape\n        Dn = np.zeros((w, w))\n        for i in range(w):\n            if Dl[i] > 0:\n                Dn[i, i] = Dl[i]**(-1)\n        AD = np.dot(A, Dn)\n        return AD\n    def get_spatial_graph(self, num_node, self_link, inward, outward):\n        I = self.edge2mat(self_link, num_node)\n        In = self.normalize_digraph(self.edge2mat(inward, num_node))\n        Out = self.normalize_digraph(self.edge2mat(outward, num_node))\n        A = np.stack((I, In, Out))\n        return A\n    def get_adjacency_matrix(self, labeling_mode=None):\n        if labeling_mode is None:\n            return self.A\n        if labeling_mode == 'spatial':\n            A = self.get_spatial_graph(self.num_node, self.self_link,\n                                       self.inward, self.outward)\n        else:\n            raise ValueError()"
        },
        {
            "comment": "Class AGCN2s defines a neural network layer for graph convolutions. It takes parameters such as number of points, persons, and the type of graph. The code initializes graph adjacency matrix 'A' from the specified graph and creates several Block layers for convolution operations with different parameters and strides. In forward pass, it rearranges the input tensor dimensions and reshapes it before performing graph convolutions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":176-211",
            "content": "        return A\n@BACKBONES.register()\nclass AGCN2s(nn.Layer):\n    def __init__(self,\n                 num_point=25,\n                 num_person=2,\n                 graph='ntu_rgb_d',\n                 graph_args=dict(),\n                 in_channels=3):\n        super(AGCN2s, self).__init__()\n        if graph == 'ntu_rgb_d':\n            self.graph = Graph(**graph_args)\n        else:\n            raise ValueError()\n        A = self.graph.A\n        self.data_bn = nn.BatchNorm1D(num_person * in_channels * num_point)\n        self.l1 = Block(in_channels, 64, A, residual=False)\n        self.l2 = Block(64, 64, A)\n        self.l3 = Block(64, 64, A)\n        self.l4 = Block(64, 64, A)\n        self.l5 = Block(64, 128, A, stride=2)\n        self.l6 = Block(128, 128, A)\n        self.l7 = Block(128, 128, A)\n        self.l8 = Block(128, 256, A, stride=2)\n        self.l9 = Block(256, 256, A)\n        self.l10 = Block(256, 256, A)\n    def forward(self, x):\n        N, C, T, V, M = x.shape\n        x = x.transpose([0, 4, 3, 1, 2]).reshape_([N, M * V * C, T])"
        },
        {
            "comment": "The code performs the following operations: \n1. Applies data normalization to x using self.data_bn.\n2. Reshapes x with dimensions N, M, V, C, and T to (N*M,C,T,V).\n3. Passes x through ten linear layers (l1 to l10) for transformation.\n4. Finally, returns the transformed x.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/backbones/agcn2s.py\":212-228",
            "content": "        x = self.data_bn(x)\n        x = x.reshape_([N, M, V, C,\n                        T]).transpose([0, 1, 3, 4,\n                                       2]).reshape_([N * M, C, T, V])\n        x = self.l1(x)\n        x = self.l2(x)\n        x = self.l3(x)\n        x = self.l4(x)\n        x = self.l5(x)\n        x = self.l6(x)\n        x = self.l7(x)\n        x = self.l8(x)\n        x = self.l9(x)\n        x = self.l10(x)\n        return x"
        }
    ]
}