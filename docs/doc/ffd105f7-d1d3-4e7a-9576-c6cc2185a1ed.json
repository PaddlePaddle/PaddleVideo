{
    "summary": "The code imports libraries, defines a DecodeSampler class for video decoding, and initializes parameters. It then decodes video frames, clips the index, retrieves frames, converts them to images using PIL library, and stores the images in a list.",
    "details": [
        {
            "comment": "This code imports necessary libraries, defines the DecodeSampler class for faster decoding and sampling of video data using 'decord', and registers it with the PIPELINES registry. It is used in the slowfast model and takes arguments such as num_frames, sampling_rate, and target_fps.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler.py\":0-29",
            "content": "# copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport random\nimport numpy as np\nfrom PIL import Image\nimport decord as de\nfrom ..registry import PIPELINES\n@PIPELINES.register()\nclass DecodeSampler(object):\n    \"\"\"\n    We use 'decord' for decode and sampling, which is faster than opencv.\n    This is used in slowfast model.\n    Args:\n        num_frames(int): the number of frames we want to sample.\n        sampling_rate(int): sampling rate for video data.\n        target_fps(int): desired fps, default 30"
        },
        {
            "comment": "This code initializes a class with parameters for sampling video frames, and determines the start and end indices for each clip based on test mode (random or uniform).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler.py\":30-54",
            "content": "        test_mode(bool): whether test or train/valid. In slowfast, we use multicrop when test.\n    \"\"\"\n    def __init__(self,\n                 num_frames,\n                 sampling_rate,\n                 default_sampling_rate=2,\n                 target_fps=30,\n                 test_mode=False):\n        self.num_frames = num_frames\n        self.orig_sampling_rate = self.sampling_rate = sampling_rate\n        self.default_sampling_rate = default_sampling_rate\n        self.target_fps = target_fps\n        self.test_mode = test_mode\n    def get_start_end_idx(self, video_size, clip_size, clip_idx,\n                          temporal_num_clips):\n        delta = max(video_size - clip_size, 0)\n        if not self.test_mode:\n            # Random temporal sampling.\n            start_idx = random.uniform(0, delta)\n        else:\n            # Uniformly sample the clip with the given index.\n            start_idx = delta * clip_idx / temporal_num_clips\n        end_idx = start_idx + clip_size - 1\n        return start_idx, end_idx"
        },
        {
            "comment": "This function performs mp4 decode operations and returns a list of numpy arrays after decoding. It considers the short_cycle_idx to adjust the sampling rate, takes the filepath and temporal parameters from results, initializes a VideoReader object, calculates clip size, gets start and end indices for video clipping based on these values, and finally creates an index list for the decoded frames.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler.py\":56-80",
            "content": "    def __call__(self, results):\n        \"\"\"\n        Perform mp4 decode operations.\n        return:\n            List where each item is a numpy array after decoder.\n        \"\"\"\n        short_cycle_idx = results.get('short_cycle_idx')\n        if short_cycle_idx:\n            self.sampling_rate = random.randint(self.default_sampling_rate,\n                                                self.orig_sampling_rate)\n        filepath = results['filename']\n        temporal_sample_index = results['temporal_sample_index']\n        temporal_num_clips = results['temporal_num_clips']\n        vr = de.VideoReader(filepath)\n        videolen = len(vr)\n        fps = vr.get_avg_fps()\n        clip_size = self.num_frames * self.sampling_rate * fps / self.target_fps\n        start_idx, end_idx = self.get_start_end_idx(videolen, clip_size,\n                                                    temporal_sample_index,\n                                                    temporal_num_clips)\n        index = np.linspace(start_idx, end_idx, self.num_frames).astype(\"int64\")"
        },
        {
            "comment": "This code segment is responsible for decoding and preparing image frames from a video. It clips the index value to ensure it falls within the valid range, retrieves the corresponding batch of frames using get_batch function, converts these frames into an array, and then loops through the array to convert each frame into an image using the PIL library's Image.fromarray method. The resulting images are stored in a list which is then assigned to 'results'['imgs'] before the function returns the results.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/decode_sampler.py\":81-92",
            "content": "        index = np.clip(index, 0, videolen)\n        frames_select = vr.get_batch(index)  #1 for buffer\n        # dearray_to_img\n        np_frames = frames_select.asnumpy()\n        frames_select_list = []\n        for i in range(np_frames.shape[0]):\n            imgbuf = np_frames[i]\n            frames_select_list.append(Image.fromarray(imgbuf, mode='RGB'))\n        results['imgs'] = frames_select_list\n        return results"
        }
    ]
}