{
    "summary": "The \"AddsHead\" class in PaddleVideo handles object detection, loss calculation during training and metrics like abs_rel, rmse in inference, while supporting multi-GPU scenarios with all-reduce operations.",
    "details": [
        {
            "comment": "This code is part of the PaddleVideo library, defining a class called AddsHead for object detection. It uses input features with specific number of channels and classes to be classified. The class is registered in the registry under HEADS. MIN_DEPTH and MAX_DEPTH constants define the minimum and maximum depth values respectively.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/adds_head.py\":0-32",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport cv2\nimport numpy as np\nimport paddle.nn as nn\nfrom paddlevideo.utils import get_dist_info\nimport paddle\nfrom ..builder import build_loss\nfrom ..registry import HEADS\nMIN_DEPTH = 1e-3\nMAX_DEPTH = 80\n@HEADS.register()\nclass AddsHead(nn.Layer):\n    \"\"\"TimeSformerHead Head.\n    Args:\n        num_classes (int): The number of classes to be classified.\n        in_channels (int): The number of channles in input feature."
        },
        {
            "comment": "The code represents the initialization and forward pass of a class named \"AddsHead\". The class takes in parameters like avg_reprojection, disparity_smoothness, no_ssim, etc. It builds a loss function using build_loss method with the provided configuration (loss_cfg). During training, it returns the result of the loss function on inputs and outputs. In inference mode, it uses get_metrics method to calculate metrics such as abs_rel, sq_rel, rmse, rmse_log, a1, a2, a3.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/adds_head.py\":33-61",
            "content": "        loss_cfg (dict): Config for building config. Default: dict(name='CrossEntropyLoss').\n        std(float): Std(Scale) value in normal initilizar. Default: 0.01.\n        kwargs (dict, optional): Any keyword argument to initialize.\n    \"\"\"\n    def __init__(self,\n                 avg_reprojection,\n                 disparity_smoothness,\n                 no_ssim,\n                 loss_cfg=dict(name='ADDSLoss'),\n                 max_gt_depth=60,\n                 pred_depth_scale_factor=1):\n        super(AddsHead, self).__init__()\n        loss_cfg['avg_reprojection'] = avg_reprojection\n        loss_cfg['disparity_smoothness'] = disparity_smoothness\n        loss_cfg['no_ssim'] = no_ssim\n        self.max_gt_depth = max_gt_depth\n        self.pred_depth_scale_factor = pred_depth_scale_factor\n        self.loss_func = build_loss(loss_cfg)\n    def forward(self):\n        raise NotImplemented\n    def loss(self, inputs, outputs):\n        if self.training:\n            return self.loss_func(inputs, outputs)\n        else:\n            abs_rel, sq_rel, rmse, rmse_log, a1, a2, a3 = self.get_metrics("
        },
        {
            "comment": "This code snippet defines an \"AddsHead\" class that returns a dictionary of metrics including absolute relative error, squared relative error, root mean square error, and additional error measures. The get_metrics function resizes the predicted displacement to match the ground truth depth, scales and adjusts the predicted depth based on certain factors, and then computes the specified errors using another function.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/adds_head.py\":62-94",
            "content": "                outputs['pred_disp'], outputs['gt'])\n            outputs['abs_rel'] = abs_rel\n            outputs['sq_rel'] = sq_rel\n            outputs['rmse'] = rmse\n            outputs['rmse_log'] = rmse_log\n            outputs['a1'] = a1\n            outputs['a2'] = a2\n            outputs['a3'] = a3\n            return outputs\n    def get_metrics(self, pred_disp, gt_depth):\n        gt_height, gt_width = gt_depth.shape[:2]\n        pred_disp = cv2.resize(pred_disp, (gt_width, gt_height))\n        pred_depth = 1 / pred_disp\n        mask = gt_depth > 0\n        pred_depth = pred_depth[mask]\n        gt_depth = gt_depth[mask]\n        pred_depth *= self.pred_depth_scale_factor\n        ratio = np.median(gt_depth) / np.median(pred_depth)\n        pred_depth *= ratio\n        pred_depth[pred_depth < MIN_DEPTH] = MIN_DEPTH\n        pred_depth[pred_depth > MAX_DEPTH] = MAX_DEPTH\n        mask2 = gt_depth <= self.max_gt_depth\n        pred_depth = pred_depth[mask2]\n        gt_depth = gt_depth[mask2]\n        abs_rel, sq_rel, rmse, rmse_log, a1, a2, a3 = self.compute_errors("
        },
        {
            "comment": "This code is performing all-reduce operations on tensors for multi-GPU scenarios, ensuring that the sum of tensor values across GPUs is reduced and then divided by the total number of participating GPUs. This allows for accurate averaging of results when working with multiple GPUs in a distributed environment.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/adds_head.py\":95-116",
            "content": "            gt_depth, pred_depth)\n        _, world_size = get_dist_info()\n        if world_size > 1:\n            # educe sum when valid\n            # TODO: there are some problems with multi gpu gather code.\n            abs_rel = paddle.to_tensor(abs_rel)\n            sq_rel = paddle.to_tensor(sq_rel)\n            rmse = paddle.to_tensor(rmse)\n            rmse_log = paddle.to_tensor(rmse_log)\n            a1 = paddle.to_tensor(a1)\n            a2 = paddle.to_tensor(a2)\n            a3 = paddle.to_tensor(a3)\n            abs_rel = paddle.distributed.all_reduce(\n                abs_rel, op=paddle.distributed.ReduceOp.SUM) / world_size\n            sq_rel = paddle.distributed.all_reduce(\n                sq_rel, op=paddle.distributed.ReduceOp.SUM) / world_size\n            rmse = paddle.distributed.all_reduce(\n                rmse, op=paddle.distributed.ReduceOp.SUM) / world_size\n            rmse_log = paddle.distributed.all_reduce(\n                rmse_log, op=paddle.distributed.ReduceOp.SUM) / world_size\n            a1 = paddle.distributed.all_reduce("
        },
        {
            "comment": "The code defines a function that computes error metrics between predicted and ground truth depths. It uses all-reduce operations to calculate average values and returns multiple metrics including absolute relative error, squared relative error, RMSE, log RMSE, and three averages (a1, a2, a3) indicating the percentage of thresholds below certain levels.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/adds_head.py\":117-143",
            "content": "                a1, op=paddle.distributed.ReduceOp.SUM) / world_size\n            a2 = paddle.distributed.all_reduce(\n                a2, op=paddle.distributed.ReduceOp.SUM) / world_size\n            a3 = paddle.distributed.all_reduce(\n                a3, op=paddle.distributed.ReduceOp.SUM) / world_size\n            return abs_rel.item(), sq_rel.item(), rmse.item(), rmse_log.item(\n            ), a1.item(), a2.item(), a3.item()\n        return abs_rel, sq_rel, rmse, rmse_log, a1, a2, a3\n    def compute_errors(self, gt, pred):\n        \"\"\"Computation of error metrics between predicted and ground truth depths\n        \"\"\"\n        thresh = np.maximum((gt / pred), (pred / gt))\n        a1 = (thresh < 1.25).mean()\n        a2 = (thresh < 1.25**2).mean()\n        a3 = (thresh < 1.25**3).mean()\n        rmse = (gt - pred)**2\n        rmse = np.sqrt(rmse.mean())\n        rmse_log = (np.log(gt) - np.log(pred))**2\n        rmse_log = np.sqrt(rmse_log.mean())\n        abs_rel = np.mean(np.abs(gt - pred) / gt)\n        sq_rel = np.mean(((gt - pred)**2) / gt)"
        },
        {
            "comment": "This code returns six metrics: abs_rel, sq_rel, rmse, rmse_log, a1, and a2. These metrics are likely related to evaluating the performance of some model or algorithm in a regression task. The 'abs_rel' might stand for absolute relative error, 'sq_rel' could be squared relative error, 'rmse' represents root mean squared error, 'rmse_log' could be the logarithm of rmse, and 'a1', 'a2', and 'a3' are possibly other evaluation metrics.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/heads/adds_head.py\":145-145",
            "content": "        return abs_rel, sq_rel, rmse, rmse_log, a1, a2, a3"
        }
    ]
}