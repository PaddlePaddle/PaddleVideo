{
    "summary": "The DataReader class handles YouTube-8M dataset using LSTM models, pickle for data loading, and supports various Python versions. It sets batch size, shuffles files if training mode is on, and reads video frames with labels/filenames into batches using one-hot encoding.",
    "details": [
        {
            "comment": "This code is for a DataReader class that handles the youtube-8M dataset. The features are extracted by prior networks, specifically for LSTM models. It uses pickle to load data and BytesIO for compatibility with different python versions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/feature_reader.py\":0-33",
            "content": "#  Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n#Licensed under the Apache License, Version 2.0 (the \"License\");\n#you may not use this file except in compliance with the License.\n#You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n#Unless required by applicable law or agreed to in writing, software\n#distributed under the License is distributed on an \"AS IS\" BASIS,\n#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#See the License for the specific language governing permissions and\n#limitations under the License.\nimport sys\nfrom .reader_utils import DataReader\ntry:\n    import cPickle as pickle\n    from cStringIO import StringIO\nexcept ImportError:\n    import pickle\n    from io import BytesIO\nimport numpy as np\nimport random\npython_ver = sys.version_info\nclass FeatureReader(DataReader):\n    \"\"\"\n    Data reader for youtube-8M dataset, which was stored as features extracted by prior networks\n    This is for the three models: lstm\n    dataset cfg: num_classes"
        },
        {
            "comment": "Initializes a feature reader object with specified name, mode and configuration. Sets batch size and file list from the configuration. Reads the file list, removes empty lines and shuffles if in training mode. Defines a nested function reader that iterates over each item in the file list, loads corresponding RGB data and labels, converts labels to one-hot format if not in inference mode, and returns them as batch outputs.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/feature_reader.py\":34-63",
            "content": "                 batch_size\n                 list\n    \"\"\"\n    def __init__(self, name, mode, cfg):\n        self.name = name\n        self.mode = mode\n        self.num_classes = cfg.MODEL.num_classes\n        # set batch size and file list\n        self.batch_size = cfg[mode.upper()]['batch_size']\n        self.filelist = cfg[mode.upper()]['filelist']\n        self.seg_num = cfg.MODEL.get('seg_num', None)\n    def create_reader(self):\n        fl = open(self.filelist).readlines()\n        fl = [line.strip() for line in fl if line.strip() != '']\n        if self.mode == 'train':\n            random.shuffle(fl)\n        def reader():\n            batch_out = []\n            for item in fl:\n                fileinfo = item.split(' ')\n                filepath = fileinfo[0]\n                rgb = np.load(filepath, allow_pickle=True)\n                nframes = rgb.shape[0]\n                label = [int(i) for i in fileinfo[1:]]\n                one_hot_label = make_one_hot(label, self.num_classes)\n                if self.mode != 'infer':"
        },
        {
            "comment": "This code reads video frames and their labels/filenames into batches, using one-hot encoding for label conversion. The make_one_hot function creates a one-hot encoded vector from the given label.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/reader/feature_reader.py\":64-79",
            "content": "                    batch_out.append((rgb, one_hot_label))\n                else:\n                    batch_out.append((rgb, filepath.split('/')[-1]))\n                if len(batch_out) == self.batch_size:\n                    yield batch_out\n                    batch_out = []\n        return reader\ndef make_one_hot(label, dim=3862):\n    one_hot_label = np.zeros(dim)\n    one_hot_label = one_hot_label.astype(float)\n    for ind in label:\n        one_hot_label[int(ind)] = 1\n    return one_hot_label"
        }
    ]
}