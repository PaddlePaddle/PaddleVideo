{
    "summary": "This code snippet calculates mean average precision for video tagging in the Youtube-8m dataset using numpy, with functions for accumulation and processing. It allows for clearing the calculator, checking if empty, and retrieving non-interpolated average precision at n for each class.",
    "details": [
        {
            "comment": "This code calculates the mean average precision for an entire list or top-n ranked items in a video tag application. It imports numpy and provides functions to accumulate, process parts of the ranked list, and finally calculate the mean average precision using peek_map_at_n function. The example usage demonstrates how to use this code with a sample array.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/metrics/youtube8m/mean_average_precision_calculator.py\":0-26",
            "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Calculate the mean average precision.\nIt provides an interface for calculating mean average precision\nfor an entire list or the top-n ranked items.\nExample usages:\nWe first call the function accumulate many times to process parts of the ranked\nlist. After processing all the parts, we call peek_map_at_n\nto calculate the mean average precision.\n```\nimport random\np = np.array([[random.random() for _ in xrange(50)] for _ in xrange(1000)])"
        },
        {
            "comment": "The code initializes a numpy array 'a' with random values (0 or 1) for each of the 50 classes. It then creates an instance of MeanAveragePrecisionCalculator class and accumulates the predictions and actuals using the 'accumulate' method. Finally, it retrieves the average precision at different recall levels using the 'peek_map_at_n' method.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/metrics/youtube8m/mean_average_precision_calculator.py\":27-57",
            "content": "a = np.array([[random.choice([0, 1]) for _ in xrange(50)]\n     for _ in xrange(1000)])\n# mean average precision for 50 classes.\ncalculator = mean_average_precision_calculator.MeanAveragePrecisionCalculator(\n            num_class=50)\ncalculator.accumulate(p, a)\naps = calculator.peek_map_at_n()\n```\n\"\"\"\nimport numpy\nfrom . import average_precision_calculator\nclass MeanAveragePrecisionCalculator(object):\n    \"\"\"This class is to calculate mean average precision.\n  \"\"\"\n    def __init__(self, num_class):\n        \"\"\"Construct a calculator to calculate the (macro) average precision.\n    Args:\n      num_class: A positive Integer specifying the number of classes.\n      top_n_array: A list of positive integers specifying the top n for each\n      class. The top n in each class will be used to calculate its average\n      precision at n.\n      The size of the array must be num_class.\n    Raises:\n      ValueError: An error occurred when num_class is not a positive integer;\n      or the top_n_array is not a list of positive integers."
        },
        {
            "comment": "This code initializes an instance of AveragePrecisionCalculator with a specified number of classes. It appends an instance of AveragePrecisionCalculator to the class member _ap_calculators for each class. The accumulate method takes predictions and actuals as arguments, accumulates prediction scores and ground truth labels, treats any value greater than 0 as positives and negatives otherwise, and optionally takes num_positives as an argument if provided.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/metrics/youtube8m/mean_average_precision_calculator.py\":58-78",
            "content": "    \"\"\"\n        if not isinstance(num_class, int) or num_class <= 1:\n            raise ValueError(\"num_class must be a positive integer.\")\n        self._ap_calculators = []  # member of AveragePrecisionCalculator\n        self._num_class = num_class  # total number of classes\n        for i in range(num_class):\n            self._ap_calculators.append(\n                average_precision_calculator.AveragePrecisionCalculator())\n    def accumulate(self, predictions, actuals, num_positives=None):\n        \"\"\"Accumulate the predictions and their ground truth labels.\n    Args:\n      predictions: A list of lists storing the prediction scores. The outer\n      dimension corresponds to classes.\n      actuals: A list of lists storing the ground truth labels. The dimensions\n      should correspond to the predictions input. Any value\n      larger than 0 will be treated as positives, otherwise as negatives.\n      num_positives: If provided, it is a list of numbers representing the\n      number of true positives for each class. If not provided, the number of"
        },
        {
            "comment": "This code initializes a mean average precision calculator, handles accumulating predictions and actuals, allows for clearing the calculator, checks if it's empty, and retrieves non-interpolated average precision at n for each class.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/metrics/youtube8m/mean_average_precision_calculator.py\":79-110",
            "content": "      true positives will be inferred from the 'actuals' array.\n    Raises:\n      ValueError: An error occurred when the shape of predictions and actuals\n      does not match.\n    \"\"\"\n        if not num_positives:\n            num_positives = [None for i in predictions.shape[1]]\n        calculators = self._ap_calculators\n        for i in range(len(predictions)):\n            calculators[i].accumulate(predictions[i], actuals[i],\n                                      num_positives[i])\n    def clear(self):\n        for calculator in self._ap_calculators:\n            calculator.clear()\n    def is_empty(self):\n        return ([calculator.heap_size for calculator in self._ap_calculators\n                 ] == [0 for _ in range(self._num_class)])\n    def peek_map_at_n(self):\n        \"\"\"Peek the non-interpolated mean average precision at n.\n    Returns:\n      An array of non-interpolated average precision at n (default 0) for each\n      class.\n    \"\"\"\n        aps = [\n            self._ap_calculators[i].peek_ap_at_n()\n            for i in range(self._num_class)"
        },
        {
            "comment": "This code snippet calculates mean average precision for video tagging in the Youtube-8m dataset. It returns a list of average precisions (aps) after processing each chunk of data.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/metrics/youtube8m/mean_average_precision_calculator.py\":111-112",
            "content": "        ]\n        return aps"
        }
    ]
}