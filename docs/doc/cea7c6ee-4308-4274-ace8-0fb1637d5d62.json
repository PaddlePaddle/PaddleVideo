{
    "summary": "The GaussianSmoothing class in PaddlePaddle applies 1D gaussian smoothing for image processing tasks, and the code initializes weights and biases for a neural network layer with Kaiming Uniform method.",
    "details": [
        {
            "comment": "This code defines a GaussianSmoothing class in PaddlePaddle for applying gaussian smoothing on 1D tensors. It uses depthwise convolution to filter each channel separately, with input and output channels remaining the same. The kernel size can be specified as an integer or sequence.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":0-29",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# https://github.com/yiskw713/asrf/libs/postprocess.py\nimport paddle\nimport paddle.nn as nn\nimport paddle.nn.functional as F\nimport numpy as np\nimport math\nclass GaussianSmoothing(nn.Layer):\n    \"\"\"\n    Apply gaussian smoothing on a 1d tensor.\n    Filtering is performed seperately for each channel\n    in the input using a depthwise convolution.\n    Arguments:\n        channels (int, sequence): Number of channels of the input tensors. Output will\n            have this number of channels as well.\n        kernel_size (int, sequence): Size of the gaussian kernel."
        },
        {
            "comment": "This code initializes a Gaussian kernel with specified kernel size and sigma. The kernel is then applied to the input during forward pass to filter the data.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":30-61",
            "content": "        sigma (float, sequence): Standard deviation of the gaussian kernel.\n    \"\"\"\n    def __init__(self, kernel_size=15, sigma=1.0):\n        super().__init__()\n        self.kernel_size = kernel_size\n        # The gaussian kernel is the product of the\n        # gaussian function of each dimension.\n        kernel = 1\n        meshgrid = paddle.arange(kernel_size)\n        meshgrid = paddle.cast(meshgrid, dtype='float32')\n        mean = (kernel_size - 1) / 2\n        kernel = kernel / (sigma * math.sqrt(2 * math.pi))\n        kernel = kernel * paddle.exp(-(((meshgrid - mean) / sigma)**2) / 2)\n        # Make sure sum of values in gaussian kernel equals 1.\n        # kernel = kernel / paddle.max(kernel)\n        self.kernel = paddle.reshape(kernel, [1, 1, -1])\n    def forward(self, inputs):\n        \"\"\"\n        Apply gaussian filter to input.\n        Arguments:\n            input (paddle.Tensor): Input to apply gaussian filter on.\n        Returns:\n            filtered (paddle.Tensor): Filtered output.\n        \"\"\"\n        _, c, _ = inputs.shape"
        },
        {
            "comment": "This code defines a convolution operation and an argrelmax function for image processing. The conv1d function performs 1D convolutions on the input tensor, with padding, kernel expansion, and return as output. The argrelmax function calculates the arguments of relative maxima in boundary probability maps, ignoring values below a certain threshold. This code seems to be related to image segmentation or edge detection tasks.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":62-94",
            "content": "        inputs = F.pad(inputs,\n                       pad=((self.kernel_size - 1) // 2,\n                            (self.kernel_size - 1) // 2),\n                       mode=\"reflect\",\n                       data_format='NCL')\n        kernel = paddle.expand(self.kernel, shape=[c, 1, self.kernel_size])\n        return F.conv1d(inputs, weight=kernel, groups=c)\ndef argrelmax(prob, threshold=0.7):\n    \"\"\"\n    Calculate arguments of relative maxima.\n    prob: np.array. boundary probability maps distributerd in [0, 1]\n    prob shape is (T)\n    ignore the peak whose value is under threshold\n    Return:\n        Index of peaks for each batch\n    \"\"\"\n    # ignore the values under threshold\n    prob[prob < threshold] = 0.0\n    # calculate the relative maxima of boundary maps\n    # treat the first frame as boundary\n    peak = np.concatenate(\n        [\n            np.ones((1), dtype=np.bool),\n            (prob[:-2] < prob[1:-1]) & (prob[2:] < prob[1:-1]),\n            np.zeros((1), dtype=np.bool),\n        ],\n        axis=0,\n    )"
        },
        {
            "comment": "The code provides functions to convert tensors into probabilities or labels. The 'is_probability' function checks if a tensor is in the form of sigmoid or softmax outputs and returns True/False accordingly. The 'convert2probability' function converts tensors into probabilities based on whether they are sigmoid or softmax outputs. Lastly, 'convert2label' function converts tensors (2D or 3D) into labels by either casting to int64 directly for 2D or first converting the tensor to probability and then finding the index of maximum value along the appropriate axis.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":96-145",
            "content": "    peak_idx = np.where(peak)[0].tolist()\n    return peak_idx\ndef is_probability(x):\n    assert x.ndim == 3\n    if x.shape[1] == 1:\n        # sigmoid\n        if x.min() >= 0 and x.max() <= 1:\n            return True\n        else:\n            return False\n    else:\n        # softmax\n        _sum = np.sum(x, axis=1).astype(np.float32)\n        _ones = np.ones_like(_sum, dtype=np.float32)\n        return np.allclose(_sum, _ones)\ndef convert2probability(x):\n    \"\"\"\n    Args: x (N, C, T)\n    \"\"\"\n    assert x.ndim == 3\n    if is_probability(x):\n        return x\n    else:\n        if x.shape[1] == 1:\n            # sigmoid\n            prob = 1 / (1 + np.exp(-x))\n        else:\n            # softmax\n            prob = np.exp(x) / np.sum(np.exp(x), axis=1)\n        return prob.astype(np.float32)\ndef convert2label(x):\n    assert x.ndim == 2 or x.ndim == 3\n    if x.ndim == 2:\n        return x.astype(np.int64)\n    else:\n        if not is_probability(x):\n            x = convert2probability(x)\n        label = np.argmax(x, axis=1)\n        return label.astype(np.int64)"
        },
        {
            "comment": "This function refines the segmented action outputs based on boundary predictions, and performs majority vote to decide class labels. The inputs include model output (outputs) for frame-level class prediction, boundary prediction (boundaries), and an optional threshold (boundary_threshold). It converts outputs and boundaries into label and probability format respectively. For each sequence, it finds the indices of maximum boundary values above the threshold, appends the last action end index, then performs majority vote on each interval between adjacent max boundaries. The function returns the final class prediction considering boundaries in a numpy array format (preds).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":148-175",
            "content": "def refinement_with_boundary(outputs, boundaries, boundary_threshold):\n    \"\"\"\n    Get segments which is defined as the span b/w two boundaries,\n    and decide their classes by majority vote.\n    Args:\n        outputs: numpy array. shape (N, C, T)\n            the model output for frame-level class prediction.\n        boundaries: numpy array.  shape (N, 1, T)\n            boundary prediction.\n        boundary_threshold: the threshold of the size of action segments. float(default=0.7)\n    Return:\n        preds: np.array. shape (N, T)\n            final class prediction considering boundaries.\n    \"\"\"\n    preds = convert2label(outputs)\n    boundaries = convert2probability(boundaries)\n    for i, (output, pred, boundary) in enumerate(zip(outputs, preds,\n                                                     boundaries)):\n        idx = argrelmax(boundary[0, :], threshold=boundary_threshold)\n        # add the index of the last action ending\n        T = pred.shape[0]\n        idx.append(T)\n        # majority vote\n        for j in range(len(idx) - 1):"
        },
        {
            "comment": "This code segment performs action segmentation by detecting the majority class in each chunk and relabeling smaller action segments with their previous action segment. It uses numpy's bincount and where functions to find majority classes, and has separate logic for cases with multiple majority classes depending on the dimension of outputs. The results are stored in preds array.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":176-202",
            "content": "            count = np.bincount(pred[idx[j]:idx[j + 1]])\n            modes = np.where(count == count.max())[0]\n            if len(modes) == 1:\n                mode = modes\n            else:\n                if outputs.ndim == 3:\n                    # if more than one majority class exist\n                    prob_sum_max = 0\n                    for m in modes:\n                        prob_sum = output[m, idx[j]:idx[j + 1]].sum()\n                        if prob_sum_max < prob_sum:\n                            mode = m\n                            prob_sum_max = prob_sum\n                else:\n                    # decide first mode when more than one majority class\n                    # have the same number during oracle experiment\n                    mode = modes[0]\n            preds[i, idx[j]:idx[j + 1]] = mode\n    return preds\ndef relabeling(outputs, theta_t):\n    \"\"\"\n        Relabeling small action segments with their previous action segment\n        Args:\n            output: the results of action segmentation. (N, T) or (N, C, T)"
        },
        {
            "comment": "The code defines two functions: \"relabel\" and \"smoothing\". The relabel function takes predicted action segment labels, applies a threshold to merge adjacent segments with overlapping actions, and returns the relabeled output. The smoothing function applies a Gaussian filter to frame-wise action probabilities, resulting in final predictions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":203-241",
            "content": "            theta_t: the threshold of the size of action segments.\n        Return:\n            relabeled output. (N, T)\n        \"\"\"\n    preds = convert2label(outputs)\n    for i in range(preds.shape[0]):\n        # shape (T,)\n        last = preds[i][0]\n        cnt = 1\n        for j in range(1, preds.shape[1]):\n            if last == preds[i][j]:\n                cnt += 1\n            else:\n                if cnt > theta_t:\n                    cnt = 1\n                    last = preds[i][j]\n                else:\n                    preds[i][j - cnt:j] = preds[i][j - cnt - 1]\n                    cnt = 1\n                    last = preds[i][j]\n        if cnt <= theta_t:\n            preds[i][j - cnt:j] = preds[i][j - cnt - 1]\n    return preds\ndef smoothing(outputs, filter_func):\n    \"\"\"\n        Smoothing action probabilities with gaussian filter.\n        Args:\n            outputs: frame-wise action probabilities. (N, C, T)\n        Return:\n            predictions: final prediction. (N, T)\n        \"\"\"\n    outputs = convert2probability(outputs)"
        },
        {
            "comment": "This code is implementing ASRF post-processing for refining action boundary and classification. It takes in outputs_cls (action segmentation results), outputs_boundary (action boundary probability), refinement_method, boundary_threshold, theta_t (threshold of the size of action segments), and kernel_size as arguments. The code applies three processing steps: \"refinement_with_boundary\", \"relabeling\", and \"smoothing\" to refine the predict boundary and classification. It returns the preds output which is a (N, T) shape.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":242-269",
            "content": "    outputs = filter_func(paddle.to_tensor(outputs)).numpy()\n    preds = convert2label(outputs)\n    return preds\ndef ASRFPostProcessing(outputs_cls,\n                       outputs_boundary,\n                       refinement_method,\n                       boundary_threshold=0.7,\n                       theta_t=15,\n                       kernel_size=15):\n    \"\"\"\n    ASRF post processing is to refine action boundary\n    Args:\n        outputs_cls: the results of action segmentation. (N, T) or (N, C, T)\n        outputs_boundary: action boundary probability. (N, 1, T)\n        refinement_method: the way of refine predict boundary and classification. str\n        boundary_threshold: the threshold of the size of action segments. float(default=0.7)\n        theta_t: the threshold of the size of action segments. int(default=15)\n        kernel_size: Size of the gaussian kernel. int(default=15)\n    Return:\n        preds output. (N, T)\n    \"\"\"\n    func = [\n        \"refinement_with_boundary\",\n        \"relabeling\",\n        \"smoothing\","
        },
        {
            "comment": "This code segment defines a function that takes an input tensor and calculates the fan-in and fan-out. It also applies different refinement methods to outputs_cls based on the user-specified refinement method. If an invalid method is chosen, it returns a zero tensor. The code includes functions for smoothing, relabeling, and refinement with boundary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":270-300",
            "content": "    ]\n    if refinement_method == \"smoothing\":\n        filter_func = GaussianSmoothing(kernel_size)\n        preds = smoothing(outputs_cls, filter_func)\n    elif refinement_method == \"relabeling\":\n        preds = relabeling(outputs_cls, theta_t)\n    elif refinement_method == \"refinement_with_boundary\":\n        preds = refinement_with_boundary(outputs_cls, outputs_boundary,\n                                         boundary_threshold)\n    else:\n        preds = np.zeros((1, 1))\n        assert refinement_method in func\n    return paddle.to_tensor(preds)\ndef _calculate_fan_in_and_fan_out(tensor):\n    dimensions = len(tensor.shape)\n    if dimensions < 2:\n        raise ValueError(\"Fan in and fan out can not be computed \\\n        for tensor with fewer than 2 dimensions\")\n    if dimensions == 2:  # Linear\n        fan_in = tensor.shape[1]\n        fan_out = tensor.shape[0]\n    else:\n        num_input_fmaps = tensor.shape[1]\n        num_output_fmaps = tensor.shape[0]\n        receptive_field_size = 1\n        if tensor.dim() > 2:"
        },
        {
            "comment": "This code calculates the gain and fan-in/fan-out values for weight initialization in a neural network. It supports different nonlinearities such as 'tanh', 'relu', 'leaky_relu', and 'selu'. The function KaimingUniform_like_torch initializes weights using the Kaiming Uniform method with the specified nonlinearity, fan mode (fan_in or fan_out), and standard deviation of the initialization.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":301-334",
            "content": "            receptive_field_size = tensor[0][0].numel()\n        fan_in = num_input_fmaps * receptive_field_size\n        fan_out = num_output_fmaps * receptive_field_size\n    return fan_in, fan_out\ndef calculate_gain(nonlinearity=None, a=None):\n    if nonlinearity == 'tanh':\n        return 5.0 / 3\n    elif nonlinearity == 'relu':\n        return math.sqrt(2.0)\n    elif nonlinearity == 'leaky_relu':\n        if a is not None:\n            return math.sqrt(2.0 / (1 + a**2))\n        else:\n            return math.sqrt(2.0 / (1 + 0.01**2))\n    elif nonlinearity == 'selu':\n        return 3.0 / 4\n    else:\n        return 1\ndef KaimingUniform_like_torch(weight_npy,\n                              mode='fan_in',\n                              nonlinearity='leaky_relu'):\n    fan_in, fan_out = _calculate_fan_in_and_fan_out(weight_npy)\n    if mode == 'fan_in':\n        fan_mode = fan_in\n    else:\n        fan_mode = fan_out\n    a = math.sqrt(5.0)\n    gain = calculate_gain(nonlinearity=nonlinearity, a=a)\n    std = gain / math.sqrt(fan_mode)"
        },
        {
            "comment": "This code initializes weights and biases for a neural network layer. It calculates the fan-in and fan-out, determines bounds based on standard deviation or square root of three times the standard deviation for weights, and uses a uniform distribution within those bounds to initialize the weights and biases.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/framework/segmenters/utils.py\":335-342",
            "content": "    bound = math.sqrt(3.0) * std\n    return np.random.uniform(-bound, bound, weight_npy.shape)\ndef init_bias(weight_npy, bias_npy):\n    fan_in, fan_out = _calculate_fan_in_and_fan_out(weight_npy)\n    bound = 1.0 / math.sqrt(fan_in)\n    return np.random.uniform(-bound, bound, bias_npy.shape)"
        }
    ]
}