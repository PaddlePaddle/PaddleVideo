{
    "summary": "The code defines a ResNet-MANET model with BatchNorm, ReLU activation, and residual blocks using convolution, batch normalization, and max pooling layers. The model is initialized and processes input to obtain output and low-level features as JSON files.",
    "details": [
        {
            "comment": "This code defines the Bottleneck class for ResNet architecture, consisting of convolutional layers and batch normalization layers. It takes parameters such as inplanes, planes, stride, dilation, downsample, and BatchNorm for initialization.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":0-30",
            "content": "import paddle.nn as nn\n# from reprod_log.utils import paddle2np\nfrom EIVideo.paddlevideo.utils.manet_utils import fill_, zero_\nclass Bottleneck(nn.Layer):\n    expansion = 4\n    def __init__(self,\n                 inplanes,\n                 planes,\n                 stride=1,\n                 dilation=1,\n                 downsample=None,\n                 BatchNorm=None):\n        super(Bottleneck, self).__init__()\n        self.conv1 = nn.Conv2D(inplanes, planes, kernel_size=1, bias_attr=False)\n        self.bn1 = BatchNorm(planes)\n        self.conv2 = nn.Conv2D(planes,\n                               planes,\n                               kernel_size=3,\n                               stride=stride,\n                               dilation=dilation,\n                               padding=dilation,\n                               bias_attr=False)\n        self.bn2 = BatchNorm(planes)\n        self.conv3 = nn.Conv2D(planes,\n                               planes * 4,\n                               kernel_size=1,\n                               bias_attr=False)"
        },
        {
            "comment": "Class \"ResNet\" is a Residual Network backbone with multiple blocks and layers. It utilizes BatchNorm for normalization, ReLU as the activation function, and supports different output strides.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":31-74",
            "content": "        self.bn3 = BatchNorm(planes * 4)\n        self.relu = nn.ReLU()\n        self.downsample = downsample\n        self.stride = stride\n        self.dilation = dilation\n    def forward(self, x):\n        residual = x\n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = self.relu(out)\n        out = self.conv2(out)\n        out = self.bn2(out)\n        out = self.relu(out)\n        out = self.conv3(out)\n        out = self.bn3(out)\n        if self.downsample is not None:\n            residual = self.downsample(x)\n        out += residual\n        out = self.relu(out)\n        return out\nclass ResNet(nn.Layer):\n    def __init__(self,\n                 block,\n                 layers,\n                 output_stride,\n                 BatchNorm,\n                 pretrained=None):\n        self.inplanes = 64\n        super(ResNet, self).__init__()\n        blocks = [1, 2, 4]\n        if output_stride == 16:\n            strides = [1, 2, 2, 1]\n            dilations = [1, 1, 1, 2]\n        elif output_stride == 8:\n            strides = [1, 2, 1, 1]"
        },
        {
            "comment": "The code defines a ResNet-MANET backbone model with BatchNorm and ReLU activation functions. It initializes convolution, batch normalization, ReLU, max pooling layers along with the first two residual blocks based on input parameters such as block type, number of channels, number of layers, and strides. Dilations are assigned based on the provided conditions.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":75-100",
            "content": "            dilations = [1, 1, 2, 4]\n        else:\n            raise NotImplementedError\n        # Modules\n        self.conv1 = nn.Conv2D(3,\n                               64,\n                               kernel_size=7,\n                               stride=2,\n                               padding=3,\n                               bias_attr=False)\n        self.bn1 = BatchNorm(64)\n        self.relu = nn.ReLU()\n        self.maxpool = nn.MaxPool2D(kernel_size=3, stride=2, padding=1)\n        self.layer1 = self._make_layer(block,\n                                       64,\n                                       layers[0],\n                                       stride=strides[0],\n                                       dilation=dilations[0],\n                                       BatchNorm=BatchNorm)\n        self.layer2 = self._make_layer(block,\n                                       128,\n                                       layers[1],\n                                       stride=strides[1],\n                                       dilation=dilations[1],"
        },
        {
            "comment": "This code defines a ResNet-MANET model, creating layers and functions for the network architecture. It includes the creation of three main layers (layer1, layer2, and layer3), using blocks and specific parameters such as stride and dilation. The _make_MG_unit function is used to create an additional MG unit in the layer4. Finally, the init_weight method initializes the weight for the network.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":101-126",
            "content": "                                       BatchNorm=BatchNorm)\n        self.layer3 = self._make_layer(block,\n                                       256,\n                                       layers[2],\n                                       stride=strides[2],\n                                       dilation=dilations[2],\n                                       BatchNorm=BatchNorm)\n        self.layer4 = self._make_MG_unit(block,\n                                         512,\n                                         blocks=blocks,\n                                         stride=strides[3],\n                                         dilation=dilations[3],\n                                         BatchNorm=BatchNorm)\n        self.init_weight()\n    def _make_layer(self,\n                    block,\n                    planes,\n                    blocks,\n                    stride=1,\n                    dilation=1,\n                    BatchNorm=None):\n        downsample = None\n        if stride != 1 or self.inplanes != planes * block.expansion:"
        },
        {
            "comment": "This code defines a function _make_MG_unit that creates a residual block with downsampling for a ResNet model. The downsample operation is determined based on stride and inplanes values, and BatchNorm layer is optional.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":127-158",
            "content": "            downsample = nn.Sequential(\n                nn.Conv2D(self.inplanes,\n                          planes * block.expansion,\n                          kernel_size=1,\n                          stride=stride,\n                          bias_attr=False),\n                BatchNorm(planes * block.expansion),\n            )\n        layers = []\n        layers.append(\n            block(self.inplanes, planes, stride, dilation, downsample,\n                  BatchNorm))\n        self.inplanes = planes * block.expansion\n        for i in range(1, blocks):\n            layers.append(\n                block(self.inplanes,\n                      planes,\n                      dilation=dilation,\n                      BatchNorm=BatchNorm))\n        return nn.Sequential(*layers)\n    def _make_MG_unit(self,\n                      block,\n                      planes,\n                      blocks,\n                      stride=1,\n                      dilation=1,\n                      BatchNorm=None):\n        downsample = None\n        if stride != 1 or self.inplanes != planes * block.expansion:"
        },
        {
            "comment": "This code defines a ResNet-MANET backbone model. It uses BatchNorm layers and block functions to create multiple convolutional layers with different dilation rates. The forward function applies the first layer, batch normalization, and ReLU activation before returning the sequence of layers.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":159-190",
            "content": "            downsample = nn.Sequential(\n                nn.Conv2D(self.inplanes,\n                          planes * block.expansion,\n                          kernel_size=1,\n                          stride=stride,\n                          bias_attr=False),\n                BatchNorm(planes * block.expansion),\n            )\n        layers = []\n        layers.append(\n            block(self.inplanes,\n                  planes,\n                  stride,\n                  dilation=blocks[0] * dilation,\n                  downsample=downsample,\n                  BatchNorm=BatchNorm))\n        self.inplanes = planes * block.expansion\n        for i in range(1, len(blocks)):\n            layers.append(\n                block(self.inplanes,\n                      planes,\n                      stride=1,\n                      dilation=blocks[i] * dilation,\n                      BatchNorm=BatchNorm))\n        return nn.Sequential(*layers)\n    def forward(self, input):\n        x = self.conv1(input)\n        x = self.bn1(x)\n        x = self.relu(x)"
        },
        {
            "comment": "This code defines a ResNet101 model with BatchNorm and outputs the features at different stages. It initializes the weights of convolutional layers, and builds a backbone based on output stride and pretrained parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":191-226",
            "content": "        x = self.maxpool(x)\n        x = self.layer1(x)\n        low_level_feat = x\n        x = self.layer2(x)\n        x = self.layer3(x)\n        x = self.layer4(x)\n        return x, low_level_feat\n    def init_weight(self):\n        for m in self.sublayers():\n            if isinstance(m, nn.Conv2D):\n                n = m._kernel_size[0] * m._kernel_size[1] * m._out_channels\n                fill_(m.weight, 1)\n            elif isinstance(m, nn.BatchNorm2D):\n                fill_(m.weight, 1)\n                zero_(m.bias)\n        return self.sublayers()\ndef ResNet101(output_stride, BatchNorm, pretrained=None):\n    \"\"\"Constructs a ResNet-101 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"\n    model = ResNet(Bottleneck, [3, 4, 23, 3],\n                   output_stride,\n                   BatchNorm,\n                   pretrained=pretrained)\n    return model\ndef build_backbone(output_stride, BatchNorm, pretrained):\n    return ResNet101(output_stride, BatchNorm, pretrained)"
        },
        {
            "comment": "The code initializes a ResNet101 model, generates random input, passes it through the model to obtain output and low-level features, and saves them as JSON files.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/EIVideo/EIVideo/paddlevideo/modeling/backbones/resnet_manet.py\":229-244",
            "content": "if __name__ == \"__main__\":\n    import paddle\n    model = ResNet101(BatchNorm=nn.BatchNorm2D,\n                      pretrained=True,\n                      output_stride=8)\n    input = paddle.rand([1, 3, 512, 512])\n    output, low_level_feat = model(input)\n    print(output.shape)\n    print(low_level_feat.shape)\n    import json\n    with open('output.txt', 'w') as f:\n        json.dump(output.tolist(), f)\n    with open('low_level_feat.txt', 'w') as f:\n        json.dump(low_level_feat.tolist(), f)"
        }
    ]
}