{
    "summary": "The PaddleVideo library's code contains a utility function, ReadDict, which reads a dictionary file and performs image cropping, input point adjustment, calculates image size, and converts points to standard format. Another function captures frames from a video at specific indices and releases the video object post-capture.",
    "details": [
        {
            "comment": "This code is part of the PaddleVideo library, specifically in the cpp_infer/src/utility.cpp file. It includes necessary headers for utility functions, and defines the ReadDict function within the PaddleVideo namespace. The function reads a dictionary file located at the given path, and stores each line into a vector of strings named m_vec.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/utility.cpp\":0-32",
            "content": "// Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#include <dirent.h>\n#include <include/utility.h>\n#include <iostream>\n#include <ostream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <vector>\nnamespace PaddleVideo\n{\n    std::vector<std::string> Utility::ReadDict(const std::string &path)\n    {\n        std::ifstream in(path);\n        std::string line;\n        std::vector<std::string> m_vec;\n        if (in)\n        {\n            while (getline(in, line))"
        },
        {
            "comment": "The code reads a label file and returns its contents as a vector. It also retrieves all files in a directory, adding them to a vector if the directory is valid.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/utility.cpp\":33-66",
            "content": "            {\n                m_vec.push_back(line);\n            }\n        }\n        else\n        {\n            std::cout << \"no such label file: \" << path << \", exit the program...\"\n                      << std::endl;\n            exit(1);\n        }\n        return m_vec; // Use fstream to read the category list and return with vector\n    }\n    void Utility::GetAllFiles(const char *dir_name, std::vector<std::string> &all_inputs)\n    {\n        if (NULL == dir_name)\n        {\n            std::cout << \" dir_name is null ! \" << std::endl;\n            return;\n        }\n        struct stat s;\n        lstat(dir_name, &s);\n        if (!S_ISDIR(s.st_mode))\n        {\n            std::cout << \"dir_name is not a valid directory !\" << std::endl;\n            all_inputs.push_back(dir_name);\n            return;\n        }\n        else\n        {\n            struct dirent *filename; // return value for readdir()\n            DIR *dir;                // return value for opendir()\n            dir = opendir(dir_name);\n            if (NULL == dir)"
        },
        {
            "comment": "The code snippet opens a directory, reads all files except \".\" and \"..\", and adds the file paths to a vector. The GetRotateCropImage function takes an image and a bounding box as input, copies the source image, and stores x and y coordinates of the bounding box in separate arrays.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/utility.cpp\":67-92",
            "content": "            {\n                std::cout << \"Can not open dir \" << dir_name << std::endl;\n                return;\n            }\n            std::cout << \"Successfully opened the dir !\" << std::endl;\n            while ((filename = readdir(dir)) != NULL)\n            {\n                if (strcmp(filename->d_name, \".\") == 0 ||\n                    strcmp(filename->d_name, \"..\") == 0)\n                    continue;\n                // img_dir + std::string(\"/\") + all_inputs[0];\n                all_inputs.push_back(dir_name + std::string(\"/\") +\n                                     std::string(filename->d_name));\n            }\n        }\n    }\n    cv::Mat Utility::GetRotateCropImage(const cv::Mat &srcimage, std::vector<std::vector<int>> box)\n    {\n        cv::Mat image;\n        srcimage.copyTo(image);\n        std::vector<std::vector<int>> points = box;\n        int x_collect[4] = {box[0][0], box[1][0], box[2][0], box[3][0]};\n        int y_collect[4] = {box[0][1], box[1][1], box[2][1], box[3][1]};\n        int left = int(*std::min_element(x_collect, x_collect + 4));"
        },
        {
            "comment": "This code crops an image based on the x and y coordinates of its bounding box, then adjusts the input points accordingly. It calculates the width and height of the cropped image using the Euclidean distance formula, and converts the original input points to a standard format for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/utility.cpp\":93-117",
            "content": "        int right = int(*std::max_element(x_collect, x_collect + 4));\n        int top = int(*std::min_element(y_collect, y_collect + 4));\n        int bottom = int(*std::max_element(y_collect, y_collect + 4));\n        cv::Mat img_crop;\n        image(cv::Rect(left, top, right - left, bottom - top)).copyTo(img_crop);\n        for (int i = 0; i < points.size(); i++)\n        {\n            points[i][0] -= left;\n            points[i][1] -= top;\n        }\n        int img_crop_width = int(sqrt(pow(points[0][0] - points[1][0], 2) +\n                                      pow(points[0][1] - points[1][1], 2)));\n        int img_crop_height = int(sqrt(pow(points[0][0] - points[3][0], 2) +\n                                       pow(points[0][1] - points[3][1], 2)));\n        cv::Point2f pts_std[4];\n        pts_std[0] = cv::Point2f(0., 0.);\n        pts_std[1] = cv::Point2f(img_crop_width, 0.);\n        pts_std[2] = cv::Point2f(img_crop_width, img_crop_height);\n        pts_std[3] = cv::Point2f(0.f, img_crop_height);\n        cv::Point2f pointsf[4];"
        },
        {
            "comment": "This code initializes four points using cv::Point2f, gets a perspective transform matrix M using getPerspectiveTransform, warps the image using warpPerspective, checks if the resized image's rows exceed 1.5 times its columns, and if so, transposes and flips the image before returning it; otherwise, returns the resized image directly. This is part of a function that samples frames from a video file.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/utility.cpp\":118-145",
            "content": "        pointsf[0] = cv::Point2f(points[0][0], points[0][1]);\n        pointsf[1] = cv::Point2f(points[1][0], points[1][1]);\n        pointsf[2] = cv::Point2f(points[2][0], points[2][1]);\n        pointsf[3] = cv::Point2f(points[3][0], points[3][1]);\n        cv::Mat M = cv::getPerspectiveTransform(pointsf, pts_std);\n        cv::Mat dst_img;\n        cv::warpPerspective(img_crop, dst_img, M,\n                            cv::Size(img_crop_width, img_crop_height),\n                            cv::BORDER_REPLICATE);\n        if (float(dst_img.rows) >= float(dst_img.cols) * 1.5)\n        {\n            cv::Mat srcCopy = cv::Mat(dst_img.rows, dst_img.cols, dst_img.depth());\n            cv::transpose(dst_img, srcCopy);\n            cv::flip(srcCopy, srcCopy, 0);\n            return srcCopy;\n        }\n        else\n        {\n            return dst_img;\n        }\n    }\n    std::vector<cv::Mat> Utility::SampleFramesFromVideo(const std::string &VideoPath, const int &num_seg, const int &seg_len)\n    {\n        cv::VideoCapture capture(VideoPath); // Create a video object"
        },
        {
            "comment": "This code snippet checks if the video can be opened and exits if it cannot. It then calculates the number of frames in the video, determines the frame indices to sample for each segment based on the length of the segment and average duration between frames, and stores the sampled frames in a vector.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/utility.cpp\":146-180",
            "content": "        if (!capture.isOpened())\n        {\n            printf(\"[Error] video cannot be opened, please check the video [%s]\\n\", VideoPath.c_str());\n            capture.release();\n            exit(1);\n        }\n        int frames_len = capture.get(cv::CAP_PROP_FRAME_COUNT); // Get the total number of video frames\n        int average_dur = int(frames_len / num_seg);\n        std::vector<int> frames_idx;\n        for (int i = 0; i < num_seg; ++i)\n        {\n            int idx = 0;\n            if (average_dur >= seg_len)\n            {\n                idx = (average_dur - 1) / 2;\n                idx += i * average_dur;\n            }\n            else if (average_dur >= 1)\n            {\n                idx += i * average_dur;\n            }\n            else\n            {\n                idx = i;\n            }\n            for (int j = idx; j < idx + seg_len; ++j)\n            {\n                frames_idx.emplace_back(j % frames_len);\n            }\n        }\n        std::vector<cv::Mat> sampled_frames;\n        cv::Mat frame; // Create an object for storing sampled frames"
        },
        {
            "comment": "This function captures frames from a video at specific indices, stores them in sampled_frames vector, and releases the video object after capture.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/deploy/cpp_infer/src/utility.cpp\":181-191",
            "content": "        for (int i = 0; i < num_seg; ++i)\n        {\n            const int &frame_idx = frames_idx[i];\n            capture.set(cv::CAP_PROP_POS_FRAMES, frame_idx); // Set to frame_idx frame\n            capture >> frame;\n            sampled_frames.push_back(frame);\n        }\n        capture.release(); // Release the video object\n        return sampled_frames;\n    }\n} // namespace PaddleVideo"
        }
    ]
}