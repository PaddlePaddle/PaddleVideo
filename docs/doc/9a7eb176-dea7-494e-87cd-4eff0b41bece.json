{
    "summary": "The code imports libraries, defines functions for parsing arguments and log files, checks for names, reads a log file, stores results in \"parser_results\", loads ground truth from multiple files, and compares log results with ground truth for testing.",
    "details": [
        {
            "comment": "This code imports necessary libraries and defines functions for parsing command-line arguments, running shell commands, and retrieving results from log files. It uses ArgumentParser to handle command line arguments, subprocess to execute shell commands, and os to check file existence.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/test_tipc/compare_results.py\":0-39",
            "content": "import numpy as np\nimport os\nimport subprocess\nimport json\nimport argparse\nimport glob\ndef init_args():\n    parser = argparse.ArgumentParser()\n    # params for testing assert allclose\n    parser.add_argument(\"--atol\", type=float, default=1e-3)\n    parser.add_argument(\"--rtol\", type=float, default=1e-3)\n    parser.add_argument(\"--gt_file\", type=str, default=\"\")\n    parser.add_argument(\"--log_file\", type=str, default=\"\")\n    parser.add_argument(\"--precision\", type=str, default=\"fp32\")\n    return parser\ndef parse_args():\n    parser = init_args()\n    return parser.parse_args()\ndef run_shell_command(cmd):\n    p = subprocess.Popen(cmd,\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         shell=True)\n    out, err = p.communicate()\n    if p.returncode == 0:\n        return out.decode('utf-8')\n    else:\n        return None\ndef parser_results_from_log_by_name(log_path, names_list):\n    if not os.path.exists(log_path):\n        raise ValueError(\"The log file {} does not exists!\".format(log_path))"
        },
        {
            "comment": "This code checks if there are any names in the \"names_list\" and reads a log file at the specified \"log_path\". If the file contains \"python_infer\", it parses the python inference results, while for other log files, it parses C++ inference results. It stores the results in the \"parser_results\" dictionary with names as keys and corresponding values as either integers or floats.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/test_tipc/compare_results.py\":41-63",
            "content": "    if names_list is None or len(names_list) < 1:\n        return []\n    parser_results = {}\n    lines = open(log_path, 'r').read().splitlines()\n    if 'python_infer' in log_path:  # parse python inference\n        for line in lines:\n            split_items = line.replace('\\t', ' ')\n            split_items = split_items.split(' ')\n            split_items = [item for item in split_items if len(item) > 0]\n            for name in names_list:\n                if name in line:\n                    if '.' in split_items[-1]:\n                        parser_results[name] = float(split_items[-1])\n                    else:\n                        parser_results[name] = int(split_items[-1])\n    else:  # parse cpp inference\n        for line in lines:\n            split_items = line.replace('\\t', ' ')\n            split_items = split_items.split(' ')\n            split_items = [item for item in split_items if len(item) > 0]\n            if all([(name + ':') in split_items for name in names_list]):\n                # print(split_items)"
        },
        {
            "comment": "This code defines a function `load_gt_from_file` that reads and parses the contents of a log file. It first checks if the file exists, then opens it in read mode. For each line containing 'top-1 class' or 'top-1 score', it extracts the class and score values, storing them as key-value pairs in `parser_gt`. If the file is not found, it raises a ValueError with an error message. The code also handles dictionaries with string keys, allowing for easy integration into larger programs.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/test_tipc/compare_results.py\":64-88",
            "content": "                parser_results['class'] = int(split_items[2])\n                parser_results['score'] = float(split_items[-1])\n    return parser_results\ndef load_gt_from_file(gt_file):\n    if not os.path.exists(gt_file):\n        raise ValueError(\"The log file {} does not exists!\".format(gt_file))\n    with open(gt_file, 'r') as f:\n        data = f.readlines()\n        f.close()\n    parser_gt = {}\n    for line in data:\n        if 'top-1 class' in line:\n            split_items = line.replace('\\t', ' ')\n            split_items = split_items.split(' ')\n            split_items = [item for item in split_items if len(item) > 0]\n            parser_gt['top-1 class'] = int(split_items[-1])\n        elif 'top-1 score' in line:\n            split_items = line.replace('\\t', ' ')\n            split_items = split_items.split(' ')\n            split_items = [item for item in split_items if len(item) > 0]\n            parser_gt['top-1 score'] = float(split_items[-1])\n        elif \"score\" in line and 'segment' in line:\n            location_dict = eval(line)"
        },
        {
            "comment": "The code defines three functions:\n1. `load_gt_from_file` loads ground truth data from a file, handling both the cases when each line contains location details or class and score information.\n2. `collect_predict_from_logs` collects predict results from logs based on given key list.\n3. `load_gt_from_txts` loads ground truth collections from multiple files (fp32, fp16, int8), organizing them under corresponding keys in a dictionary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/test_tipc/compare_results.py\":89-117",
            "content": "            parser_gt[f\"score_{len(parser_gt)}\"] = location_dict['score']\n            parser_gt[f\"segment_{len(parser_gt)}\"] = location_dict['segment']\n        elif \"class:\" in line and \"score:\" in line:\n            split_items = line.replace('\\t', ' ')\n            split_items = split_items.split(' ')\n            split_items = [item for item in split_items if len(item) > 0]\n            parser_gt['class'] = int(split_items[2])\n            parser_gt['score'] = float(split_items[-1])\n    return parser_gt\ndef load_gt_from_txts(gt_file):\n    gt_list = glob.glob(gt_file)\n    gt_collection = {}\n    for gt_f in gt_list:\n        gt_dict = load_gt_from_file(gt_f)\n        basename = os.path.basename(gt_f)\n        if \"fp32\" in basename:\n            gt_collection[\"fp32\"] = [gt_dict, gt_f]\n        elif \"fp16\" in basename:\n            gt_collection[\"fp16\"] = [gt_dict, gt_f]\n        elif \"int8\" in basename:\n            gt_collection[\"int8\"] = [gt_dict, gt_f]\n        else:\n            continue\n    return gt_collection\ndef collect_predict_from_logs(log_path, key_list):"
        },
        {
            "comment": "The code reads logs from specified file paths and compares the results with ground truth data for testing purposes. It uses numpy's assert_allclose function to validate the accuracy of the predicted results against the ground truth. The usage example provides command line options to compare Python and C++ inferencing results.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/test_tipc/compare_results.py\":118-145",
            "content": "    log_list = glob.glob(log_path)\n    pred_collection = {}\n    for log_f in log_list:\n        pred_dict = parser_results_from_log_by_name(log_f, key_list)\n        key = os.path.basename(log_f)\n        pred_collection[key] = pred_dict\n    return pred_collection\ndef testing_assert_allclose(dict_x, dict_y, atol=1e-7, rtol=1e-7):\n    for k in dict_x:\n        np.testing.assert_allclose(np.array(dict_x[k]),\n                                   np.array(dict_y[k]),\n                                   atol=atol,\n                                   rtol=rtol)\nif __name__ == \"__main__\":\n    # Usage example:\n    # test python infer:\n    ## python3.7 test_tipc/compare_results.py --gt_file=./test_tipc/results/PP-TSM/*.txt  --log_file=./test_tipc/output/PP-TSM/python_infer_*.log\n    # test cpp infer:\n    ## python3.7 test_tipc/compare_results.py --gt_file=./test_tipc/results/PP-TSM_CPP/*.txt  --log_file=./test_tipc/output/PP-TSM_CPP/cpp_infer_*.log\n    args = parse_args()\n    gt_collection = load_gt_from_txts(args.gt_file)"
        },
        {
            "comment": "Iterates through the log files, compares \"fp32\", \"fp16\" and \"int8\" results with ground truth, uses testing_assert_allclose to check for consistency and prints success/failure messages.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/test_tipc/compare_results.py\":146-169",
            "content": "    key_list = gt_collection[\"fp32\"][0].keys()\n    pred_collection = collect_predict_from_logs(args.log_file, key_list)\n    for filename in pred_collection.keys():\n        if \"fp32\" in filename:\n            gt_dict, gt_filename = gt_collection[\"fp32\"]\n        elif \"fp16\" in filename:\n            gt_dict, gt_filename = gt_collection[\"fp16\"]\n        elif \"int8\" in filename:\n            gt_dict, gt_filename = gt_collection[\"int8\"]\n        else:\n            continue\n        pred_dict = pred_collection[filename]\n        try:\n            testing_assert_allclose(gt_dict,\n                                    pred_dict,\n                                    atol=args.atol,\n                                    rtol=args.rtol)\n            print(\n                \"Assert allclose passed! The results of {} and {} are consistent!\"\n                .format(filename, gt_filename))\n        except Exception as E:\n            print(E)\n            raise ValueError(\n                \"The results of {} and the results of {} are inconsistent!\"."
        },
        {
            "comment": "This line of code formats the filename and ground truth filename for comparison purposes in the context of image or video analysis.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/test_tipc/compare_results.py\":170-170",
            "content": "                format(filename, gt_filename))"
        }
    ]
}