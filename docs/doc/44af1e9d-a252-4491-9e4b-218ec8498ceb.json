{
    "summary": "This code defines a BMN loss function for PaddleVideo, considering time-scale attributes and ratio of positive entries. It also includes a loss function for object detection models with weighted samples, position losses, and ground truth IoU masks. The code further defines a loss function for PEM and TEAM tasks by combining predicted and ground truth values using three loss functions.",
    "details": [
        {
            "comment": "This code defines a BMN loss function for the PaddleVideo library. It is registered in the LOSSES registry and takes two arguments: dscale and tscale, which represent max duration length and sequence length respectively. The class extends BaseWeightedLoss, suggesting it combines multiple weighted losses.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/bmn_loss.py\":0-31",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport numpy as np\nimport paddle\nimport paddle.nn.functional as F\nfrom ..registry import LOSSES\nfrom .base import BaseWeightedLoss\n@LOSSES.register()\nclass BMNLoss(BaseWeightedLoss):\n    \"\"\"Loss for BMN model\n    Args:\n        tscale (int): sequence length, default 100.\n        dscale (int): max duration length, default 100.\n    \"\"\"\n    def __init__(self, dscale, tscale):\n        super().__init__()\n        self.dscale = dscale"
        },
        {
            "comment": "This code defines a class with a time-scale attribute, a method to create binary mask arrays, and a loss function for a specific task. The loss function takes in predicted start and end positions along with ground truth values and calculates a ratio between the number of entries and positive values. This ratio is then used to calculate a coefficient for the loss function.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/bmn_loss.py\":32-54",
            "content": "        self.tscale = tscale\n    def _get_mask(self, dscale, tscale):\n        bm_mask = []\n        for idx in range(dscale):\n            mask_vector = [1 for i in range(tscale - idx)\n                           ] + [0 for i in range(idx)]\n            bm_mask.append(mask_vector)\n        bm_mask = np.array(bm_mask, dtype='float32')\n        bm_mask = paddle.to_tensor(bm_mask)\n        bm_mask.stop_gradient = True\n        return bm_mask\n    def tem_loss_func(self, pred_start, pred_end, gt_start, gt_end):\n        def bi_loss(pred_score, gt_label, datatype):\n            pred_score = paddle.reshape(x=pred_score, shape=[-1])\n            gt_label = paddle.reshape(x=gt_label, shape=[-1])\n            gt_label.stop_gradient = True\n            pmask = paddle.cast(x=(gt_label > 0.5), dtype=datatype)\n            num_entries = paddle.cast(paddle.shape(pmask), dtype=datatype)\n            num_positive = paddle.cast(paddle.sum(pmask), dtype=datatype)\n            ratio = num_entries / num_positive\n            coef_0 = 0.5 * ratio / (ratio - 1)"
        },
        {
            "comment": "The code defines a loss function for object detection models. It calculates the loss by considering positive and negative samples, applying weights to each sample based on their ratio, and then combines them. The bi_loss function is used to calculate losses for start and end positions. In another function, Pem_reg_loss_func, it separates ground truth IoU map into three masks: high (>0.7), medium (<=0.7 & >0.3), and low (<=0.3 & >=0). It then applies these masks to calculate the loss.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/bmn_loss.py\":55-76",
            "content": "            coef_1 = 0.5 * ratio\n            epsilon = 0.000001\n            loss_pos = paddle.multiply(paddle.log(pred_score + epsilon), pmask)\n            loss_pos = coef_1 * paddle.mean(loss_pos)\n            loss_neg = paddle.multiply(paddle.log(1.0 - pred_score + epsilon),\n                                       (1.0 - pmask))\n            loss_neg = coef_0 * paddle.mean(loss_neg)\n            loss = -1 * (loss_pos + loss_neg)\n            return loss\n        loss_start = bi_loss(pred_start, gt_start, pred_start.dtype)\n        loss_end = bi_loss(pred_end, gt_end, pred_start.dtype)\n        loss = loss_start + loss_end\n        return loss\n    def pem_reg_loss_func(self, pred_score, gt_iou_map, mask):\n        gt_iou_map = paddle.multiply(gt_iou_map, mask)\n        u_hmask = paddle.cast(x=gt_iou_map > 0.7, dtype=pred_score.dtype)\n        u_mmask = paddle.logical_and(gt_iou_map <= 0.7, gt_iou_map > 0.3)\n        u_mmask = paddle.cast(x=u_mmask, dtype=pred_score.dtype)\n        u_lmask = paddle.logical_and(gt_iou_map <= 0.3, gt_iou_map >= 0.)"
        },
        {
            "comment": "Calculating the number of elements in different masks and using them to calculate ratios for later mask operations. Creating uniform masks and multiplying them with corresponding existing masks, then casting the results.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/bmn_loss.py\":77-100",
            "content": "        u_lmask = paddle.cast(x=u_lmask, dtype=pred_score.dtype)\n        u_lmask = paddle.multiply(u_lmask, mask)\n        num_h = paddle.cast(paddle.sum(u_hmask), dtype=pred_score.dtype)\n        num_m = paddle.cast(paddle.sum(u_mmask), dtype=pred_score.dtype)\n        num_l = paddle.cast(paddle.sum(u_lmask), dtype=pred_score.dtype)\n        r_m = num_h / num_m\n        u_smmask = paddle.uniform(shape=[\n            gt_iou_map.shape[1], gt_iou_map.shape[2]\n        ],\n                                  min=0.0,\n                                  max=1.0).astype(pred_score.dtype)\n        u_smmask = paddle.multiply(u_mmask, u_smmask)\n        u_smmask = paddle.cast(x=(u_smmask > (1. - r_m)),\n                               dtype=pred_score.dtype)\n        r_l = num_h / num_l\n        u_slmask = paddle.uniform(shape=[\n            gt_iou_map.shape[1], gt_iou_map.shape[2]\n        ],\n                                  min=0.0,\n                                  max=1.0).astype(pred_score.dtype)\n        u_slmask = paddle.multiply(u_lmask, u_slmask)"
        },
        {
            "comment": "In this code, u_slmask is created by comparing r_l with 1 and casting the result to the dtype of pred_score. Then, weights are calculated by adding u_hmask, u_smmask, and u_slmask. The stop_gradient attribute of weights is set to True. Loss is calculated using square error cost between pred_score and gt_iou_map, multiplied by weights, averaged, and returned.\nIn the pem_cls_loss_func, gt_iou_map is multiplied by mask and marked as non-trainable (stop_gradient = True). Pmask and nmask are created based on conditions with gt_iou_map and mask. Num_positive and num_entries are calculated. Ratios are used to determine coef_0 and coef_1. Loss_pos is log(pred_score + epsilon) multiplied by pmask.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/bmn_loss.py\":101-125",
            "content": "        u_slmask = paddle.cast(x=(u_slmask > (1. - r_l)),\n                               dtype=pred_score.dtype)\n        weights = u_hmask + u_smmask + u_slmask\n        weights.stop_gradient = True\n        loss = F.square_error_cost(pred_score, gt_iou_map)\n        loss = paddle.multiply(loss, weights)\n        loss = 0.5 * paddle.sum(loss) / paddle.sum(weights)\n        return loss\n    def pem_cls_loss_func(self, pred_score, gt_iou_map, mask):\n        gt_iou_map = paddle.multiply(gt_iou_map, mask)\n        gt_iou_map.stop_gradient = True\n        pmask = paddle.cast(x=(gt_iou_map > 0.9), dtype=pred_score.dtype)\n        nmask = paddle.cast(x=(gt_iou_map <= 0.9), dtype=pred_score.dtype)\n        nmask = paddle.multiply(nmask, mask)\n        num_positive = paddle.sum(pmask)\n        num_entries = num_positive + paddle.sum(nmask)\n        ratio = num_entries / num_positive\n        coef_0 = 0.5 * ratio / (ratio - 1)\n        coef_1 = 0.5 * ratio\n        epsilon = 0.000001\n        loss_pos = paddle.multiply(paddle.log(pred_score + epsilon), pmask)"
        },
        {
            "comment": "Function `forward` takes in `pred_bm`, `pred_start`, `pred_end`, `gt_iou_map`, `gt_start`, and `gt_end`. It first extracts `pred_bm_reg` and `pred_bm_cls` by slicing `pred_bm` along the specified axes. Then, it calculates the `bm_mask` using `_get_mask` with given scales. The function returns the calculated loss from the input parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/bmn_loss.py\":126-146",
            "content": "        loss_pos = coef_1 * paddle.sum(loss_pos)\n        loss_neg = paddle.multiply(paddle.log(1.0 - pred_score + epsilon),\n                                   nmask)\n        loss_neg = coef_0 * paddle.sum(loss_neg)\n        loss = -1 * (loss_pos + loss_neg) / num_entries\n        return loss\n    def forward(self, pred_bm, pred_start, pred_end, gt_iou_map, gt_start,\n                gt_end):\n        pred_bm_reg = paddle.squeeze(paddle.slice(pred_bm,\n                                                  axes=[1],\n                                                  starts=[0],\n                                                  ends=[1]),\n                                     axis=[1])\n        pred_bm_cls = paddle.squeeze(paddle.slice(pred_bm,\n                                                  axes=[1],\n                                                  starts=[1],\n                                                  ends=[2]),\n                                     axis=[1])\n        bm_mask = self._get_mask(self.dscale, self.tscale)"
        },
        {
            "comment": "This code calculates the loss for PEM and TEAM detection tasks by combining the predicted and ground truth values. It uses three loss functions: `pem_reg_loss_func`, `pem_cls_loss_func`, and `tem_loss_func`. The final loss is the sum of the temporal (TEM) loss, 10 times the PEM regression loss, and the PEM classification loss.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/bmn_loss.py\":148-154",
            "content": "        pem_reg_loss = self.pem_reg_loss_func(pred_bm_reg, gt_iou_map, bm_mask)\n        pem_cls_loss = self.pem_cls_loss_func(pred_bm_cls, gt_iou_map, bm_mask)\n        tem_loss = self.tem_loss_func(pred_start, pred_end, gt_start, gt_end)\n        loss = tem_loss + 10 * pem_reg_loss + pem_cls_loss\n        return loss"
        }
    ]
}