{
    "summary": "This code initializes a TSN model class and sets parameters for segmentation, training, image statistics, layers, epochs, video data, and optimizer. It defines a VideoTag model with train, test, and infer modes, updating parameters and excluding the final layer for pre-trained weights.",
    "details": [
        {
            "comment": "This code imports necessary modules and defines a class TSN that extends the ModelBase class. The class takes parameters such as name, configuration, mode and is_videotag. It also has a method get_config that fetches the model configuration from the given section.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn.py\":0-33",
            "content": "#  Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserve.\n#\n#Licensed under the Apache License, Version 2.0 (the \"License\");\n#you may not use this file except in compliance with the License.\n#You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n#Unless required by applicable law or agreed to in writing, software\n#distributed under the License is distributed on an \"AS IS\" BASIS,\n#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#See the License for the specific language governing permissions and\n#limitations under the License.\nfrom ..model import ModelBase\nfrom .tsn_res_model import TSN_ResNet\nimport logging\nimport paddle\nimport paddle.static as static\nlogger = logging.getLogger(__name__)\n__all__ = [\"TSN\"]\nclass TSN(ModelBase):\n    def __init__(self, name, cfg, mode='train', is_videotag=False):\n        super(TSN, self).__init__(name, cfg, mode=mode)\n        self.is_videotag = is_videotag\n        self.get_config()\n    def get_config(self):\n        self.num_classes = self.get_config_from_sec('model', 'num_classes')"
        },
        {
            "comment": "This code initializes various parameters for the TSN model. It sets segment number, segment length, image mean and standard deviation, number of layers, training epochs, total videos, learning rate, learning rate decay, L2 weight decay, and momentum using get_config_from_sec method.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn.py\":34-51",
            "content": "        self.seg_num = self.get_config_from_sec('model', 'seg_num')\n        self.seglen = self.get_config_from_sec('model', 'seglen')\n        self.image_mean = self.get_config_from_sec('model', 'image_mean')\n        self.image_std = self.get_config_from_sec('model', 'image_std')\n        self.num_layers = self.get_config_from_sec('model', 'num_layers')\n        self.num_epochs = self.get_config_from_sec('train', 'epoch')\n        self.total_videos = self.get_config_from_sec('train', 'total_videos')\n        self.base_learning_rate = self.get_config_from_sec(\n            'train', 'learning_rate')\n        self.learning_rate_decay = self.get_config_from_sec(\n            'train', 'learning_rate_decay')\n        self.l2_weight_decay = self.get_config_from_sec('train',\n                                                        'l2_weight_decay')\n        self.momentum = self.get_config_from_sec('train', 'momentum')\n        self.seg_num = self.get_config_from_sec(self.mode, 'seg_num',\n                                                self.seg_num)"
        },
        {
            "comment": "The code initializes the target size and batch size, then defines a `build_input` function to create data tensors for the model's inputs. It generates image and label tensors with specified shapes and data types, and optionally creates a DataLoader for handling data if not in infer mode. The feature and label inputs are stored as separate lists.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn.py\":52-74",
            "content": "        self.target_size = self.get_config_from_sec(self.mode, 'target_size')\n        self.batch_size = self.get_config_from_sec(self.mode, 'batch_size')\n    def build_input(self, use_dataloader=True):\n        image_shape = [3, self.target_size, self.target_size]\n        image_shape[0] = image_shape[0] * self.seglen\n        image_shape = [None, self.seg_num] + image_shape\n        self.use_dataloader = use_dataloader\n        image = static.data(name='image', shape=image_shape, dtype='float32')\n        if self.mode != 'infer':\n            label = static.data(name='label', shape=[None, 1], dtype='int64')\n        else:\n            label = None\n        if use_dataloader:\n            assert self.mode != 'infer', \\\n                        'dataloader is not recommendated when infer, please set use_dataloader to be false.'\n            self.dataloader = paddle.io.DataLoader.from_generator(\n                feed_list=[image, label], capacity=4, iterable=True)\n        self.feature_input = [image]\n        self.label_input = label"
        },
        {
            "comment": "The code defines a model with configurable parameters and builds the model instance. It also includes an optimizer function that adjusts learning rate based on epoch points and total videos.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn.py\":76-100",
            "content": "    def create_model_args(self):\n        cfg = {}\n        cfg['layers'] = self.num_layers\n        cfg['class_dim'] = self.num_classes\n        cfg['seg_num'] = self.seg_num\n        return cfg\n    def build_model(self):\n        cfg = self.create_model_args()\n        videomodel = TSN_ResNet(layers=cfg['layers'],\n                                seg_num=cfg['seg_num'],\n                                is_training=(self.mode == 'train'),\n                                is_extractor=self.is_videotag)\n        out = videomodel.net(input=self.feature_input[0],\n                             class_dim=cfg['class_dim'])\n        self.network_outputs = [out]\n    def optimizer(self):\n        assert self.mode == 'train', \"optimizer only can be get in train mode\"\n        epoch_points = [self.num_epochs / 3, self.num_epochs * 2 / 3]\n        total_videos = self.total_videos\n        step = int(total_videos / self.batch_size + 1)\n        bd = [e * step for e in epoch_points]\n        base_lr = self.base_learning_rate\n        lr_decay = self.learning_rate_decay"
        },
        {
            "comment": "This code defines a model for the VideoTag application. It creates an optimizer with a piecewise learning rate decay and L2 weight decay, calculates the loss using cross entropy, updates the loss value, returns the network outputs, and handles feeds and fetches based on the mode (train, valid or infer).",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn.py\":101-128",
            "content": "        lr = [base_lr, base_lr * lr_decay, base_lr * lr_decay * lr_decay]\n        l2_weight_decay = self.l2_weight_decay\n        momentum = self.momentum\n        optimizer = paddle.optimizer.Momentum(\n            learning_rate=paddle.optimizer.lr.PiecewiseDecay(boundaries=bd,\n                                                       values=lr),\n            momentum=momentum,\n            weight_decay=paddle.regularizer.L2Decay(coeff=l2_weight_decay))\n        return optimizer\n    def loss(self):\n        assert self.mode != 'infer', \"invalid loss calculationg in infer mode\"\n        cost = paddle.nn.functional.cross_entropy(input=self.network_outputs[0], \\\n                           label=self.label_input, ignore_index=-1)\n        self.loss_ = paddle.mean(x=cost)\n        return self.loss_\n    def outputs(self):\n        return self.network_outputs\n    def feeds(self):\n        return self.feature_input if self.mode == 'infer' else self.feature_input + [\n            self.label_input\n        ]\n    def fetches(self):\n        if self.mode == 'train' or self.mode == 'valid':"
        },
        {
            "comment": "This code defines a model with three modes: train, test, and infer. It returns the losses, network outputs, and label inputs in train and test modes, while only returning network outputs in infer mode. The function pretrain_info() returns no information, weights_info() also returns no info, and load_pretrain_params() loads pre-trained weights from a specific file while excluding the final fully connected (fc) layer.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn.py\":129-158",
            "content": "            losses = self.loss()\n            fetch_list = [losses, self.network_outputs[0], self.label_input]\n        elif self.mode == 'test':\n            losses = self.loss()\n            fetch_list = [losses, self.network_outputs[0], self.label_input]\n        elif self.mode == 'infer':\n            fetch_list = self.network_outputs\n        else:\n            raise NotImplementedError('mode {} not implemented'.format(\n                self.mode))\n        return fetch_list\n    def pretrain_info(self):\n        return None, None\n    def weights_info(self):\n        return None\n    def load_pretrain_params(self, exe, pretrain, prog):\n        def is_parameter(var):\n            return isinstance(var, paddle.framework.Parameter)\n        logger.info(\n            \"Load pretrain weights from {}, exclude fc layer.\".format(pretrain))\n        print(\"===pretrain===\", pretrain)\n        state_dict = paddle.static.load_program_state(pretrain)\n        dict_keys = list(state_dict.keys())\n        # remove fc layer when pretrain, because the number of classes in final fc may not match"
        },
        {
            "comment": "The code is deleting specific keys from the pretrained parameters and then setting the program state with the updated dictionary. This could be done to avoid loading unnecessary or conflicting parameters during the model's execution.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/VideoTag/models/tsn/tsn.py\":159-164",
            "content": "        for name in dict_keys:\n            if \"fc_0\" in name:\n                del state_dict[name]\n                print('Delete {} from pretrained parameters. Do not load it'.\n                      format(name))\n        paddle.static.set_program_state(prog, state_dict)"
        }
    ]
}