{
    "summary": "The `mask_damager` function from PaddleVideo library takes a mask and maximum rotation angle, damages and scales it by applying rotations and translations to create damaged labels.",
    "details": [
        {
            "comment": "This code defines a function, `mask_damager`, which randomly applies transformations to the input labels. It can make the entire label black with 20% probability or rotate and scale it by random values from predefined ranges. If morphology transformation is applied with 50% probability, it uses an open operation to modify the labels using a randomly generated kernel.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/utils/mask_damaging.py\":0-35",
            "content": "import numpy as np\nfrom scipy.ndimage import interpolation\ntry:\n    from skimage import morphology, transform\nexcept ImportError as e:\n    print(\n        f\"{e}, [scikit-image] package and it's dependencies is required for MA-Net.\"\n    )\nimport paddle\nimport cv2\nimport random\n####\ndef mask_damager(labels=None, p_black=0.2):\n    scales = (0.8, 1.0, 1.2)\n    kernel_size = random.randint(10, 15)\n    kernel = np.ones((kernel_size, kernel_size), np.uint8)\n    if random.random() < p_black:\n        final_label = paddle.zeros_like(labels)\n        final_label = final_label.squeeze().numpy()\n    else:\n        prot = random.randint(5, 15)\n        nrot = random.randint(-15, -5)\n        rots = [prot, nrot, 0]\n        rot = rots[random.randint(0, 2)]\n        sc = scales[random.randint(0, 2)]\n        _, _, h, w = labels.shape\n        tmp = labels.squeeze()\n        tmp = tmp.unsqueeze(-1)\n        tmp = tmp.numpy().astype(np.uint8)\n        morph_p = random.random()\n        if morph_p < 0.5:\n            tmp = cv2.morphologyEx(tmp, cv2.MORPH_OPEN, kernel)"
        },
        {
            "comment": "The code defines two functions, \"damage_masks\" and \"damage_masks_np\". The former applies mask damaging to a batch of input labels while the latter performs the actual mask damaging on individual numpy arrays. These functions can be used to alter the input masks by applying shifts, scales, and rotations. The output is then converted into a tensor for further processing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/utils/mask_damaging.py\":36-72",
            "content": "        else:\n            tmp = cv2.morphologyEx(tmp, cv2.MORPH_CLOSE, kernel)\n        tmp = tmp.astype(np.uint8)\n        center = (w / 2, h / 2)\n        M = cv2.getRotationMatrix2D(center, rot, sc)\n        final_label = cv2.warpAffine(tmp, M, (w, h), cv2.INTER_NEAREST)\n    return final_label\n#####\ndef damage_masks(labels, shift=True, scale=True, rotate=True):\n    \"\"\"\n    Args:\n    labels: numpy array (batch_size * 1 * h * w)\n    \"\"\"\n    bs, _, h, w = labels.shape\n    labels = labels.transpose([0, 2, 3, 1])\n    labels = labels.numpy()\n    final_label = []\n    for i in range(bs):\n        label = labels[i]\n        damaged_label = damage_masks_np(label, shift, scale, rotate)\n        final_label.append(damaged_label)\n    final_label = np.array(final_label)\n    final_label = paddle.to_tensor(final_label)\n    final_label = final_label.transpose([0, 3, 1, 2])\n    return final_label\ndef damage_masks_np(labels, shift=True, scale=True, rotate=True):\n    \"\"\"Performs the actual mask damaging in numpy.\n    Args:\n    labels: Int32 numpy array of shape (height, width, 1)."
        },
        {
            "comment": "This function takes a mask and applies various damage operations such as shifting, scaling, rotation, or dilation to it. It first extracts unique labels from the input mask, shuffles them for random depth ordering, and creates an empty damaged labels array. Then, for each unique label, it applies the single object mask damaging function to the corresponding mask region. The damaged masks are then combined with their original labels to create the final damaged labels array.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/utils/mask_damaging.py\":73-97",
            "content": "    shift: Boolean, whether to damage the masks by shifting.\n    scale: Boolean, whether to damage the masks by scaling.\n    rotate: Boolean, whether to damage the masks by rotation.\n    dilate: Boolean, whether to damage the masks by dilation.\n    Returns:\n    The damaged version of labels.\n    \"\"\"\n    unique_labels = np.unique(labels)\n    unique_labels = np.setdiff1d(unique_labels, [0])\n    # Shuffle to get random depth ordering when combining together.\n    np.random.shuffle(unique_labels)\n    damaged_labels = np.zeros_like(labels)\n    for l in unique_labels:\n        obj_mask = (labels == l)\n        damaged_obj_mask = _damage_single_object_mask(obj_mask, shift, scale,\n                                                      rotate)\n        damaged_labels[damaged_obj_mask] = l\n    return damaged_labels\ndef _damage_single_object_mask(mask, shift, scale, rotate):\n    \"\"\"Performs mask damaging in numpy for a single object.\n    Args:\n    mask: Boolean numpy array of shape(height, width, 1).\n    shift: Boolean, whether to damage the masks by shifting."
        },
        {
            "comment": "This code is from the PaddleVideo library and performs mask damage on a given input mask. The mask can be damaged by shifting, scaling, and/or rotation depending on the provided boolean parameters. The function _shift_mask() shifts the mask randomly based on the maximum shift factor. The returned mask is the damaged version of the original input mask.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/utils/mask_damaging.py\":98-128",
            "content": "    scale: Boolean, whether to damage the masks by scaling.\n    rotate: Boolean, whether to damage the masks by rotation.\n    dilate: Boolean, whether to damage the masks by dilation.\n    Returns:\n    The damaged version of mask.\n    \"\"\"\n    if shift:\n        mask = _shift_mask(mask)\n    if scale:\n        mask = _scale_mask(mask)\n    if rotate:\n        mask = _rotate_mask(mask)\n    return mask\ndef _shift_mask(mask, max_shift_factor=0.05):\n    \"\"\"Damages a mask for a single object by randomly shifting it in numpy.\n    Args:\n    mask: Boolean numpy array of shape(height, width, 1).\n    max_shift_factor: Float scalar, the maximum factor for random shifting.\n    Returns:\n    The shifted version of mask.\n    \"\"\"\n    nzy, nzx, _ = mask.nonzero()\n    h = nzy.max() - nzy.min()\n    w = nzx.max() - nzx.min()\n    size = np.sqrt(h * w)\n    offset = np.random.uniform(-size * max_shift_factor,\n                               size * max_shift_factor, 2)\n    shifted_mask = interpolation.shift(np.squeeze(mask, axis=2),\n                                       offset,"
        },
        {
            "comment": "The code contains three functions: _damage_mask, _scale_mask, and _rotate_mask. These functions are used to randomly damage a mask for a single object in the image. The _damage_mask function applies random noise to the mask by using random values from a uniform distribution and subtracting it from the original mask. The _scale_mask function scales the mask in numpy by applying a scale factor randomly generated within a specific range around 1.0. The _rotate_mask function rotates the mask by a random angle between -max_rot_degrees to max_rot_degrees degrees. These functions can be used together or separately depending on the desired damage to the mask.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/utils/mask_damaging.py\":129-154",
            "content": "                                       order=0).astype('bool')[..., np.newaxis]\n    return shifted_mask\ndef _scale_mask(mask, scale_amount=0.025):\n    \"\"\"Damages a mask for a single object by randomly scaling it in numpy.\n    Args:\n    mask: Boolean numpy array of shape(height, width, 1).\n    scale_amount: Float scalar, the maximum factor for random scaling.\n    Returns:\n    The scaled version of mask.\n    \"\"\"\n    nzy, nzx, _ = mask.nonzero()\n    cy = 0.5 * (nzy.max() - nzy.min())\n    cx = 0.5 * (nzx.max() - nzx.min())\n    scale_factor = np.random.uniform(1.0 - scale_amount, 1.0 + scale_amount)\n    shift = transform.SimilarityTransform(translation=[-cx, -cy])\n    inv_shift = transform.SimilarityTransform(translation=[cx, cy])\n    s = transform.SimilarityTransform(scale=[scale_factor, scale_factor])\n    m = (shift + (s + inv_shift)).inverse\n    scaled_mask = transform.warp(mask, m) > 0.5\n    return scaled_mask\ndef _rotate_mask(mask, max_rot_degrees=3.0):\n    \"\"\"Damages a mask for a single object by randomly rotating it in numpy."
        },
        {
            "comment": "This function takes a boolean numpy array mask and maximum rotation angle, then returns a scaled version of the mask after applying random rotations and translations.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/Ma-Net/utils/mask_damaging.py\":155-169",
            "content": "    Args:\n    mask: Boolean numpy array of shape(height, width, 1).\n    max_rot_degrees: Float scalar, the maximum number of degrees to rotate.\n    Returns:\n    The scaled version of mask.\n    \"\"\"\n    cy = 0.5 * mask.shape[0]\n    cx = 0.5 * mask.shape[1]\n    rot_degrees = np.random.uniform(-max_rot_degrees, max_rot_degrees)\n    shift = transform.SimilarityTransform(translation=[-cx, -cy])\n    inv_shift = transform.SimilarityTransform(translation=[cx, cy])\n    r = transform.SimilarityTransform(rotation=np.deg2rad(rot_degrees))\n    m = (shift + (r + inv_shift)).inverse\n    scaled_mask = transform.warp(mask, m) > 0.5\n    return scaled_mask"
        }
    ]
}