{
    "summary": "The code imports modules, defines functions for data processing and splitting, handles evaluation cases, transforms joints, encodes labels, and saves the training/testing sets in suitable formats. It applies translation, alignment, and uses \"split_dataset\" function to create train/test indices before printing 'Done!'.",
    "details": [
        {
            "comment": "This code imports necessary modules and defines constants for file paths. It checks if a directory exists, creates it if not, and defines a function to remove frames with NaN values while logging such occurrences.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":0-33",
            "content": "# ref: https://github.com/Uason-Chen/CTR-GCN/blob/main/data/ntu/seq_transformation.py\nimport os\nimport os.path as osp\nimport numpy as np\nimport pickle\nimport logging\nfrom sklearn.model_selection import train_test_split\nroot_path = './'\nstat_path = osp.join(root_path, 'statistics')\nsetup_file = osp.join(stat_path, 'setup.txt')\ncamera_file = osp.join(stat_path, 'camera.txt')\nperformer_file = osp.join(stat_path, 'performer.txt')\nreplication_file = osp.join(stat_path, 'replication.txt')\nlabel_file = osp.join(stat_path, 'label.txt')\nskes_name_file = osp.join(stat_path, 'skes_available_name.txt')\ndenoised_path = osp.join(root_path, 'denoised_data')\nraw_skes_joints_pkl = osp.join(denoised_path, 'raw_denoised_joints.pkl')\nframes_file = osp.join(denoised_path, 'frames_cnt.txt')\nsave_path = './'\nif not osp.exists(save_path):\n    os.mkdir(save_path)\ndef remove_nan_frames(ske_name, ske_joints, nan_logger):\n    num_frames = ske_joints.shape[0]\n    valid_frames = []\n    for f in range(num_frames):\n        if not np.any(np.isnan(ske_joints[f])):"
        },
        {
            "comment": "The code defines a function \"seq_translation\" that iterates through multiple skeleton joints sequences. It checks for missing frames and calculates the origin point. It returns valid frames only if any are found, or logs nan indices otherwise. The code also handles cases with one or two bodies in the sequence.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":34-62",
            "content": "            valid_frames.append(f)\n        else:\n            nan_indices = np.where(np.isnan(ske_joints[f]))[0]\n            nan_logger.info('{}\\t{:^5}\\t{}'.format(ske_name, f + 1,\n                                                   nan_indices))\n    return ske_joints[valid_frames]\ndef seq_translation(skes_joints):\n    for idx, ske_joints in enumerate(skes_joints):\n        num_frames = ske_joints.shape[0]\n        num_bodies = 1 if ske_joints.shape[1] == 75 else 2\n        if num_bodies == 2:\n            missing_frames_1 = np.where(ske_joints[:, :75].sum(axis=1) == 0)[0]\n            missing_frames_2 = np.where(ske_joints[:, 75:].sum(axis=1) == 0)[0]\n            cnt1 = len(missing_frames_1)\n            cnt2 = len(missing_frames_2)\n        i = 0  # get the \"real\" first frame of actor1\n        while i < num_frames:\n            if np.any(ske_joints[i, :75] != 0):\n                break\n            i += 1\n        origin = np.copy(ske_joints[i, 3:6])  # new origin: joint-2\n        for f in range(num_frames):\n            if num_bodies == 1:"
        },
        {
            "comment": "This code is performing sequence transformation for NTU RGB+D dataset. It subtracts origin from joint coordinates and handles missing frames by setting them to zero if there are only two actors. It also logs information about skeletons, frames, and joints using a logger.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":63-88",
            "content": "                ske_joints[f] -= np.tile(origin, 25)\n            else:  # for 2 actors\n                ske_joints[f] -= np.tile(origin, 50)\n        if (num_bodies == 2) and (cnt1 > 0):\n            ske_joints[missing_frames_1, :75] = np.zeros((cnt1, 75),\n                                                         dtype=np.float32)\n        if (num_bodies == 2) and (cnt2 > 0):\n            ske_joints[missing_frames_2, 75:] = np.zeros((cnt2, 75),\n                                                         dtype=np.float32)\n        skes_joints[idx] = ske_joints  # Update\n    return skes_joints\ndef frame_translation(skes_joints, skes_name, frames_cnt):\n    nan_logger = logging.getLogger('nan_skes')\n    nan_logger.setLevel(logging.INFO)\n    nan_logger.addHandler(logging.FileHandler(\"./nan_frames.log\"))\n    nan_logger.info('{}\\t{}\\t{}'.format('Skeleton', 'Frame', 'Joints'))\n    for idx, ske_joints in enumerate(skes_joints):\n        num_frames = ske_joints.shape[0]\n        # Calculate the distance between spine base (joint-1) and spine (joint-21)"
        },
        {
            "comment": "This code aligns all sequences to the same frame length by subtracting the origin (middle of spine joint) from each skeleton joint, normalizing the resulting coordinates based on the distance between the new origin and original origin. It updates the number of valid frames for each sequence and returns the aligned skeleton joints and updated frame counts.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":89-117",
            "content": "        j1 = ske_joints[:, 0:3]\n        j21 = ske_joints[:, 60:63]\n        dist = np.sqrt(((j1 - j21)**2).sum(axis=1))\n        for f in range(num_frames):\n            origin = ske_joints[f, 3:\n                                6]  # new origin: middle of the spine (joint-2)\n            if (ske_joints[f, 75:] == 0).all():\n                ske_joints[f, :75] = (ske_joints[f, :75] - np.tile(origin, 25)) / \\\n                                      dist[f] + np.tile(origin, 25)\n            else:\n                ske_joints[f] = (ske_joints[f] - np.tile(origin, 50)) / \\\n                                 dist[f] + np.tile(origin, 50)\n        ske_name = skes_name[idx]\n        ske_joints = remove_nan_frames(ske_name, ske_joints, nan_logger)\n        frames_cnt[idx] = num_frames  # update valid number of frames\n        skes_joints[idx] = ske_joints\n    return skes_joints, frames_cnt\ndef align_frames(skes_joints, frames_cnt):\n    \"\"\"\n    Align all sequences with the same frame length.\n    \"\"\"\n    num_skes = len(skes_joints)\n    max_num_frames = frames_cnt.max()  # 300"
        },
        {
            "comment": "This code is part of the PaddleVideo library and contains three functions. The first function, `seq_transformation`, takes a list of skeleton joints and transforms them into aligned positions for all frames. It handles cases where there are either one or two bodies. The second function, `one_hot_vector`, converts a list of labels into a one-hot encoded vector. Lastly, the third function, `split_train_val`, splits the training set into train and validation sets using a specified method (either 'sklearn' or user-defined) and ratio.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":118-149",
            "content": "    aligned_skes_joints = np.zeros((num_skes, max_num_frames, 150),\n                                   dtype=np.float32)\n    for idx, ske_joints in enumerate(skes_joints):\n        num_frames = ske_joints.shape[0]\n        num_bodies = 1 if ske_joints.shape[1] == 75 else 2\n        if num_bodies == 1:\n            aligned_skes_joints[idx, :num_frames] = np.hstack(\n                (ske_joints, np.zeros_like(ske_joints)))\n        else:\n            aligned_skes_joints[idx, :num_frames] = ske_joints\n    return aligned_skes_joints\ndef one_hot_vector(labels):\n    num_skes = len(labels)\n    labels_vector = np.zeros((num_skes, 60))\n    for idx, l in enumerate(labels):\n        labels_vector[idx, l] = 1\n    return labels_vector\ndef split_train_val(train_indices, method='sklearn', ratio=0.05):\n    \"\"\"\n    Get validation set by splitting data randomly from training set with two methods.\n    In fact, I thought these two methods are equal as they got the same performance.\n    \"\"\"\n    if method == 'sklearn':\n        return train_test_split(train_indices,"
        },
        {
            "comment": "This code defines a function to split a dataset into training and validation sets based on the input parameters. It also includes functionality for selecting the validation set from the training set using either sklearn or numpy methods, and saving labels and features (joints positions) for each sequence of each dataset.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":150-175",
            "content": "                                test_size=ratio,\n                                random_state=10000)\n    else:\n        np.random.seed(10000)\n        np.random.shuffle(train_indices)\n        val_num_skes = int(np.ceil(0.05 * len(train_indices)))\n        val_indices = train_indices[:val_num_skes]\n        train_indices = train_indices[val_num_skes:]\n        return train_indices, val_indices\ndef split_dataset(skes_name, skes_joints, label, performer, camera, evaluation,\n                  save_path):\n    train_indices, test_indices = get_indices(performer, camera, evaluation)\n    m = 'sklearn'  # 'sklearn' or 'numpy'\n    # Select validation set from training set\n    # train_indices, val_indices = split_train_val(train_indices, m)\n    # Save labels and num_frames for each sequence of each data set\n    train_labels = label[train_indices]\n    test_labels = label[test_indices]\n    train_x = skes_joints[train_indices]\n    # train_y = one_hot_vector(train_labels)\n    test_x = skes_joints[test_indices]\n    # test_y = one_hot_vector(test_labels)"
        },
        {
            "comment": "The code is creating evaluation paths, checking if they exist, and then initializing the paths for train_data.npy, train_label.pkl, val_data.npy, and val_label.pkl files. It reshapes the train and test data and saves them using np.save() function. The train and test labels are also saved separately in pickle format.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":177-203",
            "content": "    evaluation_path = osp.join(save_path, evaluation)\n    isExists = osp.exists(evaluation_path)\n    if not isExists:\n        os.makedirs(evaluation_path)\n    train_data_save_path = osp.join(evaluation_path, 'train_data.npy')\n    train_label_save_path = osp.join(evaluation_path, 'train_label.pkl')\n    val_data_save_path = osp.join(evaluation_path, 'val_data.npy')\n    val_label_save_path = osp.join(evaluation_path, 'val_label.pkl')\n    # reshape data\n    N, T, VC = train_x.shape\n    train_x = np.reshape(train_x, (N, T, 2, 25, 3))\n    train_x = np.transpose(train_x, (0, 4, 1, 3, 2))\n    N, T, VC = test_x.shape\n    test_x = np.reshape(test_x, (N, T, 2, 25, 3))\n    test_x = np.transpose(test_x, (0, 4, 1, 3, 2))\n    # save train\n    np.save(train_data_save_path, train_x)\n    out = [skes_name[train_indices], train_labels]\n    with open(train_label_save_path, 'wb') as f:\n        pickle.dump(out, f)\n    # save test\n    np.save(val_data_save_path, test_x)\n    out = [skes_name[test_indices], test_labels]\n    with open(val_label_save_path, 'wb') as f:"
        },
        {
            "comment": "This function, `get_indices`, takes performer and camera as inputs and returns the indices of training and test data based on either cross-subject or cross-view evaluation. For cross-subject, it selects train/test IDs, then finds their respective indices in the performer array. Similarly, for cross-view, it selects train/test camera IDs and finds their indices. The code handles both cases and returns the training and test indices separately.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":204-234",
            "content": "        pickle.dump(out, f)\ndef get_indices(performer, camera, evaluation='xsub'):\n    test_indices = np.empty(0)\n    train_indices = np.empty(0)\n    if evaluation == 'xsub':  # Cross Subject (Subject IDs)\n        train_ids = [\n            1, 2, 4, 5, 8, 9, 13, 14, 15, 16, 17, 18, 19, 25, 27, 28, 31, 34,\n            35, 38\n        ]\n        test_ids = [\n            3, 6, 7, 10, 11, 12, 20, 21, 22, 23, 24, 26, 29, 30, 32, 33, 36, 37,\n            39, 40\n        ]\n        # Get indices of test data\n        for idx in test_ids:\n            temp = np.where(performer == idx)[0]  # 0-based index\n            test_indices = np.hstack((test_indices, temp)).astype(np.int)\n        # Get indices of training data\n        for train_id in train_ids:\n            temp = np.where(performer == train_id)[0]  # 0-based index\n            train_indices = np.hstack((train_indices, temp)).astype(np.int)\n    else:  # Cross View (Camera IDs)\n        train_ids = [2, 3]\n        test_ids = 1\n        # Get indices of test data\n        temp = np.where(camera == test_ids)[0]  # 0-based index"
        },
        {
            "comment": "Code reads camera, performer, label, and frames_cnt from respective files. It loads skes_name and skes_joints data from file using pickle. Applies seq_translation and align_frames to skes_joints. Creates test_indices and train_ids by filtering camera ids. Returns train_indices and test_indices.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":235-262",
            "content": "        test_indices = np.hstack((test_indices, temp)).astype(np.int)\n        # Get indices of training data\n        for train_id in train_ids:\n            temp = np.where(camera == train_id)[0]  # 0-based index\n            train_indices = np.hstack((train_indices, temp)).astype(np.int)\n    return train_indices, test_indices\nif __name__ == '__main__':\n    camera = np.loadtxt(camera_file, dtype=np.int)  # camera id: 1, 2, 3\n    performer = np.loadtxt(performer_file, dtype=np.int)  # subject id: 1~40\n    label = np.loadtxt(label_file, dtype=np.int) - 1  # action label: 0~59\n    frames_cnt = np.loadtxt(frames_file, dtype=np.int)  # frames_cnt\n    skes_name = np.loadtxt(skes_name_file, dtype=np.string_)\n    with open(raw_skes_joints_pkl, 'rb') as fr:\n        skes_joints = pickle.load(fr)  # a list\n    skes_joints = seq_translation(skes_joints)\n    skes_joints = align_frames(skes_joints,\n                               frames_cnt)  # aligned to the same frame length\n    evaluations = ['xview', 'xsub']\n    for evaluation in evaluations:"
        },
        {
            "comment": "The code is calling the \"split_dataset\" function to process data, likely dividing it into training and testing sets. The input parameters include various file names, labels, performers, cameras, evaluation criteria, and a save path. Once completed, it prints 'Done!'.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/data/ntu-rgb-d/seq_transformation.py\":263-265",
            "content": "        split_dataset(skes_name, skes_joints, label, performer, camera,\n                      evaluation, save_path)\n    print('Done!')"
        }
    ]
}