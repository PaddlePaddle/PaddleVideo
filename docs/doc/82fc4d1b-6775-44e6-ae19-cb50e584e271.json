{
    "summary": "This code calculates smoothness and reprojection losses for depth estimation tasks, combining identity and reprojection losses to compute disparity loss. It handles day and night scenarios while saving images if necessary. The total loss is stored in the losses dictionary.",
    "details": [
        {
            "comment": "This code defines a function \"get_smooth_loss\" that calculates the smoothness loss for disparity images using color image gradients and disparity image gradients. It uses PaddlePaddle library functions like paddle.abs() and paddle.mean(). The function is part of the BaseWeightedLoss class in the LOSSES registry.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":0-28",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport paddle\nimport paddle.nn as nn\nfrom ..registry import LOSSES\nfrom .base import BaseWeightedLoss\ndef get_smooth_loss(disp, img):\n    \"\"\"Computes the smoothness loss for a disparity image\n    The color image is used for edge-aware smoothness\n    \"\"\"\n    grad_disp_x = paddle.abs(disp[:, :, :, :-1] - disp[:, :, :, 1:])\n    grad_disp_y = paddle.abs(disp[:, :, :-1, :] - disp[:, :, 1:, :])\n    grad_img_x = paddle.mean(paddle.abs(img[:, :, :, :-1] - img[:, :, :, 1:]),"
        },
        {
            "comment": "The code defines two classes: DiffLoss and MSE. DiffLoss calculates the loss between two inputs using L2 norm, while MSE calculates mean squared error loss for a single input. The function on lines 29-66 calculates gradients of disparity maps using image differences, applies exponential decay based on gradient values, and returns their average. This seems to be related to depth estimation or disparity prediction in computer vision tasks.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":29-66",
            "content": "                             1,\n                             keepdim=True)\n    grad_img_y = paddle.mean(paddle.abs(img[:, :, :-1, :] - img[:, :, 1:, :]),\n                             1,\n                             keepdim=True)\n    grad_disp_x *= paddle.exp(-grad_img_x)\n    grad_disp_y *= paddle.exp(-grad_img_y)\n    return grad_disp_x.mean() + grad_disp_y.mean()\nclass DiffLoss(nn.Layer):\n    def __init__(self):\n        super(DiffLoss, self).__init__()\n    def forward(self, input1, input2):\n        batch_size = input1.shape[0]\n        input1 = input1.reshape([batch_size, -1])\n        input2 = input2.reshape([batch_size, -1])\n        input1_l2 = input1\n        input2_l2 = input2\n        diff_loss = 0\n        dim = input1.shape[1]\n        for i in range(input1.shape[0]):\n            diff_loss = diff_loss + paddle.mean(\n                ((input1_l2[i:i + 1, :].mm(input2_l2[i:i + 1, :].T)).pow(2)) /\n                dim)\n        diff_loss = diff_loss / input1.shape[0]\n        return diff_loss\nclass MSE(nn.Layer):\n    def __init__(self):"
        },
        {
            "comment": "MSE class is a mean squared error loss function for PaddlePaddle, SIMSE class calculates the structured iterative mean squared error loss, and SSIM class computes the structural similarity index (SSIM) loss between a pair of images using various pooling operations and constants.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":67-103",
            "content": "        super(MSE, self).__init__()\n    def forward(self, pred, real):\n        diffs = paddle.add(real, -pred)\n        n = paddle.numel(diffs)\n        mse = paddle.sum(diffs.pow(2)) / n\n        return mse\nclass SIMSE(nn.Layer):\n    def __init__(self):\n        super(SIMSE, self).__init__()\n    def forward(self, pred, real):\n        diffs = paddle.add(real, -pred)\n        n = paddle.numel(diffs)\n        simse = paddle.sum(diffs).pow(2) / (n**2)\n        return simse\nclass SSIM(nn.Layer):\n    \"\"\"Layer to compute the SSIM loss between a pair of images\n    \"\"\"\n    def __init__(self):\n        super(SSIM, self).__init__()\n        self.mu_x_pool = nn.AvgPool2D(3, 1, exclusive=False)\n        self.mu_y_pool = nn.AvgPool2D(3, 1, exclusive=False)\n        self.sig_x_pool = nn.AvgPool2D(3, 1, exclusive=False)\n        self.sig_y_pool = nn.AvgPool2D(3, 1, exclusive=False)\n        self.sig_xy_pool = nn.AvgPool2D(3, 1, exclusive=False)\n        self.refl = nn.Pad2D(1, mode='reflect')\n        self.C1 = 0.01**2\n        self.C2 = 0.03**2"
        },
        {
            "comment": "This code defines a forward function for calculating the SSIM loss, which is used in the ADDSLoss class. The SSIM loss measures the structural similarity between two images and takes into account luminance (mu_x and mu_y) and contrast (sigma_x and sigma_y) for each image. It also considers the covariance of the two images (sigma_xy). The SSIM loss is then used in the ADDSLoss class to compute the reprojection loss between predicted and target images.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":105-136",
            "content": "    def forward(self, x, y):\n        x = self.refl(x)\n        y = self.refl(y)\n        mu_x = self.mu_x_pool(x)\n        mu_y = self.mu_y_pool(y)\n        sigma_x = self.sig_x_pool(x**2) - mu_x**2\n        sigma_y = self.sig_y_pool(y**2) - mu_y**2\n        sigma_xy = self.sig_xy_pool(x * y) - mu_x * mu_y\n        SSIM_n = (2 * mu_x * mu_y + self.C1) * (2 * sigma_xy + self.C2)\n        SSIM_d = (mu_x**2 + mu_y**2 + self.C1) * (sigma_x + sigma_y + self.C2)\n        return paddle.clip((1 - SSIM_n / SSIM_d) / 2, 0, 1)\n@LOSSES.register()\nclass ADDSLoss(BaseWeightedLoss):\n    def __init__(self, avg_reprojection, disparity_smoothness, no_ssim):\n        super(ADDSLoss, self).__init__()\n        self.avg_reprojection = avg_reprojection\n        self.disparity_smoothness = disparity_smoothness\n        self.no_ssim = no_ssim\n        self.loss_diff = DiffLoss()\n        self.loss_recon1 = MSE()\n        self.loss_recon2 = SIMSE()\n        self.loss_similarity = MSE()\n    def compute_reprojection_loss(self, pred, target):\n        \"\"\"Computes reprojection loss between a batch of predicted and target images"
        },
        {
            "comment": "This code computes the reprojection and smoothness losses for a minibatch by iterating over different scales. It calculates the L1 loss between the predicted depth and the target depth, and optionally computes the SSIM (Structural Similarity Index) loss as well. The reprojection loss is determined based on these two values, with 85% weighted towards the SSIM loss and 15% towards the L1 loss. The total loss for the minibatch is accumulated in the \"total_loss\" variable.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":137-172",
            "content": "        \"\"\"\n        abs_diff = paddle.abs(target - pred)\n        l1_loss = abs_diff.mean(1, True)\n        if not self.no_ssim:\n            self.ssim = SSIM()\n        if self.no_ssim:\n            reprojection_loss = l1_loss\n        else:\n            ssim_loss = self.ssim(pred, target).mean(1, True)\n            reprojection_loss = 0.85 * ssim_loss + 0.15 * l1_loss\n        return reprojection_loss\n    def compute_losses(self, inputs, outputs, is_night):\n        \"\"\"Compute the reprojection and smoothness losses for a minibatch\n        \"\"\"\n        losses = {}\n        total_loss = 0\n        for scale in outputs['scales']:\n            loss = 0\n            reprojection_losses = []\n            source_scale = 0\n            disp = outputs[(\"disp\", scale)]\n            if is_night:\n                color = inputs[(\"color_n\", 0, scale)]\n                target = inputs[(\"color_n\", 0, source_scale)]\n            else:\n                color = inputs[(\"color\", 0, scale)]\n                target = inputs[(\"color\", 0, source_scale)]\n            for frame_id in outputs['frame_ids'][1:]:"
        },
        {
            "comment": "This code computes reprojection losses for day and night scenarios, concatenates them into a single tensor, and then checks if average reprojection loss should be computed. If not, it saves both images and performs minimum operation all at once.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":173-196",
            "content": "                pred = outputs[(\"color\", frame_id, scale)]\n                reprojection_losses.append(\n                    self.compute_reprojection_loss(pred, target))\n            reprojection_losses = paddle.concat(reprojection_losses, 1)\n            identity_reprojection_losses = []\n            for frame_id in outputs['frame_ids'][1:]:\n                if is_night:\n                    pred = inputs[(\"color_n\", frame_id, source_scale)]\n                else:\n                    pred = inputs[(\"color\", frame_id, source_scale)]\n                identity_reprojection_losses.append(\n                    self.compute_reprojection_loss(pred, target))\n            identity_reprojection_losses = paddle.concat(\n                identity_reprojection_losses, 1)\n            if self.avg_reprojection:\n                identity_reprojection_loss = identity_reprojection_losses.mean(\n                    1, keepdim=True)\n            else:\n                # save both images, and do min all at once below\n                identity_reprojection_loss = identity_reprojection_losses"
        },
        {
            "comment": "This code calculates the depth loss by combining identity and reprojection losses, adds random numbers to break ties, concatenates them, selects minimum values for optimization, and calculates disparity smoothness loss. It then updates the total loss and stores it in the losses dictionary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":198-222",
            "content": "            if self.avg_reprojection:\n                reprojection_loss = reprojection_losses.mean(1, keepdim=True)\n            else:\n                reprojection_loss = reprojection_losses\n            # add random numbers to break ties\n            identity_reprojection_loss = identity_reprojection_loss + paddle.randn(\n                identity_reprojection_loss.shape) * 0.00001\n            combined = paddle.concat(\n                (identity_reprojection_loss, reprojection_loss), axis=1)\n            if combined.shape[1] == 1:\n                to_optimise = combined\n            else:\n                to_optimise = paddle.min(combined, axis=1)\n            loss = loss + to_optimise.mean()\n            mean_disp = disp.mean(2, True).mean(3, True)\n            norm_disp = disp / (mean_disp + 1e-7)\n            smooth_loss = get_smooth_loss(norm_disp, color)\n            loss = loss + self.disparity_smoothness * smooth_loss / (2**scale)\n            total_loss = total_loss + loss\n            losses[\"loss/{}\".format(scale)] = loss"
        },
        {
            "comment": "This code computes losses for both day and night scenes in a video, using the compute_losses function. It appends two target differences to the 'loss' list and adds them to the total loss. The target_diff1 and target_diff2 are calculated by the loss_diff function, comparing specific elements from the outputs. Target_diff3 and target_diff4 are also computed in a similar manner. The final total loss is divided by the number of scales and stored in the losses dictionary before returning.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":224-249",
            "content": "        total_loss /= len(outputs['scales'])\n        losses[\"loss\"] = total_loss\n        return losses\n    def forward(self, inputs, outputs):\n        losses_day = self.compute_losses(inputs, outputs, 'day')\n        losses_night = self.compute_losses(inputs, outputs['outputs_night'],\n                                           'night')\n        loss = 0\n        losses = []\n        # diff\n        target_diff1 = 0.5 * self.loss_diff(\n            outputs['result'][0], outputs['result'][2])  # 10 when batchsize=1\n        target_diff2 = 0.5 * self.loss_diff(outputs['result_night'][0],\n                                            outputs['result_night'][2])\n        losses.append(target_diff1)\n        losses.append(target_diff2)\n        loss = loss + target_diff1\n        loss = loss + target_diff2\n        target_diff3 = 1 * self.loss_diff(\n            outputs['result'][1], outputs['result'][3])  # 10 when batchsize=1\n        target_diff4 = 1 * self.loss_diff(outputs['result_night'][1],\n                                          outputs['result_night'][3])"
        },
        {
            "comment": "The code calculates multiple losses, including depth and reconstruction, for both daytime and night-time scenes. It then adds these losses to the total loss and appends them to the 'losses' list.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":250-275",
            "content": "        losses.append(target_diff3)\n        losses.append(target_diff4)\n        loss = loss + target_diff3\n        loss = loss + target_diff4\n        # recon\n        target_mse = 1 * self.loss_recon1(outputs['result'][5],\n                                          inputs[\"color_aug\", 0, 0])\n        loss = loss + target_mse\n        target_simse = 1 * self.loss_recon2(outputs['result'][5],\n                                            inputs[\"color_aug\", 0, 0])\n        loss = loss + target_simse\n        losses.append(target_mse)\n        losses.append(target_simse)\n        target_mse_night = 1 * self.loss_recon1(outputs['result_night'][5],\n                                                inputs[\"color_n_aug\", 0, 0])\n        loss = loss + target_mse_night\n        target_simse_night = 1 * self.loss_recon2(outputs['result_night'][5],\n                                                  inputs[\"color_n_aug\", 0, 0])\n        loss = loss + target_simse_night\n        losses.append(target_mse_night)\n        losses.append(target_simse_night)"
        },
        {
            "comment": "This code calculates a depth loss by comparing predicted depths with detached pseudo-labels, then adds it to the overall loss and appends it to the losses list. Finally, it updates the output dictionary with the total loss and separate day/night losses before returning the updated outputs.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/losses/depth_loss.py\":277-289",
            "content": "        # depth loss\n        pseudo_label = outputs[(\"disp\", 0)].detach()\n        depth_loss = 1 * self.loss_similarity(\n            outputs['outputs_night'][(\"disp\", 0)], pseudo_label)\n        loss = loss + depth_loss\n        losses.append(depth_loss)\n        outputs['loss'] = loss + losses_day['loss'] + losses_night['loss']\n        outputs['losses_day'] = losses_day['loss']\n        outputs['losses_night'] = losses_night['loss']\n        return outputs"
        }
    ]
}