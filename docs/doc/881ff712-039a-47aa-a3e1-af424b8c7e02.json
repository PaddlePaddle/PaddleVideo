{
    "summary": "This code generates ground truth data for the BMN model in table tennis applications, using the `combile_gts` function to extract action segments from root actions. It calculates video segments, appends annotations, and returns a dataset dictionary for TableTennis.",
    "details": [
        {
            "comment": "This code is responsible for generating ground truth data for the BMN model in a table tennis application. It takes in original gts (ground truth) data and outputs the modified gts_bmn dictionary. The code first sets the fps value from gts_data, then iterates over each sub-item in gts_data['gts']. If a sub-item has actions but its duration is less than bmn_window, it is skipped. Otherwise, the sub-item data gets stored in gts_bmn.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":0-47",
            "content": "\"\"\"\nget instance for bmn\n\u4f7f\u7528winds=8\u7684\u6ed1\u7a97\uff0c\u5c06\u6240\u6709\u5b50\u7a97\u53e3\u7684\u957f\u5ea6\u4e4b\u548c\u5c0f\u4e8ewinds\u7684\u8fdb\u884c\u5408\u5e76\n\u5408\u5e76\u540e\uff0c\u7236\u7a97\u53e3\u4ee3\u8868bmn\u8bad\u7ec3\u6570\u636e\uff0c\u5b50\u7a97\u53e3\u4ee3\u8868tsn\u8bad\u7ec3\u6570\u636e\n\"\"\"\nimport os\nimport sys\nimport json\nimport random\nimport pickle\nimport numpy as np\nimport math\n# for table tennis\nbmn_window = 8\ndataset = \"/home/aistudio/work/BMN/\"\nfeat_dir = dataset + '/Features_example'\nout_dir = dataset + '/Input_for_bmn'\nlabel_files = {\n    'train': 'label_cls14_small_train.json',\n    'validation': 'label_cls14_small_test.json'\n}\nglobal fps\ndef gen_gts_for_bmn(gts_data):\n    \"\"\"\n    @param, gts_data, original gts for action detection\n    @return, gts_bmn, output gts dict for bmn\n    \"\"\"\n    fps = gts_data['fps']\n    gts_bmn = {'fps': fps, 'gts': []}\n    for sub_item in gts_data['gts']:\n        url = sub_item['url']\n        max_length = sub_item['total_frames']\n        gts_bmn['gts'].append({\n            'url': url,\n            'total_frames': max_length,\n            'root_actions': []\n        })\n        sub_actions = sub_item['actions']\n        # \u8df3\u8fc7\u6ca1\u6709\u52a8\u4f5c\u7684\u7247\u6bb5\n        if len(sub_actions) == 0:\n            continue\n        # duration > bmn_window\uff0c \u52a8\u4f5c\u6301\u7eed\u65f6\u95f4\u5927\u4e8ebmn_windows\uff0c\u76f4\u63a5\u5220\u9664"
        },
        {
            "comment": "This code extracts video action segments using a sliding window and stores them in the \"root_actions\" list. If the duration of an action is too long, it splits it into multiple actions and appends them to the \"gts_bmn['gts'][-1]['root_actions']\". The \"before_id\" and \"after_id\" keep track of the first and last frame of each extracted action, while the \"bmn_window\" determines the maximum duration for a single action.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":48-73",
            "content": "        for idx, sub_action in enumerate(sub_actions):\n            if sub_action['end_id'] - sub_action['start_id'] > bmn_window:\n                sub_actions.pop(idx)\n        # \u3010\u6ed1\u52a8\u7a97\u53e3\uff0c\u628a\u6bcf\u4e00\u4e2a\u89c6\u9891\u91cc\u7684\u52a8\u4f5c\u7247\u6bb5\u63d0\u53d6\u51fa\u6765\u3011\n        root_actions = [sub_actions[0]]\n        # before_id, \u524d\u4e00\u52a8\u4f5c\u7684\u6700\u540e\u4e00\u5e27\n        # after_id, \u540e\u4e00\u52a8\u4f5c\u7684\u7b2c\u4e00\u5e27\n        before_id = 0\n        for idx in range(1, len(sub_actions)):\n            cur_action = sub_actions[idx]\n            duration = (cur_action['end_id'] - root_actions[0]['start_id'])\n            if duration > bmn_window:  # windows\u53ea\u80fd\u5305\u4f4f\u4e00\u4e2a\u52a8\u4f5c\u5c31\u5305\uff0c\u5305\u4e0d\u4f4f\u5c31\u5305\u591a\u4e2a\n                after_id = cur_action['start_id']\n                gts_bmn['gts'][-1]['root_actions'].append({\n                    'before_id':\n                    before_id,\n                    'after_id':\n                    after_id,\n                    'actions':\n                    root_actions\n                })\n                before_id = root_actions[-1]['end_id']  #\u66f4\u65b0\u6ed1\u7a97\n                root_actions = [cur_action]\n            else:\n                root_actions.append(cur_action)"
        },
        {
            "comment": "The code is defining a function `combile_gts` that takes in `gts_bmn`, `gts_process`, and `mode` as parameters. It sets `fps` based on the `gts_process` data, calculates `duration_frame` and `feature_frame`. Then it iterates over the `gts_process['gts']` list to extract action segments from each item's root actions, appending them to the `segments` list. The function returns these segments.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":74-107",
            "content": "            if idx == len(sub_actions) - 1:\n                after_id = max_length\n                gts_bmn['gts'][-1]['root_actions'].append({\n                    'before_id':\n                    before_id,\n                    'after_id':\n                    after_id,\n                    'actions':\n                    root_actions\n                })\n    return gts_bmn\ndef combile_gts(gts_bmn, gts_process, mode):\n    \"\"\"\n    1\u3001bmn_window \u8303\u56f4\u5185\u53ea\u6709\u4e00\u4e2a\u52a8\u4f5c\uff0c\u53ea\u53d6\u4e00\u4e2a\u76ee\u6807\u6846\n    2\u3001bmn_window \u8303\u56f4\u5185\u6709\u591a\u4e2a\u52a8\u4f5c\uff0c\u53d6\u4e09\u4e2a\u76ee\u6807\u6846(\u7b2c\u4e00\u4e2a\u52a8\u4f5c\u3001\u6700\u540e\u4e00\u4e2a\u52a8\u4f5c\u3001\u6240\u6709\u52a8\u4f5c)\n    \"\"\"\n    global fps\n    fps = gts_process['fps']\n    duration_second = bmn_window * 1.0\n    duration_frame = bmn_window * fps\n    feature_frame = duration_frame\n    for item in gts_process['gts']:\n        url = item['url']\n        basename = os.path.basename(url).split('.')[0]\n        root_actions = item['root_actions']\n        # \u628a\u6bcf\u4e00\u4e2a\u89c6\u9891\u91cc\u7684\u52a8\u4f5c\u7247\u6bb5\u63d0\u53d6\u51fa\u6765\n        for root_action in root_actions:\n            segments = []\n            # all actions\n            segments.append({\n                'actions': root_action['actions'],"
        },
        {
            "comment": "This code processes a list of actions and splits them into segments based on the number of elements. It adds extra segments for the first and last actions if there are more than one. Then, it processes each segment to fit a window size for compatibility with BMN input.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":108-133",
            "content": "                'before_id': root_action['before_id'],\n                'after_id': root_action['after_id']\n            })\n            if len(root_action['actions']) > 1:  #\u5982\u679c\u6709\u591a\u4e2a\u52a8\u4f5c\uff0c\u5219\u7b2c\u4e00\u4e2a\u52a8\u4f5c\u548c\u6700\u540e\u4e00\u4e2a\u52a8\u4f5c\uff0c\u989d\u5916\u6dfb\u52a0\u4e00\u6b21\n                # first action\n                segments.append({\n                    'actions': [root_action['actions'][0]],\n                    'before_id':\n                    root_action['before_id'],\n                    'after_id':\n                    root_action['actions'][1]['start_id']\n                })\n                # last action\n                segments.append({\n                    'actions': [root_action['actions'][-1]],\n                    'before_id':\n                    root_action['actions'][-2]['end_id'],\n                    'after_id':\n                    root_action['after_id']\n                })\n            # \u628a\u52a8\u4f5c\u7247\u6bb5\u5904\u7406\u6210window size\u5927\u5c0f\uff0c\u4ee5\u9002\u914dBMN\u8f93\u5165\n            for segment in segments:\n                before_id = segment['before_id']\n                after_id = segment['after_id']\n                actions = segment['actions']"
        },
        {
            "comment": "This code snippet is determining the start and end points for a segment of video data based on action IDs. It ensures that the segment contains the entire sequence of actions, with some randomness in selecting the starting point within the specified range. The selected segment will be used to create an instance of the TableTennis application.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":134-153",
            "content": "                # before_id\u5230after_id\u592a\u957f\u4e86\uff0c\u4ece\u91cc\u9762\u53d6window_size\u5e27\uff0c\u8981\u5148\u786e\u5b9a\u4e00\u4e2a\u8d77\u59cb\u70b9\uff0c\u7136\u540e\u52a8\u4f5c\u90fd\u8981\u5305\u4f4f\n                box0 = max(actions[-1]['end_id'] - bmn_window,\n                           before_id)  #\u786e\u5b9a\u8d77\u59cb\u70b9\n                box1 = min(actions[0]['start_id'],\n                           after_id - bmn_window)  #\u786e\u5b9e\u8d77\u59cb\u70b9\n                if box0 <= box1:  # \u4e00\u6b21\u68c0\u67e5\n                    if int(box0) - int(box1) == 0:\n                        cur_start = box0\n                    else:\n                        box0 = math.ceil(box0)\n                        box1 = int(box1)\n                        cur_start = random.randint(box0, box1)\n                    cur_end = cur_start + bmn_window\n                    cur_start = round(cur_start, 2)\n                    cur_end = round(cur_end, 2)\n                    name = '{}_{}_{}'.format(basename, cur_start, cur_end)\n                    annotations = []\n                    for action in actions:\n                        label = str(1.0 * action['label_ids'][0])\n                        label_name = action['label_names'][0]"
        },
        {
            "comment": "The code segment defines a function that calculates segments of video data based on start and end IDs. It then appends the calculated segments, along with their corresponding labels and label names, to an 'annotations' list. The function returns a dictionary containing information about the duration, frame rate, feature frames, subset type, and annotations for a given dataset or model (in this case, named 'bmn'). Additionally, the code defines another function that saves the calculated features to a specified folder if it doesn't exist, and handles any missing files.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":154-181",
            "content": "                        seg0 = 1.0 * round((action['start_id'] - cur_start),\n                                           2)  #\u5b58\u50a8\u7684\u662f\u5230\u5f00\u59cb\u4f4d\u7f6e(\u65f6\u95f4: s)\u7684\u8ddd\u79bb\n                        seg1 = 1.0 * round((action['end_id'] - cur_start), 2)\n                        annotations.append({\n                            'segment': [seg0, seg1],\n                            'label': label,\n                            'label_name': label_name\n                        })\n                    gts_bmn[name] = {\n                        'duration_second': duration_second,\n                        'duration_frame': duration_frame,\n                        'feature_frame': feature_frame,\n                        'subset': mode,\n                        'annotations': annotations\n                    }\n    return gts_bmn\ndef save_feature_to_numpy(gts_bmn, folder):\n    global fps\n    print('save feature for bmn ...')\n    if not os.path.exists(folder):\n        os.mkdir(folder)\n    process_gts_bmn = {}\n    miss = 0\n    for item, value in gts_bmn.items():\n        # split to rsplit \u9488\u5bf9\u6587\u4ef6\u547d\u540d\u4fee\u6539"
        },
        {
            "comment": "The code is parsing video file names and extracting features from them. It then stores these features in a dictionary with corresponding start and end timestamps, and checks if any segments exceed the video length before saving the feature cut.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":182-206",
            "content": "        basename, start_id, end_id = item.rsplit('_', 2)\n        if not basename in process_gts_bmn:\n            process_gts_bmn[basename] = []\n        process_gts_bmn[basename].append({\n            'name': item,\n            'start': float(start_id),\n            'end': float(end_id)\n        })\n    for item, values in process_gts_bmn.items():\n        feat_path = os.path.join(feat_dir, item + '.pkl')\n        feature_video = pickle.load(open(feat_path, 'rb'))['image_feature']\n        for value in values:\n            save_cut_name = os.path.join(folder, value['name'])\n            a, b, c = save_cut_name.rsplit('_', 2)\n            if float(b) > 360:\n                print(b)\n            start_frame = round(value['start'] * fps)\n            end_frame = round(value['end'] * fps)\n            if end_frame > len(feature_video):\n                miss += 1\n                continue\n            feature_cut = [\n                feature_video[i] for i in range(start_frame, end_frame)\n            ]\n            np_feature_cut = np.array(feature_cut, dtype=np.float32)"
        },
        {
            "comment": "The code is saving processed data for a table tennis dataset. It creates a dictionary 'gts_bmn' from json files, processes it using 'gen_gts_for_bmn', combines it with existing data in 'gts_bmn', and then saves it as 'label.json' and 'feature'. It also handles creating the output directory if necessary.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/applications/TableTennis/get_instance_for_bmn.py\":207-226",
            "content": "            np.save(save_cut_name, np_feature_cut)\n    print('miss number (broken sample):', miss)\nif __name__ == \"__main__\":\n    if not os.path.exists(out_dir):\n        os.mkdir(out_dir)\n    gts_bmn = {}\n    for item, value in label_files.items():\n        label_file = os.path.join(dataset, value)\n        gts_data = json.load(open(label_file, 'rb'))\n        gts_process = gen_gts_for_bmn(gts_data)\n        gts_bmn = combile_gts(gts_bmn, gts_process, item)\n    with open(out_dir + '/label.json', 'w', encoding='utf-8') as f:\n        data = json.dumps(gts_bmn, indent=4, ensure_ascii=False)\n        f.write(data)\n    save_feature_to_numpy(gts_bmn, out_dir + '/feature')"
        }
    ]
}