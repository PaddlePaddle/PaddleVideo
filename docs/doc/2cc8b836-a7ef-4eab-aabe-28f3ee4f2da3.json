{
    "summary": "The code utilizes PaddleVideo's image processing pipeline for efficient frame sampling, defines a sampler class for video decoding and data conversion, and calculates sampling positions, offsets, and generates frame indices for video sequences.",
    "details": [
        {
            "comment": "This code is a Python module that imports various libraries and defines an image processing pipeline for PaddleVideo. It checks if SimpleITK is installed, handles pickling, and registers the pipeline using PaddleVideo's registry.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":0-37",
            "content": "# Copyright (c) 2020  PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport os\nimport random\nimport numpy as np\nfrom PIL import Image\ntry:\n    import SimpleITK as sitk\nexcept ImportError as e:\n    print(\n        f\"Warning! {e}, [SimpleITK] package and it's dependencies is required for PP-Care.\"\n    )\nimport cv2\nfrom ..registry import PIPELINES\ntry:\n    import cPickle as pickle\n    from cStringIO import StringIO\nexcept ImportError:\n    import pickle\n    from io import BytesIO\n@PIPELINES.register()"
        },
        {
            "comment": "The `Sampler` class is used to sample frames based on various parameters such as number of segments, length of each segment, frame interval, valid mode, select left flag and whether to use PIL for reading images. It returns the index of sampled frames.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":38-65",
            "content": "class Sampler(object):\n    \"\"\"\n    Sample frames id.\n    NOTE: Use PIL to read image here, has diff with CV2\n    Args:\n        num_seg(int): number of segments.\n        seg_len(int): number of sampled frames in each segment.\n        valid_mode(bool): True or False.\n        select_left: Whether to select the frame to the left in the middle when the sampling interval is even in the test mode.\n    Returns:\n        frames_idx: the index of sampled #frames.\n    \"\"\"\n    def __init__(self,\n                 num_seg,\n                 seg_len,\n                 frame_interval=None,\n                 valid_mode=False,\n                 select_left=False,\n                 dense_sample=False,\n                 linspace_sample=False,\n                 use_pil=True):\n        self.num_seg = num_seg\n        self.seg_len = seg_len\n        self.frame_interval = frame_interval\n        self.valid_mode = valid_mode\n        self.select_left = select_left\n        self.dense_sample = dense_sample\n        self.linspace_sample = linspace_sample"
        },
        {
            "comment": "The code defines a class with an attribute 'use_pil' that determines the image format. The '_get' method retrieves frames based on data format (frame, MRI, or video), applies necessary conversions and resizing, and stores them in 'imgs'. It uses different libraries such as Image, sitk, and cv2 for different formats.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":66-95",
            "content": "        self.use_pil = use_pil\n    def _get(self, frames_idx, results):\n        data_format = results['format']\n        if data_format == \"frame\":\n            frame_dir = results['frame_dir']\n            imgs = []\n            for idx in frames_idx:\n                img = Image.open(\n                    os.path.join(frame_dir,\n                                 results['suffix'].format(idx))).convert('RGB')\n                imgs.append(img)\n        elif data_format == \"MRI\":\n            frame_dir = results['frame_dir']\n            imgs = []\n            MRI = sitk.GetArrayFromImage(sitk.ReadImage(frame_dir))\n            for idx in frames_idx:\n                item = MRI[idx]\n                item = cv2.resize(item, (224, 224))\n                imgs.append(item)\n        elif data_format == \"video\":\n            if results['backend'] == 'cv2':\n                frames = np.array(results['frames'])\n                imgs = []\n                for idx in frames_idx:\n                    imgbuf = frames[idx]\n                    img = Image.fromarray(imgbuf, mode='RGB')"
        },
        {
            "comment": "Code is handling video decoding using different backends such as 'opencv', 'decord', and 'pyav'. It appends the frames to imgs list, converts numpy array to image using Image.fromarray method for 'decord' backend, and handles frame indexing and data structures based on backend used.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":96-118",
            "content": "                    imgs.append(img)\n            elif results['backend'] == 'decord':\n                container = results['frames']\n                if self.use_pil:\n                    frames_select = container.get_batch(frames_idx)\n                    # dearray_to_img\n                    np_frames = frames_select.asnumpy()\n                    imgs = []\n                    for i in range(np_frames.shape[0]):\n                        imgbuf = np_frames[i]\n                        imgs.append(Image.fromarray(imgbuf, mode='RGB'))\n                else:\n                    if frames_idx.ndim != 1:\n                        frames_idx = np.squeeze(frames_idx)\n                    frame_dict = {\n                        idx: container[idx].asnumpy()\n                        for idx in np.unique(frames_idx)\n                    }\n                    imgs = [frame_dict[idx] for idx in frames_idx]\n            elif results['backend'] == 'pyav':\n                imgs = []\n                frames = np.array(results['frames'])\n                for idx in frames_idx:"
        },
        {
            "comment": "This code snippet is responsible for sampling frames from a video sequence, and it handles different scenarios based on the input parameters. If `dense_sample` is True, it adjusts the index before accessing the frame. The frames are then appended to a list called `imgs`. If neither of the else conditions are met, it raises a `NotImplementedError`. The function also includes another method, `_get_train_clips`, which calculates clip offsets for training purposes based on the number of frames and other parameters.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":119-143",
            "content": "                    if self.dense_sample:\n                        idx = idx - 1\n                    imgbuf = frames[idx]\n                    imgs.append(imgbuf)\n                imgs = np.stack(imgs)  # thwc\n            else:\n                raise NotImplementedError\n        else:\n            raise NotImplementedError\n        results['imgs'] = imgs\n        return results\n    def _get_train_clips(self, num_frames):\n        ori_seg_len = self.seg_len * self.frame_interval\n        avg_interval = (num_frames - ori_seg_len + 1) // self.num_seg\n        if avg_interval > 0:\n            base_offsets = np.arange(self.num_seg) * avg_interval\n            clip_offsets = base_offsets + np.random.randint(avg_interval,\n                                                            size=self.num_seg)\n        elif num_frames > max(self.num_seg, ori_seg_len):\n            clip_offsets = np.sort(\n                np.random.randint(num_frames - ori_seg_len + 1,\n                                  size=self.num_seg))\n        elif avg_interval == 0:"
        },
        {
            "comment": "The code defines a class with methods to determine clip offsets based on the number of frames and segment length. If the number of frames exceeds the original segment length, it calculates clip offsets for each segment. Otherwise, it sets all clip offsets to zero. The class also has a __call__ method that takes frames length as input and returns sampling indices.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":144-170",
            "content": "            ratio = (num_frames - ori_seg_len + 1.0) / self.num_seg\n            clip_offsets = np.around(np.arange(self.num_seg) * ratio)\n        else:\n            clip_offsets = np.zeros((self.num_seg, ), dtype=np.int)\n        return clip_offsets\n    def _get_test_clips(self, num_frames):\n        ori_seg_len = self.seg_len * self.frame_interval\n        avg_interval = (num_frames - ori_seg_len + 1) / float(self.num_seg)\n        if num_frames > ori_seg_len - 1:\n            base_offsets = np.arange(self.num_seg) * avg_interval\n            clip_offsets = (base_offsets + avg_interval / 2.0).astype(np.int)\n        else:\n            clip_offsets = np.zeros((self.num_seg, ), dtype=np.int)\n        return clip_offsets\n    def __call__(self, results):\n        \"\"\"\n        Args:\n            frames_len: length of frames.\n        return:\n            sampling id.\n        \"\"\"\n        frames_len = int(results['frames_len'])\n        frames_idx = []\n        if self.frame_interval is not None:\n            assert isinstance(self.frame_interval, int)"
        },
        {
            "comment": "This code determines the sampling method for frames based on the mode (valid or train) and format ('video' or 'frame'). It calculates offsets, handles different formats, and if linspace_sample is True, it generates offsets using linear spacing.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":171-198",
            "content": "            if not self.valid_mode:\n                offsets = self._get_train_clips(frames_len)\n            else:\n                offsets = self._get_test_clips(frames_len)\n            offsets = offsets[:, None] + np.arange(\n                self.seg_len)[None, :] * self.frame_interval\n            offsets = np.concatenate(offsets)\n            offsets = offsets.reshape((-1, self.seg_len))\n            offsets = np.mod(offsets, frames_len)\n            offsets = np.concatenate(offsets)\n            if results['format'] == 'video':\n                frames_idx = offsets\n            elif results['format'] == 'frame':\n                frames_idx = list(offsets + 1)\n            else:\n                raise NotImplementedError\n            return self._get(frames_idx, results)\n        if self.linspace_sample:\n            if 'start_idx' in results and 'end_idx' in results:\n                offsets = np.linspace(results['start_idx'], results['end_idx'],\n                                      self.num_seg)\n            else:\n                offsets = np.linspace(0, frames_len - 1, self.num_seg)"
        },
        {
            "comment": "This code segment calculates the frames to sample from a video, based on its format (video/frame/MRI). It also handles dense sampling for ppTSM. In non-dense mode, it selects random positions for each segment within the range of 1 to frames_len. For dense sampling in train mode, it generates a set of evenly spaced frame indices between start_idx and sample_pos, which is calculated based on frames_len and 64 (to ensure at least one frame within the window). The offsets are then used to fetch corresponding data using the _get method.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":199-222",
            "content": "            offsets = np.clip(offsets, 0, frames_len - 1).astype(np.int64)\n            if results['format'] == 'video':\n                frames_idx = list(offsets)\n                frames_idx = [x % frames_len for x in frames_idx]\n            elif results['format'] == 'frame':\n                frames_idx = list(offsets + 1)\n            elif results['format'] == 'MRI':\n                frames_idx = list(offsets)\n            else:\n                raise NotImplementedError\n            return self._get(frames_idx, results)\n        average_dur = int(frames_len / self.num_seg)\n        if not self.select_left:\n            if self.dense_sample:  # For ppTSM\n                if not self.valid_mode:  # train\n                    sample_pos = max(1, 1 + frames_len - 64)\n                    t_stride = 64 // self.num_seg\n                    start_idx = 0 if sample_pos == 1 else np.random.randint(\n                        0, sample_pos - 1)\n                    offsets = [(idx * t_stride + start_idx) % frames_len + 1\n                               for idx in range(self.num_seg)]"
        },
        {
            "comment": "The code determines the sampling position based on frames length, number of segments, and valid mode. If no offsets are provided, it calculates the starting positions for each segment using a linear space. Then, it generates the offsets by multiplying the stride with the current segment index and adding the start index. Finally, if in valid mode, it randomly selects indices within the average duration per segment and adds them to the offsets list.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":223-244",
            "content": "                    frames_idx = offsets\n                else:\n                    sample_pos = max(1, 1 + frames_len - 64)\n                    t_stride = 64 // self.num_seg\n                    start_list = np.linspace(0,\n                                             sample_pos - 1,\n                                             num=10,\n                                             dtype=int)\n                    offsets = []\n                    for start_idx in start_list.tolist():\n                        offsets += [\n                            (idx * t_stride + start_idx) % frames_len + 1\n                            for idx in range(self.num_seg)\n                        ]\n                    frames_idx = offsets\n            else:\n                for i in range(self.num_seg):\n                    idx = 0\n                    if not self.valid_mode:\n                        if average_dur >= self.seg_len:\n                            idx = random.randint(0, average_dur - self.seg_len)\n                            idx += i * average_dur"
        },
        {
            "comment": "Code calculates index based on average duration, then appends corresponding frame indices to frames_idx list based on the format specified in results. If the format is not recognized, it raises NotImplementedError. Finally, it returns the frames_idx and results to an unknown method.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":245-267",
            "content": "                        elif average_dur >= 1:\n                            idx += i * average_dur\n                        else:\n                            idx = i\n                    else:\n                        if average_dur >= self.seg_len:\n                            idx = (average_dur - 1) // 2\n                            idx += i * average_dur\n                        elif average_dur >= 1:\n                            idx += i * average_dur\n                        else:\n                            idx = i\n                    for jj in range(idx, idx + self.seg_len):\n                        if results['format'] == 'video':\n                            frames_idx.append(int(jj % frames_len))\n                        elif results['format'] == 'frame':\n                            frames_idx.append(jj + 1)\n                        elif results['format'] == 'MRI':\n                            frames_idx.append(jj)\n                        else:\n                            raise NotImplementedError\n            return self._get(frames_idx, results)"
        },
        {
            "comment": "This code generates random offsets for selecting frames from a video. If the valid mode is not enabled, it randomly selects frame offsets within the available duration or number of frames. If the valid mode is enabled, it evenly distributes the frames across the video duration. The 'format' variable determines if the selected frames are in video format.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":269-291",
            "content": "        else:  # for TSM\n            if not self.valid_mode:\n                if average_dur > 0:\n                    offsets = np.multiply(list(range(self.num_seg)),\n                                          average_dur) + np.random.randint(\n                                              average_dur, size=self.num_seg)\n                elif frames_len > self.num_seg:\n                    offsets = np.sort(\n                        np.random.randint(frames_len, size=self.num_seg))\n                else:\n                    offsets = np.zeros(shape=(self.num_seg, ))\n            else:\n                if frames_len > self.num_seg:\n                    average_dur_float = frames_len / self.num_seg\n                    offsets = np.array([\n                        int(average_dur_float / 2.0 + average_dur_float * x)\n                        for x in range(self.num_seg)\n                    ])\n                else:\n                    offsets = np.zeros(shape=(self.num_seg, ))\n            if results['format'] == 'video':\n                frames_idx = list(offsets)"
        },
        {
            "comment": "This code snippet defines a SamplerPkl class that samples frames' indices for video loading. It takes arguments num_seg, seg_len, and backend and returns the index of sampled frames. Depending on the results format ('frame', 'MRI', or others), it sets the frames_idx accordingly before returning it.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":292-326",
            "content": "                frames_idx = [x % frames_len for x in frames_idx]\n            elif results['format'] == 'frame':\n                frames_idx = list(offsets + 1)\n            elif results['format'] == 'MRI':\n                frames_idx = list(offsets)\n            else:\n                raise NotImplementedError\n            return self._get(frames_idx, results)\n@PIPELINES.register()\nclass SamplerPkl(object):\n    \"\"\"\n    Sample frames id.\n    NOTE: Use PIL to read image here, has diff with CV2\n    Args:\n        num_seg(int): number of segments.\n        seg_len(int): number of sampled frames in each segment.\n        mode(str): 'train', 'valid'\n    Returns:\n        frames_idx: the index of sampled #frames.\n    \"\"\"\n    def __init__(self, num_seg, seg_len, backend='pillow', valid_mode=False):\n        self.num_seg = num_seg\n        self.seg_len = seg_len\n        self.valid_mode = valid_mode\n        self.backend = backend\n    def _get(self, buf):\n        if isinstance(buf, str):\n            img = Image.open(StringIO(buf))\n        else:"
        },
        {
            "comment": "This code is part of a pipeline for image sampling in video processing. It loads data from disk, converts images to RGB format, and handles labels. The `__call__` method takes results as input, retrieves the video name, label, and frames from the loaded data. If the label is a dictionary or has multiple elements, it assigns the label to '\u52a8\u4f5c\u7c7b\u578b' or randomly chooses between the first two elements. It sets the 'frames_len' based on the length of frames and calculates the average duration per segment. Then, it initializes an empty list for the images and loops through the segments to create image samples. If valid mode is not enabled, it also resets the index variable.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":327-357",
            "content": "            img = Image.open(BytesIO(buf))\n        img = img.convert('RGB')\n        if self.backend != 'pillow':\n            img = np.array(img)\n        return img\n    def __call__(self, results):\n        \"\"\"\n        Args:\n            frames_len: length of frames.\n        return:\n            sampling id.\n        \"\"\"\n        filename = results['frame_dir']\n        data_loaded = pickle.load(open(filename, 'rb'), encoding='bytes')\n        video_name, label, frames = data_loaded\n        if isinstance(label, dict):\n            label = label['\u52a8\u4f5c\u7c7b\u578b']\n            results['labels'] = label\n        elif len(label) == 1:\n            results['labels'] = int(label[0])\n        else:\n            results['labels'] = int(label[0]) if random.random() < 0.5 else int(\n                label[1])\n        results['frames_len'] = len(frames)\n        frames_len = results['frames_len']\n        average_dur = int(int(frames_len) / self.num_seg)\n        imgs = []\n        for i in range(self.num_seg):\n            idx = 0\n            if not self.valid_mode:"
        },
        {
            "comment": "The code calculates the index for a segment of frames based on average duration and frame length. It then retrieves images from the frames list, appends them to imgs, sets backend type, and returns the results including the imgs and backend information.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/loader/pipelines/sample.py\":358-381",
            "content": "                if average_dur >= self.seg_len:\n                    idx = random.randint(0, average_dur - self.seg_len)\n                    idx += i * average_dur\n                elif average_dur >= 1:\n                    idx += i * average_dur\n                else:\n                    idx = i\n            else:\n                if average_dur >= self.seg_len:\n                    idx = (average_dur - 1) // 2\n                    idx += i * average_dur\n                elif average_dur >= 1:\n                    idx += i * average_dur\n                else:\n                    idx = i\n            for jj in range(idx, idx + self.seg_len):\n                imgbuf = frames[int(jj % results['frames_len'])]\n                img = self._get(imgbuf)\n                imgs.append(img)\n        results['backend'] = self.backend\n        results['imgs'] = imgs\n        return results"
        }
    ]
}