{
    "summary": "The code initializes a SamplingResult class for bbox sampling and defines a RandomSampler class to sample positive and negative bboxes from assigned results, ensuring enough samples are available in each case.",
    "details": [
        {
            "comment": "This code is importing necessary libraries and defining a class called \"SamplingResult\" that holds the result of bbox sampling. The class has attributes for positive indices, negative indices, bboxes, gt_bboxes, assign_result, and gt_flags. It uses paddle library to index select the bboxes based on pos_inds. Negative_inds may be empty.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/samplers/random_sampler.py\":0-27",
            "content": "# copyright (c) 2021 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport paddle\nimport numpy as np\nfrom ..registry import BBOX_SAMPLERS\nclass SamplingResult():\n    \"\"\"Bbox sampling result.  \"\"\"\n    def __init__(self, pos_inds, neg_inds, bboxes, gt_bboxes, assign_result,\n                 gt_flags):\n        self.pos_inds = pos_inds\n        self.neg_inds = neg_inds\n        self.pos_bboxes = paddle.index_select(bboxes,pos_inds)\n        # neg_inds may be empty\n        if neg_inds.shape[0]!=0:"
        },
        {
            "comment": "This code initializes the negative bounding boxes, positive ground truth (gt) bounding boxes and labels for a sampler. It checks if there are any gt bboxes available, if not, it sets up a placeholder for them. The 'pos_bboxes' are then concatenated with the neg_bboxes if they exist. If assign_result.labels is not None, it also extracts and stores positive gt labels.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/samplers/random_sampler.py\":28-54",
            "content": "            self.neg_bboxes = paddle.index_select(bboxes,neg_inds)\n        else:\n            self.neg_bboxes=None\n        self.pos_is_gt  = paddle.index_select(gt_flags,pos_inds)\n        self.num_gts = gt_bboxes.shape[0]\n        self.pos_assigned_gt_inds = paddle.index_select(assign_result.gt_inds,pos_inds) - 1\n        if float(gt_bboxes.numel()) == 0:\n            assert self.pos_assigned_gt_inds.numel() == 0\n            self.pos_gt_bboxes = paddle.empty_like(gt_bboxes).view(-1, 4)\n        else:\n            if len(gt_bboxes.shape) < 2:\n                gt_bboxes = gt_bboxes.view(-1, 4)\n            self.pos_gt_bboxes = paddle.index_select(gt_bboxes, self.pos_assigned_gt_inds)\n        if assign_result.labels is not None:\n            self.pos_gt_labels = paddle.index_select(assign_result.labels, pos_inds)\n        else:\n            self.pos_gt_labels = None\n    @property\n    def bboxes(self):\n        if self.neg_bboxes is not None:\n            ret = paddle.concat([self.pos_bboxes, self.neg_bboxes])\n        else:"
        },
        {
            "comment": "This code defines a RandomSampler class which samples positive and negative bboxes from assigned results. It takes arguments like num, pos_fraction, neg_pos_ub, add_gt_as_proposals, etc. If add_gt_as_proposals is True and gt_bboxes are present, it raises a ValueError if gt_labels are not given. The sample method takes assign_result, bboxes, gt_bboxes, and gt_labels as arguments. It checks the shape of bboxes, converts them to 4-column format, and creates gt_flags.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/samplers/random_sampler.py\":55-91",
            "content": "            # neg bbox may be empty\n            ret = self.pos_bboxes\n        return ret\n@BBOX_SAMPLERS.register()\nclass RandomSampler():\n    def __init__(self,\n                 num,\n                 pos_fraction,\n                 neg_pos_ub=-1,\n                 add_gt_as_proposals=True,\n                 **kwargs):\n        self.num = num\n        self.pos_fraction = pos_fraction\n        self.neg_pos_ub = neg_pos_ub\n        self.add_gt_as_proposals = add_gt_as_proposals\n    def sample(self,\n               assign_result,\n               bboxes,\n               gt_bboxes,\n               gt_labels=None,\n               **kwargs):\n        \"\"\"Sample positive and negative bboxes.  \"\"\"\n        if len(bboxes.shape) < 2:\n            bboxes = bboxes[None, :]\n        bboxes = bboxes[:, :4]\n        gt_flags = paddle.full([bboxes.shape[0], ], 0, dtype='int32')\n        if self.add_gt_as_proposals and len(gt_bboxes) > 0:\n            if gt_labels is None:\n                raise ValueError(\n                    'gt_labels must be given when add_gt_as_proposals is True')"
        },
        {
            "comment": "This code samples positive and negative indices for assigning ground truth labels to objects, ensuring a desired ratio of positive and negative samples. It then creates a SamplingResult object containing these indices along with bounding boxes and other information. The random_choice function is used to randomly select a specific number of samples from a given set of objects.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/samplers/random_sampler.py\":92-113",
            "content": "            bboxes = paddle.concat([gt_bboxes, bboxes])\n            assign_result.add_gt_(gt_labels)\n            gt_ones = paddle.full([gt_bboxes.shape[0], ], 1, dtype='int32')\n            gt_flags = paddle.concat([gt_ones, gt_flags])\n        #1. \u5f97\u5230\u6b63\u6837\u672c\u7684\u6570\u91cf, inds\n        num_expected_pos = int(self.num * self.pos_fraction)\n        pos_inds = self._sample_pos( assign_result, num_expected_pos, bboxes=bboxes, **kwargs)\n        pos_inds = paddle.to_tensor(np.unique(pos_inds.numpy()))\n        #2. \u5f97\u5230\u8d1f\u6837\u672c\u7684\u6570\u91cf, inds\n        num_sampled_pos = pos_inds.numel()\n        num_expected_neg = self.num - num_sampled_pos\n        neg_inds = self._sample_neg(\n            assign_result, num_expected_neg, bboxes=bboxes, **kwargs)\n        neg_inds = paddle.to_tensor(np.unique(neg_inds.numpy()))\n        #3. \u5f97\u5230sampling result\n        sampling_result = SamplingResult(pos_inds, neg_inds, bboxes, gt_bboxes,\n                                         assign_result, gt_flags)\n        return sampling_result\n    def random_choice(self, gallery, num):"
        },
        {
            "comment": "The code defines a random sampler that randomly selects elements from the gallery. It has two functions: _sample_pos, which randomly samples positive samples, and _sample_neg, which randomly samples negative samples. The _sample_pos function first finds indexes of assign_result with label greater than 0 (i.e., positive samples), then checks if the number of positive samples is less than or equal to num_expected. If it's less, returns the indices; otherwise, selects num_expected random samples from the available indices using the random_choice method. The _sample_neg function does a similar process for negative samples but doesn't return the indices if their number is 0.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/samplers/random_sampler.py\":114-138",
            "content": "        \"\"\"Random select some elements from the gallery.  \"\"\"\n        assert len(gallery) >= num\n        perm = paddle.arange(gallery.numel())[:num]\n        perm = paddle.randperm(gallery.numel())[:num] \n        rand_inds = paddle.index_select(gallery, perm)\n        return rand_inds\n    def _sample_pos(self, assign_result, num_expected, **kwargs):\n        \"\"\"Randomly sample some positive samples.\"\"\"\n        #1.\u9996\u5148\u770b\u4e00\u4e0b\u7ed9\u7684bboxes\u91cc\u9762\u6709\u54ea\u4e9blabel\u662f\u5927\u4e8e0\u7684 \u5f97\u5230\u4e86\u4ed6\u4eec\u7684index\n        pos_inds = paddle.nonzero(assign_result.gt_inds, as_tuple=False)\n        #2. \u53ea\u8981\u8fd9\u4e2apos_inds\u7684\u6570\u76ee\u4e0d\u662f0\u4e2a \u8fd9\u4e9b\u5c31\u90fd\u53ef\u4ee5\u662fpositive sample\n        # \u5f53pos_inds\u7684\u6570\u76ee\u5c0f\u4e8enum_expected(\u60f3\u8981\u7684sample\u7684\u6700\u5927\u6570\u76ee), \u5c31\u76f4\u63a5\u7528\u8fd9\u4e2apos_inds\n        # \u53cd\u4e4b\u5c31\u4ece\u8fd9\u4e48\u591aindex\u91cc\u968f\u673a\u91c7\u6837num_expected\u4e2a\u51fa\u6765\n        if float(pos_inds.numel()) != 0:\n            pos_inds = pos_inds.squeeze() \n        if float(pos_inds.numel()) <= num_expected:\n            return pos_inds\n        else:\n            return self.random_choice(pos_inds, num_expected)\n    def _sample_neg(self, assign_result, num_expected, **kwargs):\n        \"\"\"Randomly sample some negative samples.\"\"\""
        },
        {
            "comment": "This code checks the assign_result's gt_inds for zero values, extracts their indices in neg_inds, and if there are non-zero values, squeezes them. If the number of non-zero values is less than or equal to expected, it returns neg_inds. Otherwise, it uses random_choice() to select required indices from neg_inds.",
            "location": "\"/media/root/Prima/works/PaddleVideo/docs/src/paddlevideo/modeling/samplers/random_sampler.py\":139-145",
            "content": "        neg_inds = paddle.nonzero(assign_result.gt_inds == 0, as_tuple=False)\n        if float(neg_inds.numel()) != 0:\n            neg_inds = neg_inds.squeeze() \n        if (float(neg_inds.numel())) <= float(num_expected):\n            return neg_inds\n        else:\n            return self.random_choice(neg_inds, num_expected)"
        }
    ]
}